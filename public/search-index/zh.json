[{"id":"2018_ICPC_Singapore","title":"é¢˜è§£ 2018 ICPC Asia Singapore Regional Contest","content":"å®˜æ–¹è‹±æ–‡é¢˜è§£A. Bitwiseä»é«˜ä½å¾€ä½ä½è´ªå¿ƒï¼Œå†™ä¸€ä¸ªå‡½æ•°åˆ¤æ–­èƒ½å¦è‡³å°‘å¾—åˆ°ã€‚å¦‚ä½•åˆ¤æ–­èƒ½å¦è‡³å°‘å¾—åˆ°ï¼Ÿä¾ç„¶æ˜¯è´ªå¿ƒçš„æ€è·¯ï¼Œæˆ‘ä»¬ä»æŸä¸€ä½å¼€å§‹ï¼Œè®°å½•å½“å‰çš„æˆ–å€¼ï¼Œå¦‚æœå¤§äºå°±å¼€å§‹æ–°çš„ä¸€å—ã€‚ä½†å¦‚æœä»æ¯ä¸ªæ•°éƒ½å¼€å§‹è¯•ä¸€éçš„è¯æ—¶é—´å¤æ‚åº¦æ˜¯ã€‚ä½†æ˜¯æˆ‘ä»¬å‘ç°æ¯ä¸ªå—çš„ç»“æŸä½ç½®ä¸€å®šæ˜¯æŸä¸€ä½å˜æˆ1çš„ä½ç½®ï¼Œæ‰€ä»¥è¯´å¼€å§‹çš„ä½ç½®å…¶å®å¹¶ä¸é‡è¦ï¼Œæœ€å¤šåªä¼šå°‘ç®—ä¸€ä¸ªéƒ¨åˆ†ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬éå†ä¸¤åœˆï¼Œå¦‚æœè‡³å°‘æœ‰ä¸ªå—çš„è¯å°±è¯´æ˜æ˜¯å¯è¡Œçš„ã€‚#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin>>n>>k;\n    vector<int> a(n*2);\n    for (int i=0; i<n; i++) {\n        cin>>a[i];\n        a[i+n]=a[i];\n    }\n    auto can=[&](int x) -> bool {\n        int cnt=0, cur=0;\n        for (int i=0; i<2*n; i++) {\n            cur|=a[i];\n            if ((cur&x)==x) {\n                cnt++;\n                cur=0;\n            }\n        }\n        return cnt>=2*k-1;\n    };\n    int ans=0;\n    for (int bit=31; bit>=0; bit--) {\n        if (can(ans|(1<<bit))) ans|=(1<<bit);\n    }\n    cout<<ans;\n    return 0;\n}B. Conveyor Beltsæˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ªç‚¹æ‹†æˆä¸ªç‚¹ï¼Œç¬¬ä¸ªç‚¹ä»£è¡¨ç¬¬æ—¶åˆ»ã€‚åŸå›¾ä¸­çš„è¾¹æ‹†å®Œä¹‹åå°±å˜æˆäº†çš„ç¬¬æ—¶åˆ»è¿åˆ°çš„ç¬¬æ—¶åˆ»ï¼Œå®¹é‡ä¸º1ã€‚è¿™æ ·å°±ä¿è¯äº†æ¯æ—¶åˆ»æ¯æ¡ä¼ é€å¸¦ä¸Šåªæœ‰ä¸€ä¸ªç‰©å“ã€‚ç„¶åæ·»åŠ ä¸€ä¸ªè¶…çº§æºç‚¹ï¼Œè¿åˆ°ç¬¬ä¸ªproducerçš„ç¬¬æ—¶åˆ»ï¼Œå®¹é‡ä¸º1ã€‚æœ€åä»ç¬¬ä¸ªç‚¹çš„æ¯ä¸€ä¸ªæ—¶åˆ»è¿åˆ°ä¸€ä¸ªè¶…çº§æ±‡ç‚¹ï¼Œå®¹é‡ä¸ºæ— ç©·å¤§ã€‚ç„¶åè·‘ä¸ªæœ€å¤§æµå°±è¡Œäº†ã€‚#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\n// indexed from 0!\nstruct Flow {\n    static constexpr int INF = 1e9;\n    int n;\n    struct Edge {\n        int to, cap;\n        Edge(int to, int cap) : to(to), cap(cap) {}\n    };\n    std::vector<Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n    Flow(int n) : n(n), g(n) {}\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t) return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t) return f;\n        int r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i) {\n            int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0) return f;\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k, m;\n    cin>>n>>k>>m;\n    Flow mf(n*k+2);\n    for (int i=0; i<m; i++) {\n        int x, y;\n        cin>>x>>y;\n        x--, y--;\n        for (int j=0; j<k; j++) {\n            mf.addEdge(x*k+j, y*k+(j+1)%k, 1);\n        }\n    }\n    for (int i=0; i<k; i++) mf.addEdge(n*k, i*k+i, 1);\n    for (int i=0; i<k; i++) mf.addEdge((n-1)*k+i, n*k+1, 1e9);\n    cout<<mf.maxFlow(n*k, n*k+1);\n    return 0;\n}C. Free Foodæš´åŠ›æ ‡è®°æ¯ä¸€å¤©å³å¯D. Hopperså¦‚æœæœ‰é•¿åº¦ä¸ºå¥‡æ•°çš„ç¯çš„è¯å¹¶ä¸”æ•´ä¸ªç½‘ç»œè¿é€šå°±èƒ½ä¼ æ’­åˆ°æ•´ä¸ªç½‘ç»œã€‚æ‰€ä»¥åªå°‘æ£€æŸ¥æ¯ä¸ªè¿é€šåˆ†é‡æ˜¯ä¸æ˜¯äºŒåˆ†å›¾å¹¶è®¡ç®—è¿é€šåˆ†é‡çš„ä¸ªæ•°å°±è¡Œäº†ã€‚é˜Ÿå‹å†™çš„æ‰€ä»¥æ²¡æœ‰ä»£ç QAQE. Largest Triangleè¿™é¢˜è¿‡äºç»å…¸ï¼Œç½‘ä¸Šåº”è¯¥æœ‰å¾ˆå¤šé¢˜è§£ã€‚G. Non-Prime Factorså…ˆé¢„å¤„ç†ç­”æ¡ˆï¼Œç±»ä¼¼ç­›æ³•çš„æ€è·¯ï¼šå¦‚æœä¸æ˜¯è´¨æ•°å°±æŠŠå®ƒçš„å€æ•°ä»¬çš„ç­”æ¡ˆåŠ 1,è´¨æ•°å°±æŠŠå®ƒçš„å€æ•°ä»¬æ ‡è®°æˆåˆæ•°ã€‚è¾“å‡ºè¯¢é—®å³å¯ã€‚å¿«è¯»è²Œä¼¼ä¸æ˜¯å¾ˆæœ‰å¿…è¦ã€‚#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nnamespace IO {\nconst int MAXSIZE = 1 << 20;\nchar buf[MAXSIZE], *p1, *p2;\n#define gc()                                                               \\\n  (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\\n       ? EOF                                                               \\\n       : *p1++)\ninline int rd() {\n  int x = 0, f = 1;\n  char c = gc();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = gc();\n  }\n  while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc();\n  return x * f;\n}\nchar pbuf[1 << 20], *pp = pbuf;\ninline void push(const char &c) {\n  if (pp - pbuf == 1 << 20) fwrite(pbuf, 1, 1 << 20, stdout), pp = pbuf;\n  *pp++ = c;\n}\ninline void write(int x) {\n  static int sta[35];\n  int top = 0;\n  do {\n    sta[top++] = x % 10, x /= 10;\n  } while (x);\n  while (top) push(sta[--top] + '0');\n}\n}  //\nconst int N=2e6;\nint ans[N+1];\nbool not_prime[N+1];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int q=IO::rd();\n\n    for (int i=2; i<=N; i++) {\n        if (!not_prime[i]) {\n            for (int j=i+i; j<=N; j+=i)\n                not_prime[j]=1;\n        } else {\n            for (int j=i; j<=N; j+=i) {\n                ans[j]++;\n            }\n        }\n    }\n    while (q--) {\n        int x=IO::rd();\n        printf(\"%d\\n\", ans[x]+1);\n    }\n    return 0;\n}J. SG Coinå…¶å®å°±æ˜¯ä¸ªå–æ¨¡ä¸‹çš„å‡æ³•ã€‚ã€‚ã€‚L. Wi Knowé¦–å…ˆæˆ‘ä»¬è§‚å¯Ÿåˆ°ï¼šå¯¹äºï¼Œä¸€å®šä¸å·®äºã€‚æ‰€ä»¥åœ¨ ä¸­ç¬¬ä¸€ä¸ªAæˆ‘ä»¬ä¸€å®šé€‰åœ¨ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„Aã€‚åŒç†ï¼Œç¬¬äºŒä¸ªBä¸€å®šé€‰ä¸­æœ€åä¸€å‡ºç°çš„Bã€‚è§£æ³•çš„å¤§è‡´æ€è·¯å°±æ˜¯å›ºå®šBæ‰¾æœ€å°çš„Aã€‚ä¸€ç§æ¯”è¾ƒnaiveçš„æ€è·¯æ˜¯åœ¨ä¸­æŸ¥è¯¢æœ€å°å€¼ï¼Œä½†æœ‰ä¸¤ä¸ªé—®é¢˜ï¼šä¸çŸ¥é“æœ€å°å€¼åœ¨ä¹‹å‰æœ‰æ²¡æœ‰å‡ºç°è¿‡ã€‚æœ€å°å€¼å¯èƒ½ç­‰äºã€‚æ‰€ä»¥æˆ‘ä»¬ä¸èƒ½ä¸€æ¬¡æŠŠæ‰€æœ‰çš„æ•°éƒ½æ”¾åˆ°çº¿æ®µæ ‘é‡Œï¼Œè¦æŒ‰ä¸€å®šçš„é¡ºåºæ”¾ã€‚å¯¹äºæ¯ä¸ªä½ç½®ï¼Œæˆ‘ä»¬è®°å½•ä¸€ä¸ªä¸ºçš„ä¸‹ä¸€ä¸ªå‡ºç°ä½ç½®ã€‚ç„¶åæˆ‘ä»¬éå†ï¼Œé¦–å…ˆæŸ¥è¯¢ä¸­çš„æœ€å°å€¼minï¼Œç„¶åç”¨æ›´æ–°ç­”æ¡ˆï¼Œæœ€ååœ¨çº¿æ®µæ ‘ä¸­æŠŠè®¾ä¸ºã€‚è¿™æ ·ä¸ºä»€ä¹ˆé¿å…äº†ä¸Šé¢çš„ä¸¤ä¸ªé—®é¢˜å‘¢ï¼Ÿé¦–å…ˆï¼Œåªæœ‰åœ¨ä¹‹å‰å‡ºç°è¿‡çš„æ•°æ‰ä¼šè¢«åŠ è¿›å»ï¼Œé¿å…äº†é—®é¢˜1ï¼Œç„¶åæˆ‘ä»¬æ˜¯å…ˆæŸ¥è¯¢å†æ·»åŠ ï¼Œè€Œä¸”ä¸€æ¬¡åªåŠ ä¸€ä¸ªï¼Œè¿™æ ·å°±é¿å…é—®é¢˜2ã€‚æ€»ä¹‹è¿™ä¸ªè§£æ³•è¿˜æ˜¯å¾ˆå¦™çš„ï¼Œæ¯”å®˜æ–¹é¢˜è§£ç®€å•ä¸å°‘ã€‚#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nstruct SegTree{\n    int n;\n    vector<int> t;\n    SegTree(int n_):n(n_),t(4*n, 1e9){}\n    void pushup(int node){\n        t[node]=min(t[node<<1],t[node<<1|1]);\n    }\n    void update(int node,int i,int x,int l,int r){\n        if(l==r){\n            t[node]=x;\n            return;\n        }\n        int mid=(l+r)/2;\n        if(i<=mid) update(node<<1,i,x,l,mid);\n        else update(node<<1|1,i,x,mid+1,r);\n        pushup(node);\n    }\n    void update(int i, int x) {\n        update(1, i, x, 0, n-1);\n    }\n    int query(int node,int ql,int qr,int l,int r){\n        if (ql > r || qr < l) return 1e9;\n        if(ql<=l&&qr>=r){\n            return t[node];\n        }\n        int mid=(l+r)>>1;\n        return min(query(node<<1,ql,qr,l,mid), query(node<<1|1,ql,qr,mid+1,r));\n    }\n    int query(int l, int r) {\n        return query(1, l, r, 0, n-1);\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> a(n);\n    vector<int> pos(n+1, -1), nxt(n, -1), last(n+1, -1);\n    for (int i=0; i<n; i++) {\n        cin>>a[i];\n        last[a[i]]=i;\n    }\n    for (int i=n-1; i>=0; i--) {\n        nxt[i]=pos[a[i]];\n        pos[a[i]]=i;\n    }\n    pair<int, int> ans={n+1, n+1};\n    SegTree st(n);\n    for (int i=0; i<n; i++) {\n        int x=st.query(i+1, last[a[i]] - 1);\n        ans=min(ans, { x, a[i] });\n        st.update(nxt[i], a[i]);\n    }\n    if (ans.first<=n) cout<<ans.first<<' '<<ans.second<<'\\n';\n    else cout << -1;\n    return 0;\n}"},{"id":"2019_ECNA_K","title":"é¢˜è§£ 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","content":"æ„Ÿè§‰æŒºå¥—è·¯çš„ï¼Œä½†å½“æ—¶å¤ªèœäº†ä¸ä¼šåšï¼Œæ˜¯é“ä¸é”™çš„é¢˜SolutionFor brevity, let's use  denote A, E, I, O, U.Let  be the cost to put all the bins of type  consecutively to where ends at .For the 5 types of bins, there's are  combinations of relative order. Let   be the best cost to put  types of bins such that the last type of bins ends at . Obviously,  can be one of of .For ,  can be calculated from :Time complexity:  (correct me if I'm wrong).é¢˜è§£é¦–å…ˆå…ˆç®—å‡ºæŠŠæ¯ä¸€ç§ç®±å­æ”¾åˆ°ç»“å°¾ä¸ºçš„ä½ç½®çš„èŠ±è´¹ï¼Œç„¶åéå†  ç§ç›¸å¯¹ä½ç½®é¡ºåºï¼Œç„¶åè®°å½•æŠŠå‰ç§ç®±å­æ”¾åˆ°ç»“å°¾ä¸ºçš„ä½ç½®çš„èŠ±è´¹ã€‚ å…·ä½“è½¬ç§»å…¬å¼çœ‹ä¸Šé¢å§ï¼Œæ‡’å¾—å¤åˆ¶äº†QAQ.Code#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin>>s;\n    int n=(int)s.size();\n    vector<int> a(n), bins(n);\n    for (auto& i : a) cin>>i;\n    map<char, int> mp{{'A', 0}, {'E', 1}, {'I', 2}, {'O', 3}, {'U', 4}};\n    int cnt[5]{}, totalCost[5]{};\n    int d;\n    cin>>d;\n    while (d--) {\n        int x;\n        cin>>x;\n        x--;\n        a[x]=0;\n        s[x]='X';\n    }\n    for (int i=0; i<n; i++) {\n        auto c=s[i];\n        if (c!='X') {\n            cnt[mp[c]]++;\n            totalCost[mp[c]]+=a[i];\n            bins[i]=mp[c];\n        } else bins[i]=-1;\n    }\n    string t;\n    cin>>t;\n    if (t!=\"X\") for (auto c : t) cnt[mp[c]]++;\n    constexpr int INF=1e9;\n    vector endCost(5, vector(n, INF));\n    auto bestCost=endCost;\n    for (int bin=0; bin<5; bin++) {\n        for (int i=0; i<n; i++) {\n            if (i>=cnt[bin]-1) {\n                endCost[bin][i]=totalCost[bin];\n                for (int j=0; j<cnt[bin]; j++) {\n                    if (bins[i-j]==bin) endCost[bin][i]-=a[i-j];\n                }\n            }\n        }\n    }\n    int ans=1e9;\n    vector<bool> available(5, true);\n    auto solve=[&](auto& solve, int level) -> void{\n        if (level==0) {\n            for (int o=0; o<5; o++) {\n                available[o]=false;\n                bestCost[0]=endCost[o];\n                solve(solve, 1);\n                available[o]=true;\n            }\n        } else if (level==5) {\n            ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end()));\n        } else {\n            for (int o=0; o<5; o++) {\n                if (available[o]) {\n                    available[o]=false;\n                    int spaceNeeded=0;\n                    for (int o2=0; o2<5; o2++) {\n                        if (!available[o2]) spaceNeeded+=cnt[o2];\n                    }\n                    for (int i=0; i<n; i++) {\n                        bestCost[level][i]=INF;\n                        if (i>=spaceNeeded-1) {\n                            for (int j=0; j<i-cnt[o]+1; j++) {\n                                bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]);\n                            }\n                        }\n                    }\n                    solve(solve, level+1);\n                    available[o]=true;\n                }\n            }\n        }\n\n    };\n    solve(solve, 0);\n    cout<<ans;\n    return 0;\n}"},{"id":"2019summary","title":"æˆ‘çš„2019","content":"è½¬çœ¼å°±åˆ°äº†2019å¹´çš„æœ€åä¸€å¤©äº†ã€‚çœ‹åˆ°äº†å¾ˆå¤šäººçš„å›é¡¾å’Œæ€»ç»“ï¼Œåˆæƒ³åˆ°äº†ä»Šå¹´å‘ç”Ÿçš„ä¸€äº›äº‹æƒ…ï¼Œå¿ƒæƒ³æˆ‘ä¹Ÿå¯ä»¥å†™ç‚¹æµæ°´è´¦å•Šã€‚2019å‘ç”Ÿçš„æœ€å¤§çš„äº‹ï¼Œè«è¿‡äºæˆ‘ä»ä¸­å›½æ¥åˆ°äº†åŠ æ‹¿å¤§ã€‚å½“ç„¶ä¹Ÿæœ‰å¾ˆå¤šåˆ«çš„äº‹æƒ…å€¼å¾—å›å¿†ï¼šå­¦äº†è‡ªç”±æ³³ã€æ‰“äº†åŒºåŸŸèµ›ã€æ¡¥å¼sub20ã€å­¦ä¼šåšèœâ€¦â€¦å…ˆè¯´è¯´ç•™å­¦ï¼Œè¿™ä¸ªå†³å®šå…¶å®æ¯”è¾ƒçªç„¶ï¼Œä½†è€ƒè™‘åˆ°æ—¶é—´æœ‰ç‚¹æ™šï¼Œæ‰€ä»¥å‡†å¤‡çš„è¿‡ç¨‹ä¹Ÿæ˜¯ç´§é”£å¯†é¼“ã€‚å¯¹æˆ‘æ¥è¯´æœ€å¤§çš„æŒ‘æˆ˜å°±æ˜¯è€ƒé›…æ€ï¼ŒæŠ¥äº†ä¸ªç½‘è¯¾ï¼Œå­¦ä¸€æ•´ä¸ªå¯’å‡çš„æ—¶é—´ï¼Œä½†è‡ªå·±å´æ²¡å¤ªåŠªåŠ›ï¼Œé˜…è¯»å’Œå¬åŠ›ç›¸å¯¹ç®€å•ï¼Œè‡ªå·±æœ€æ‹…å¿ƒçš„è¿˜æ˜¯å†™ä½œå’Œå£è¯­ï¼Œå°¤å…¶æ˜¯å£è¯­ï¼Œå› ä¸ºæ˜¯æœ€éš¾ç»ƒä¹ çš„ï¼Œå†åŠ ä¸Šè‡ªå·±ä¹Ÿæ²¡è®¤çœŸå‡†å¤‡ç´ æï¼Œä»¥è‡³äºè€ƒè¯•å‰å¤•å¼‚å¸¸ç´§å¼ ï¼Œæœç„¶æœ€åæˆç»©åªæœ‰5.5ã€‚æ­¤æ—¶å¸Œæœ›å…¨éƒ½æ”¾åœ¨äº†ä¸‹ä¸€æ¬¡è€ƒè¯•ä¸Šé¢ï¼Œä¸¤æ¬¡è€ƒè¯•ä¸­é—´çš„åå‡ å¤©ä¹Ÿå…¨ç”¨åœ¨äº†å‡†å¤‡å£è¯­ä¸Šï¼Œå€¼å¾—åº†å¹¸çš„æ˜¯ç¢°åˆ°äº†è‡ªå·±æ¯”è¾ƒç†Ÿæ‚‰çš„è¯é¢˜ï¼Œè‡ªæˆ‘æ„Ÿè§‰è‰¯å¥½ã€‚å¥½æ­¹è¾¾åˆ°äº†ä¹‹å‰çš„ç›®æ ‡ï¼ˆè™½ç„¶åªæœ‰6åˆ†ï¼‰ã€‚ä»å¹´åˆå¼€å§‹å‡†å¤‡ä¸€ç›´åˆ°4æœˆä¸­æ—¬æ‹¿åˆ°æˆç»©ï¼Œå†åˆ°4æœˆåº•æ‹¿åˆ°çº¦å…‹çš„offerï¼Œè¿™ä»¶äº‹æ€»ç®—å‘Šä¸€æ®µè½ã€‚\n\nè¿™ä¸€å¹´ä¹Ÿæ˜¯acmèµ·æ­¥çš„ç¬¬ä¸€å¹´ï¼Œè™½ç„¶ä¸­é—´ç»å†äº†ä¸€äº›æ³¢æŠ˜ï¼Œä½†æœ€åè¿˜æ˜¯å†³å®šèµ°åœ¨æ¡è·¯ã€‚å¯’å‡è®­ç»ƒæ‰“å¼€äº†ç®—æ³•è¿›é˜¶çš„é—¨ï¼Œå­¦æœŸåˆšå¼€å§‹è®­ç»ƒè¿˜æ¯”è¾ƒæ­£å¸¸ï¼Œè€ƒå®Œé›…æ€ä¹‹åå°±å¼€å§‹æ”¾é£è‡ªæˆ‘ï¼Œå¤©å¤©æ³¡åœ¨å®éªŒå®¤ï¼Œæœ‰æ®µæ—¶é—´å°±æ˜¯å¤©å¤©æ•²çº¿æ®µæ ‘ï¼Œæœ€ååŸºæœ¬ä¸Šåšå®Œäº† â€œå¤§å¯çº¿æ®µæ ‘26é¢˜â€,å½“æ—¶æ„Ÿè§‰è¿˜æ˜¯æƒ³å½“çˆ½çš„~æœŸé—´æ‰“äº†åŒ—äº¤æ ¡èµ›ï¼Œå¡åœ¨äº†é“é¢˜æ„ä¸æ¸…çš„çƒ‚é¢˜ä¸Šï¼Œè¢«åŒ—äº¤å¤§ä½¬åŠæ‰“ã€‚è¿˜å»äº†åŒ—å·¥æ‰“äº†ç¨‹åºè®¾è®¡å¤©æ¢¯èµ›ï¼Œæ·±åˆ»ä½“ä¼šåˆ°äº†ä»€ä¹ˆå«â€œæš´åŠ›ç¢¾æ ‡ç®—â€ï¼Œæœ€åæ··äº†ä¸ªé“œå¥–ã€‚æ”¾å‡å‰æ‰“äº†åŒ—æ—æ ¡èµ›ï¼ŒçŸ®å­é‡Œé¢æ‹”é«˜ä¸ªï¼Œè¿æ°”å¥½å‡ºäº†6é¢˜æ··äº†ç¬¬å››è¿˜èµšäº†200å—ï¼Œä¸å¾—ä¸è¯´è¿™å¥–é‡‘è¿˜æ˜¯å¾ˆå¤§æ°”çš„ã€‚è½¬çœ¼åˆ°äº†æš‘å‡ï¼Œç”±äºæš‘å‡é›†è®­å‰è¿˜æœ‰å°å­¦æœŸï¼Œå†åŠ ä¸Šåœ¨åŒ—äº¬ä¹Ÿæ²¡ä»€ä¹ˆå¥½å¾…çš„äº†ï¼Œäºæ˜¯å°±æ—©æ—©å›äº†å®¶ï¼Œæš‘å‡é›†è®­ä¹Ÿå°±ä¸æäº†ï¼Œé”™è¿‡äº†ä¸€äº›ç®—æ³•ï¼Œä¸è¿‡ç°åœ¨çœ‹æ¥å¤§éƒ¨åˆ†ä¹Ÿæ²¡æœºä¼šç”¨æ¯•ç«Ÿç®€å•é¢˜è¿˜åšä¸å¥½ã€‚åœ¨å®¶çš„æ—¶å€™è€ƒè™‘åˆ°äº†å»äº†åŠ æ‹¿å¤§è¿˜è¦ä¸è¦ç»§ç»­æ‰“acmï¼Œä½†åˆä¸çŸ¥é“é‚£è¾¹çš„æ¯”èµ›æƒ…å†µï¼Œäºæ˜¯å°±å…ˆé€‰æ‹©äº†æš‚æ—¶æ”¾ä¸‹acmï¼Œç­‰åˆ°äº†é‚£è¾¹å†è¯´ï¼Œäºæ˜¯ä¸€ä¸ªæš‘å‡æ²¡æ€ä¹ˆæ•²ä»£ç ã€‚åˆ°äº†çº¦å…‹æ²¡å‡ å¤©ä¾¿æ”¶åˆ°äº†å…³äºecna regional contesté€‰æ‹”èµ›çš„é‚®ä»¶ï¼Œå¯æŠŠæˆ‘æ¿€åŠ¨åäº†ï¼Œä¸å‡ºæ„å¤–çš„æ‹¿åˆ°äº†å‚èµ›åé¢ï¼Œæœ€å6ä¸ªäººé‡Œé¢3ä¸ªç”¨C++çš„æ­£å¥½å‡‘ä¸€ä¸ªé˜Ÿï¼Œæäº†ä¸€åœºè®­ç»ƒå‘ç°é˜Ÿå‹å¹¶ä¸å¼ºï¼Œé‚£ä»Šå¹´å°±å½“å»ç©ç©ç†Ÿæ‚‰æ¯”èµ›äº†ã€‚å› ä¸ºé˜Ÿå‹éƒ½ä¸ä½åœ¨å­¦æ ¡ï¼Œä¸€èµ·è®­ç»ƒä¸å¤ªæ–¹ä¾¿ï¼Œæ‰€ä»¥è¿˜æ˜¯ä»¥ä¸ªäººè®­ç»ƒä¸ºä¸»ï¼ŒæœŸé—´è‡ªå·±ä¹Ÿå¼€å§‹æ‰“cfï¼Œç åŠ›æœ‰æ‰€æ¢å¤ã€‚æ¯”èµ›åœ¨æ¸©èå¤§å­¦ï¼Œæ•™ç»ƒå¼€è½¦å¸¦æˆ‘ä»¬è¿‡å»ï¼Œä¸‹åˆåˆ°äº†å…ˆç­¾åˆ°ç„¶åå°±ç­‰ç€çƒ­èº«èµ›ï¼Œæ»‘å¤§æ²¡æœ‰æ”¾æ°´å¾ˆå¿«å°±akäº†ï¼Œè€Œæˆ‘ä»¬æœ€å1åˆ†é’Ÿæ‰è¿‡äº†4é¢˜æ’ç¬¬10ï¼Œæ¯•ç«Ÿå¥½å¤šæ”¾æ°´çš„ï¼Œæ„Ÿè§‰çŠ¶æ€è¿˜è¡Œï¼Œç»“æŸä¹‹ååƒäº†ç‚¹ä¸»åŠæ–¹æä¾›çš„æŠ«è¨ç„¶åæˆ‘ä»¬å°±å»å®¾é¦†äº†ï¼Œæ•™ç»ƒå®šçš„å®¾é¦†ç¦»å­¦æ ¡å¾ˆè¿‘ï¼Œæ¡ä»¶ä¹Ÿç›¸å½“å¥½ï¼ˆé™¤äº†æ²¡æœ‰çƒ­æ°´æ´—æ¾¡ï¼‰æœ¬æƒ³æ—©ç‚¹ç¡çš„ï¼Œç»“æœå’Œé˜Ÿå‹èŠåˆ°12ç‚¹å¤šâ€¦â€¦\nç¬¬äºŒå¤©ä¸€æ—©åƒäº†æ—©é¥­å°±èµ¶èµ´èµ›åœºï¼Œè™½è¯´æ˜¯æ¥ç©ç©çš„ï¼Œä½†æ¯”èµ›å¼€å§‹å‰è¿˜æ˜¯ç›¸å½“ç´§å¼ çš„ï¼ŒæŒ‰ç…§ä¹‹å‰çš„è®¡åˆ’ï¼Œä¸‰ä¸ªäººåˆ†åˆ«è¯»å‰ä¸­åï¼Œæˆ‘å¯èƒ½æ˜¯æ€¥äºæƒ³å¿«é€Ÿæ‰¾åˆ°ç­¾åˆ°é¢˜ï¼Œè¯»å®Œåè€Œæ²¡ä»€ä¹ˆå°è±¡ï¼Œä»¥è‡³äºç­¾åˆ°é¢˜ä¹Ÿè§‰å¾—æ¯”è¾ƒéš¾ï¼Œè€Œé˜Ÿå‹ä¹Ÿè¯»åˆ°äº†ç­¾åˆ°é¢˜ä½†ç»™æˆ‘è§£é‡Šçš„æ—¶å€™æ²¡æŠ“ä½é‡ç‚¹ï¼Œè¯´äº†åŠå¤©æˆ‘æ‰æ˜ç™½ï¼Œå°±æ˜¯åœ¨ä¸€ä¸ªä¸å•è°ƒçš„åºåˆ—é‡Œå¼ºè¡ŒäºŒåˆ†ï¼Œçœ‹æ˜¯å¦èƒ½æ‰¾åˆ°æŸä¸ªæ•°ï¼Œç»“æœæˆ‘ç”¨äº†waäº†ä¸¤å‘æœ€åæ‰‹å†™äºŒåˆ†æ‰è¿‡çš„ï¼Œè€Œæ­¤æ—¶å·²ç»52åˆ†é’Ÿäº†ï¼Œå’Œé¢„è®¡çš„èŠ‚å¥ï¼ˆ1å°æ—¶åšå®Œç­¾åˆ°ï¼‰ä¸¥é‡ä¸ç¬¦ï¼Œä½†è¿˜å¥½ä¹Ÿæ²¡æ‹–å¤ªä¹…ï¼Œä¸€ä¸ªåŠå°æ—¶çš„æ—¶å€™åšå®Œäº†æ‰€æœ‰ä¸‰é“ç­¾åˆ°ã€‚ç„¶åå‘ç°ä¸€ä¸ªå¾ˆå¤šäººè¿‡çš„dpé¢˜ï¼Œä½†è‡ªå·±dpå¾ˆå·®ï¼Œå†™äº†ä¸€ä¸ªwaäº†ä¹‹åå‘ç°æ€è·¯æœ‰é—®é¢˜ï¼Œå°±å¼€å§‹æ€€ç–‘æ˜¯ä¸æ˜¯dpï¼Œæƒ³äº†å¾ˆä¹…ä¹Ÿæ²¡ä»€ä¹ˆæƒ³æ³•å°±å»çœ‹åˆ«çš„é¢˜äº†ï¼Œçœ‹åˆ°ä¸€ä¸ªä¸­å›½å‰©ä½™å®šç†çš„æ¿å­é¢˜ç„¶è€Œæ¿å­é‡Œå¹¶æ²¡æœ‰å°ï¼Œå½“æ—¶å†…å¿ƒä¸€ä¸‹å°±å‡‰äº†ï¼Œä¹Ÿæˆä¸ºäº†è¿™æ¬¡æœ€å¤§çš„é—æ†¾ã€‚é˜Ÿå‹è¯´å¯ä»¥å°è¯•æ¨ä¸€ä¸‹ä¸è¿‡æœ€åä¹Ÿæ²¡æ¨å‡ºæ¥ï¼Œæ²¡è¿‡å¤šå°±å‘ç°å‹å¯¹æŠŠé‚£ä¸ªdpé¢˜è¿‡äº†ï¼Œç„¶åé˜Ÿå‹å°±ä¸€å†æé†’æˆ‘è¯´é‚£ä¸ªé¢˜è‚¯å®šä¸éš¾å› ä¸ºå‹é˜Ÿä¸ä¼šå›¾è®ºï¼Œåˆæƒ³äº†å¥½ä¹…çªç„¶å¼€çªå‘ç°å¤šåŠ ä¸€ä¸ªdpçŠ¶æ€å°±è¡Œäº†ï¼Œèµ¶ç´§å»å†™ç„¶è€Œåˆ¤å®šè¾¹ç•Œçš„å‡½æ•°æ²¡å†™å¥½æœ€åæ‰å‘ç°ï¼Œåœ¨è¿˜æœ‰åŠå°æ—¶ç»“æŸçš„æ—¶å€™è¿‡äº†â€¦â€¦æœ€åæˆ‘ä»¬æ’34/120ï¼Œå‹é˜Ÿæ’31ï¼Œä¸å¥½ä¹Ÿä¸åï¼Œåæ­£æ•™ç»ƒæŒºé«˜å…´çš„ã€‚ä½†æˆ‘æ·±çŸ¥è¿™ç»å¯¹ä¸æ˜¯æˆ‘ä»¬çš„æ°´å¹³ã€‚\nå›å­¦æ ¡ä¹‹åä¸€åˆ‡åˆå›å½’æ­£å¸¸ï¼Œåœ¨å¯’å‡ç–¯ç‹‚æ‰åˆ†ä¹‹åå‘ç°ä¹‹å‰åœ¨åœ°å¤§çš„è®­ç»ƒéå¸¸æœ‰é—®é¢˜ï¼Œéå¸¸ä¸æ³¨é‡åŸºæœ¬åŠŸï¼Œä»¥è‡³äºç»å¸¸å¡åœ¨cé¢˜æˆ–dé¢˜ï¼Œè€Œäº‹å®ä¸Šè¿™äº›é¢˜éƒ½ä¸éœ€è¦å¤šä¹ˆé«˜çº§çš„ç®—æ³•ï¼Œäºæ˜¯è‡ªå·±å¼€å§‹ç»ƒä¸€äº›ç®€å•æˆ–ä¸­ç­‰éš¾åº¦çš„æš´åŠ›å’Œæ„é€ é¢˜ï¼Œç»ˆäºåœ¨2019æœ€åä¸€åœºæ­¢ä½äº†æ‰åˆ†åŒæ—¶ä¹Ÿä¿ä½äº†æ­£çš„å‡€åˆ†æ•°å˜åŒ–ã€‚æœ€åå†è¯´è¯´åšé¥­å§ï¼Œå…¶å®è¿™æŒºç¥å¥‡çš„ï¼Œæ¥ä¹‹å‰å®Œå…¨ä¸ä¼šåšé¥­ï¼Œæ„Ÿè§‰è‡ªå·±æ¥äº†ä¸€ä¸‹å°±ä¼šäº†å“ˆå“ˆï¼Œæ¥çš„ç¬¬äºŒå¤©å°±å¼€å§‹æ‰¾èƒ½ä¹°èœçš„è¶…å¸‚ï¼Œè¿˜å¥½å­¦æ ¡è¥¿è¾¹æœ‰ä¸€ä¸ªäºšï¼ˆä¸­ï¼‰æ´²ï¼ˆå›½ï¼‰è¶…å¸‚ï¼Œè¿™å¯çœŸæ˜¯å¤ªæ–¹ä¾¿äº†ã€‚é£Ÿæè§£å†³ä¹‹åå°±æ˜¯æŠ€æœ¯äº†ï¼Œåœ¨è€çˆ¸å’Œç½‘ä¸Šçš„èœè°±æŒ‡å¯¼ä¹‹ä¸‹æ…¢æ…¢å½¢æˆäº†è‡ªå·±çš„ä¸€å¥—ç†è®ºï¼Œå…¶å®ä¹Ÿæ²¡ä»€ä¹ˆéº»çƒ¦ï¼Œç®€å•çš„å®¶å¸¸èœå°±è¶³å¤Ÿåº”ä»˜æ¯æ—¥é¥®é£Ÿäº†ã€‚å¯¹äºå­¦ä¼šåšèœè¿™ä»¶äº‹è‡ªå·±çœŸçš„æ˜¯å¾ˆå¼€å¿ƒçš„ï¼Œæ—¢çœé’±åˆåˆè‡ªå·±å£ï¼Œè¿™ä¹Ÿç®—æ˜¯ä¸€é¡¹é‡è¦çš„ç”Ÿæ´»æŠ€èƒ½å•Šã€‚2019çœŸçš„æ˜¯æ”¶è·é¢‡ä¸°çš„ä¸€å¹´ï¼Œå¸Œæœ›è‡ªå·±åœ¨2020èƒ½ç»§ç»­è¿›æ­¥ï¼Œç«‹å‡ ä¸ªflag:cf1800åˆ†åŒºåŸŸèµ›è¿›å‰20æˆç»©ä¿æŒåœ¨Aä»¥ä¸Šä¸‰é€Ÿè‡³å°‘sub15åŠ æ²¹ï¼Œå¥¥åŠ›ç»™ï¼"},{"id":"2020_ICPC_ECNA","title":"2020 ICPC East Central NA Regional Contest æ€»ç»“ä¸é¢˜è§£","content":"ç®—æ˜¯æœ‰æ‰€è¿›æ­¥ä½†è¿˜æ˜¯ç¨æœ‰é—æ†¾ï¼Œå·®ä¸€é¢˜å°±èƒ½è¿›division championships.æ›´æ–°ï¼šæ‰€æœ‰7é¢˜é˜Ÿéƒ½ä»¥wildcardçš„èº«ä»½æ™‹çº§NADCäº†ï¼Œè€Œä¸”å¦‚æœæœ¬å­¦æ ¡åªæœ‰wildcardé˜Ÿçš„è¯ï¼Œä¼šè¢«åˆ†åˆ°æœ€å¼±çš„central divisionï¼Œç„¶åæˆ‘ä»¬åˆè«åå…¶å¦™çš„æ‹¿äº†ä¸ªç¬¬6ï¼Œæ™‹çº§NACäº†:joy:æ¯”èµ›è¿‡ç¨‹ä¸¤ä¸ªé˜Ÿå‹ä¸€ä¸ªç®€ç§°Tï¼Œä¸€ä¸ªç®€ç§°Jã€‚å¼€åœºæˆ‘ä»å‰å¾€åè¯»ï¼ŒAæ¯”è¾ƒé•¿å°±ç›´æ¥è·³è¿‡äº†ï¼Œè¯»äº†Bæ„Ÿè§‰æœ‰ç‚¹æƒ³æ³•ä½†åˆä¸æ˜¯å¾ˆç¡®å®šå°±æ¥ç€è¯»ï¼ŒCå¾ˆæ˜æ˜¾æ˜¯ä¸ªæ‰¾æœ€å¤§ç¯ï¼Œä¸€å¼€å§‹è¿˜è§‰å¾—æ¯”è¾ƒéº»çƒ¦ï¼Œä½†æƒ³æƒ³ä¸æ˜¯ç¯å°±æ˜¯é“¾æ‰€ä»¥ç›´æ¥dfså°±è¡Œäº†ã€‚åŒæ—¶é˜Ÿå‹Jè¯»åˆ°Eå‘ç°å°±æ˜¯ä¸ªçŸ©é˜µä¹˜æ³•äºæ˜¯å¼€å§‹å†™ï¼Œæˆ‘åˆè·Ÿæ¦œåšäº†Gã€‚ä¹‹åä¸ä¹…é˜Ÿå‹Jçš„Eä¹Ÿè¿‡äº†ã€‚å¦ä¸€ä¸ªé˜Ÿå‹Tè¯»äº†Hæ˜¯è´ªå¿ƒä½†ä¸ä¼šå†™ï¼Œæˆ‘æ­¤æ—¶åœ¨å†™Bçš„æš´åŠ›ï¼ˆä½†å…¶å®ç¨å¾®æƒ³æƒ³æš´åŠ›è‚¯å®šè¶…æ—¶ä½†ä¸çŸ¥é“ä¸ºå•¥è¿˜æ˜¯å†™å®Œäº†ï¼‰ã€‚Bæš´åŠ›å†™å®Œæ‰å‘ç°ä¼šè¶…æ—¶ï¼Œæ­¤æ—¶Hè¿˜æ²¡åšå‡ºæ¥ï¼Œæˆ‘çœ‹äº†ä¸€çœ¼ä¹Ÿæ²¡æƒ³æ³•ï¼Œå°±æ‰”ç»™é˜Ÿå‹Jäº†ã€‚ç„¶åå‘ç°Bå¥½åƒå¯ä»¥dpï¼Œç„¶åå°±ä¸€è¾¹æƒ³ä¸€è¾¹å†™ï¼Œè™½ç„¶æœ‰ç‚¹æ¶å¿ƒä½†æŒºç›´æ¥çš„ï¼Œæœ€åä¸€éè¿‡ã€‚å†™Bçš„è¿‡ç¨‹ä¸­é˜Ÿå‹Jè¿‡äº†Hï¼Œç®—æ˜¯ç­¾å®Œåˆ°äº†ã€‚æ­¤æ—¶æ‰ä¸€ä¸ªåŠå°æ—¶ï¼Œæ„Ÿè§‰éå¸¸å¥½ï¼Œæ¯”å»å¹´é¡ºåˆ©å¤šäº†ã€‚ç„¶åæˆ‘åœ¨åšKï¼Œæ„Ÿè§‰æ˜¯dpï¼Œæœ‰ç‚¹æ€è·¯ä½†ä¸ä¼šå†™ï¼Œé˜Ÿå‹Jåœ¨åšJï¼Œè¿‡äº†æ ·ä¾‹ä½†æ˜¯WAï¼Œé˜Ÿå‹Tç›´æ¥å¼€Iäº†ï¼ˆå…¶å®æ˜¯æœ€éš¾çš„é¢˜orzï¼‰ã€‚äºæ˜¯ä¸‰ä¸ªäººéƒ½å¡é¢˜äº†ï¼Œä¸çŸ¥ä¸è§‰è¿‡äº†ä¸€ä¸ªåŠå°æ—¶æˆ‘ç»ˆäºæ”¾å¼ƒäº†ï¼Œæ­¤æ—¶Jé¢˜è¿‡äº†ä¸€å¤§å †ï¼Œäºæ˜¯æˆ‘å°±è·Ÿé˜Ÿå‹Jæ¢äº†ä¸€ä¸‹é¢˜ï¼Œç”±äºé˜Ÿå‹Jç”¨çš„pythonè€Œæˆ‘åˆæ‡’çš„çœ‹æ‰€ä»¥å°±å‡†å¤‡é‡å†™ï¼Œç„¶åæ²¡æƒ³åˆ°æ˜¯ä¸ªè¶…çº§æ¶å¿ƒæ¨¡æ‹Ÿé¢˜ï¼Œè€Œä¸”å†™äº†ä¸€å †bugï¼Œç¦»ç»“æŸè¿˜æœ‰åŠå°æ—¶å’Œé˜Ÿå‹Jå‡ ä¹åŒæ—¶è¿‡äº†Jå’ŒKã€‚ç„¶åä»”ç»†ä¸€çœ‹Aå‘ç°å¾ˆç®€å•ä½†è¾“å‡ºæ ¼å¼å¾ˆæ¶å¿ƒï¼Œæœ€åè™½ç„¶å‹‰å¼ºå†™å®Œä½†æ²¡æ—¶é—´debugï¼Œä»¥7é¢˜æ”¶åœºã€‚åæ€å¡é¢˜å¤ªä¹…æ²¡æœ‰åŠæ—¶æ”¾å¼ƒï¼Œå“ªæ€•å»è¯»è¯»åˆ«çš„é¢˜ã€‚é¢˜æ²¡æœ‰éƒ½è¯»ä¸€éï¼Œé˜Ÿå‹Jå…¶å®è¯»äº†Aä½†æ„Ÿè§‰å¾ˆéº»çƒ¦ï¼Œä½†æˆ‘æ„Ÿè§‰æ¯”Jå¥½åšå¤šäº†ï¼ˆå¯èƒ½æˆ‘Jå†™çš„å¤ªçƒ‚äº†ï¼‰ã€‚Låˆ°æœ€åä¹Ÿæ²¡äººè¯»ï¼Œå…¶å®ä¹Ÿä¸éš¾ï¼Œå°±æ˜¯ä¸ªäºŒåˆ†å›¾åŒ¹é…çš„æ¿å­ é¢˜ã€‚æ‰€ä»¥è¯´ä¹Ÿä¸èƒ½ä¸€å‘³çš„è·Ÿæ¦œï¼Œæ¯•ç«Ÿæ¯ä¸ªäººçš„çŸ¥è¯†ç‚¹è¦†ç›–ä¸ä¸€æ ·ã€‚ä½†Kå¡åŠå¤©æ²¡åšå‡ºæ¥ä¹Ÿä¸åº”è¯¥ã€‚é¢˜è§£Aæ•°æ®å¾ˆå°ï¼Œæ‰¾lcaç›´æ¥æš´åŠ›ç½‘ä¸Šè·³ä¹Ÿå¯ä»¥ã€‚è¾“å‡ºæ ¼å¼æ¯”è¾ƒæ¶å¿ƒï¼Œè¦å¤šçœ‹å‡ éï¼Œæ³¨æ„ä¸è¦æŠŠè¾“å‡ºæˆ ã€‚#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, T;\n    cin>>n>>T;\n    vector<vector<string>> a(n);\n    vector<string> name(n);\n    unordered_map<string, int> id;\n    for (int i=0; i<n; i++) {\n        cin>>name[i];\n        id.try_emplace(name[i], id.size());\n        int x;\n        cin>>x;\n        a[i].resize(x);\n        for (auto& s : a[i]) {\n            cin>>s;\n            id.try_emplace(s, id.size());\n        }\n    }\n    vector<vector<int>> g(id.size());\n    vector<int> ind(id.size());\n    for (int i=0; i<n; i++) {\n        int u=id[name[i]];\n        for (auto& s : a[i]) {\n            g[u].push_back(id[s]);\n            ind[id[s]]++;\n        }\n    }\n    vector<int> pa(id.size());\n    vector<int> dep(id.size());\n    auto dfs=[&](auto& dfs, int u, int p) -> void {\n        pa[u] = p;\n        for (auto v : g[u]) {\n            if (v == p) continue;\n            dep[v]=dep[u]+1;\n            dfs(dfs, v, u);\n        }\n    };\n\n    auto lca=[&](int x, int y) {\n        while (x!=y) {\n            if (dep[x]<dep[y]) swap(x, y);\n            x=pa[x];\n        }\n        return x;\n    };\n\n    for (int i=0; i<id.size(); i++) {\n        if (ind[i]==0) {\n            dfs(dfs, i, i);\n            break;\n        }\n    }\n    auto ordinal=[](int x) {\n        auto s=to_string(x);\n        if (x>=11 && x<=13) return s+\"th\";\n        if (x%10==1) return s+\"st\";\n        if (x%10==2) return s+\"nd\";\n        if (x%10==3) return s+\"rd\";\n        return s+\"th\";\n    };\n    while (T--) {\n        string s, t;\n        cin>>s>>t;\n        int l=lca(id[s], id[t]);\n        int m=dep[id[s]]-dep[l];\n        int n=dep[id[t]]-dep[l];\n        int swaped=0;\n        if (m>n) {\n            swap(m, n);\n            swaped=1;\n            swap(s, t);\n        }\n        if (m==0) {\n            swap(s, t);\n            if (n==1) {\n                cout<<s<<\" is the child of \"<<t<<'\\n';\n            } else {\n                n-=2;\n                cout<<s<<\" is the \";\n                for (int i=0; i<n; i++) cout<<\"great \";\n                cout<<\"grandchild of \"<<t<<'\\n';\n            }\n        } else if (m==n && m>0) {\n            if (swaped) swap(s, t);\n            if (n==1) cout<<s<<\" and \"<<t<<\" are siblings\\n\";\n            else {\n                n--;\n                cout<<s<<\" and \"<<t<<\" are \"<<ordinal(n)<<\" cousins\\n\";\n            }\n        } else if (n>m && m>0) {\n            if (swaped) swap(s, t);\n            if (n-m==1)\n                cout<<s<<\" and \"<<t<<\" are \"<< ordinal(m-1)<<\" cousins, 1 time removed\\n\";\n            else \n                cout<<s<<\" and \"<<t<<\" are \"<<ordinal(m-1)<<\" cousins, \"<<n-m<<\" times removed\\n\";\n        }\n    }\n        return 0;\n}B ä»£è¡¨æ˜¯å¦å­˜åœ¨ä»¥åæ ‡  çš„å­—ç¬¦ç»“å°¾ï¼Œè¦†ç›–ç›®æ ‡å­—ç¬¦ä¸²çš„å‰ä¸ªå­—ç¬¦ï¼Œè½¬å‘æ¬¡ï¼Œç»“æŸæ—¶çš„æ–¹å‘æ˜¯çš„èµ°æ³•ã€‚æ³¨æ„é•¿åº¦ä¸ºçš„å­—ç¬¦ä¸²æœ€å¤šè½¬æ¬¡ï¼Œè™½ç„¶ç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯æ²¡æœ‰æ–¹å‘çš„ï¼Œä½†ä¸ºäº†è½¬ç§»æ–¹ä¾¿å°±å˜æˆäº†æ‰€æœ‰æ–¹å‘ï¼Œæ‰€ä»¥æšä¸¾è½¬å‘æ¬¡æ•°çš„è¯è¦é™åˆ¶ä¸€ä¸‹ï¼Œä¸ç„¶ä¼šå‡ºç°é•¿åº¦ä¸º2è½¬ä¸¤æ¬¡çš„èµ°æ³•ã€‚#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint dp[10][10][105][105][8];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin>>n>>m;\n    vector a(n, vector<char>(m));\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<m; j++) {\n            cin>>a[i][j];\n        }\n    }\n    int limit;\n    string s;\n    cin>>limit>>s;\n    limit=min(limit, int(s.size()));\n    const vector<pair<int, int>> dirs{{1, 0}, {-1, 0}, {0,1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<m; j++) {\n            if (a[i][j]==s[0]) {\n                for (int d=0; d<8; d++) \n                    dp[i][j][0][0][d]=1;\n            }\n        }\n    }\n    for (int i=1; i<s.size(); i++) {\n        for (int x=0; x<n; x++) {\n            for (int y=0; y<m; y++) {\n                if (a[x][y]!=s[i]) continue;\n                for (int used=0; used<=min(limit, i-1); used++) {\n                    for (int d=0; d<8; d++) {\n                        for (int pd=0; pd<8; pd++) {\n                            auto [dx, dy]=dirs[d];\n                            unsigned nx=x+dx, ny=y+dy;\n                            int pused=used-(d!=pd);\n                            // if (i==1) pused=0;\n                            if (nx<n && ny<m && pused>=0 && dp[nx][ny][i-1][pused][pd]) {\n                                dp[x][y][i][used][d]=1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<m; j++) {\n            for (int d=0; d<8; d++)\n                if (dp[i][j][s.size()-1][limit][d]) \n                    return cout<<\"Yes\", 0;\n        }\n    }\n    cout<<\"No\";\n    return 0;\n}Cç”±äºæ¯ä¸ªç‰©å“æœ€å¤šåªæœ‰ä¸€ä¸ªäººè¦ï¼Œæ‰€ä»¥æ¯ä¸ªç‚¹çš„å‡ºåº¦æœ€å¤šä¸º1ï¼Œæ‰€ä»¥æ¯ä¸ªè¿é€šåˆ†é‡è¦ä¹ˆæ˜¯ç¯è¦ä¹ˆæ˜¯é“¾ã€‚ç›´æ¥dfså³å¯ã€‚#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<vector<int>> g(n);\n    struct node {\n        string name, has, wants;\n    };\n    vector<node> a(n);\n    unordered_map<string, int> names, toys;\n    unordered_map<string, string> wanted_by;\n    for (auto& [name, has, wants] : a) {\n        cin>>name>>has>>wants;\n        names.try_emplace(name, names.size());\n        toys.try_emplace(has, toys.size());\n        toys.try_emplace(wants, toys.size());\n        wanted_by[wants]=name;\n    }\n    for (int i=0; i<n; i++) {\n        if (wanted_by.count(a[i].has))\n            g[i].push_back(names[wanted_by[a[i].has]]);\n    }\n    vector<int> vis(n);\n    int ans=0;\n    auto dfs=[&](auto& dfs, int u, int dep) -> void{\n        vis[u]=1;\n        for (auto v : g[u]) {\n            if (vis[v]==1) {\n                ans=max(ans, dep+1);\n            } else {\n                dfs(dfs, v, dep+1);\n            }\n        }\n        vis[u]=2;\n    };\n    for (int i=0; i<n; i++) {\n        if (!vis[i]) {\n            dfs(dfs, i, 0);\n        }\n    }\n    if (ans) cout<<ans;\n    else cout<<\"No trades possible\";\n    return 0;\n}Dè¿˜æ²¡æ¥å¾—åŠè¡¥Eéå¸¸ç®€å•çš„çŸ©é˜µä¹˜æ³•ï¼Œé˜Ÿå‹å†™çš„ï¼Œæ²¡è¦ä»£ç ã€‚ã€‚ã€‚FçŸ©é˜µæ±‚é€†ï¼Œæ¨¡è¿ç®—ä¸‹çš„é«˜æ–¯æ¶ˆå…ƒã€‚é˜Ÿå‹èµ›åè¡¥çš„using namespace std;\n#include <bits/stdc++.h>\n#include <string>\n#define ll long long\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define FOR(i,n) for(int (i)=0;(i)<(n);++(i))\n#define PRE(i,m,n,in) for(int (i)=(m);(i)<(n);i+=in)\n#define RPRE(i,m,n,in) for(int (i)=(m);(i)>=(n);i-=in)\n#define srt(v) sort(v.begin(),v.end())\n#define printv(a) printa(a,0,a.size())\n#define debug(x) cout<<#x\" = \"<<(x)<<endl\n#define printa(a,L,R) for(int i=L;i<R;i++) cout<<a[i]<<(i==R-1?\"\\n\":\" \")\n#define printv(a) printa(a,0,a.size())\n#define print2d(a,r,c) for(int i=0;i<r;i++) for(int j=0;j<c;j++) cout<<a[i][j]<<(j==c-1?\"\\n\":\" \")\ntypedef vector<string>VS;\ntypedef pair<int,int>pii;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>VL;\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<VL>VVL;\ntypedef vector<pii>VII;\n\nconst int MOD = 37;\nconst int INF = 2; \n\nint gauss (vector < vector<int> > &a, vector<int> & ans, const vector<ll>&inv) {\n  int n = (int) a.size(); int m = (int) a[0].size() - 1;\n  vector<int> where (m, -1);\n  for (int col=0, row=0; col<m && row<n; ++col) {\n    int sel = row;\n    for (int i=row; i<n; ++i)\n      if ( a[i][col] > a[sel][col]) sel = i;\n    if (a[sel][col] == 0) continue;\n    for (int i=col; i<=m; ++i)\n      swap (a[sel][i], a[row][i]);\n    where[col] = row;\n    for (int i=0; i<n; ++i) \n      if (i != row) {\n        int c = (a[i][col] * inv[a[row][col]]) % MOD;\n        for (int j=col; j<=m; ++j)\n          a[i][j] = (a[i][j] - (a[row][j]*c % MOD) + MOD) % MOD;\n      }\n    ++row;\n  }\n\n  ans.assign (m, 0);\n  for (int i=0; i<m; ++i)\n    if (where[i] != -1)\n      ans[i] = (a[where[i]][m] * inv[a[where[i]][i]]) % MOD;\n  for (int i=0; i<n; ++i) {\n    int sum = 0;\n    for (int j=0; j<m; ++j)\n      sum = (MOD + sum + (ans[j] * a[i][j]) % MOD) % MOD;\n    if (abs (sum - a[i][m]) != 0)\n      return 0;\n  }\n  for (int i=0; i<m; ++i)\n    if (where[i] == -1) return INF;\n  return 1;\n}\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  string ns; getline(cin, ns); int n = stoi(ns);\n  string s1; getline(cin, s1); \n  string s2; getline(cin, s2);\n  vector<ll> inv(MOD);\n  inv[1]=1;\n  for(int i = 2; i < MOD; ++i) inv[i] = MOD - (MOD/i) * inv[MOD % i] % MOD;\n  vector< vector <int> > v1( n , vector <int> ()); \n  vector< vector <int> > v2( n , vector <int> ()); \n  for(int i = 0; i < s1.size(); i++) {\n    int num;\n    if(s1[i] >= 'A' && s1[i] <= 'Z') {\n      num = int(s1[i]) - 65;\n    }\n    else if(s1[i] == ' ') num = 36;\n    else num = (s1[i] - '0') + 26;\n    v1[i % n].push_back(num);\n  }  \n  for(int i = 0; i < s2.size(); i++) {\n    int num;\n    if(s2[i] >= 'A' && s2[i] <= 'Z') {\n      num = int(s2[i]) - 65;\n    }\n    else if(s2[i] == ' ') num = 36;\n    else num = (s2[i] - '0') + 26;\n    v2[i % n].push_back(num);\n  }\n  int consistent = 0;\n  int many = 0;\n  int no = 0;\n  vector <vector <int> > sol;\n  for(int i = 0; i < n; i++) {\n    vector<vector<int>>a(v1[0].size(), vector<int>(n + 1));\n    vector<int>b(n);\n    for(int j = 0; j < v1[0].size(); j++) {\n      for(int k = 0; k < n; k++) {\n        a[j][k] = v1[k][j];\n      }\n      a[j][n] = v2[i][j]; \n    }\n    vector<int>ans;\n    int num = gauss(a, ans, inv);\n    if(num == 0) no++;\n    else if(num == 1) {\n      consistent++;\n      sol.push_back(ans);\n    }\n    else many++;\n  }\n  if(consistent == n) print2d(sol, n, n);\n  else if(no >= 1)cout << \"No solution\" << endl;\n  else if(many >= 1) cout << \"Too many solutions\" << endl;\n  return 0;\n}Gç›´æ¥æ¨¡æ‹Ÿå³å¯#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin>>n>>m;\n    vector<int> a(n), rank(n);\n    iota(all(a), 0);\n    iota(all(rank), 0);\n    while (m--) {\n        char c;\n        int u, v;\n        cin>>c>>u>>c>>v;\n        u--, v--;\n        if (rank[u]>rank[v]) {\n            for (int i=rank[v]; i<rank[u]; i++) {\n                a[i]=a[i+1];\n                rank[a[i]]=i;\n            }\n            a[rank[u]+1]=v;\n            rank[v]=rank[u]+1;\n        }\n    }\n    for (auto i : a) cout<<\"T\"<<i+1<<' ';\n    return 0;\n}Hæ ¹æ®deadlineæ’åºï¼Œç„¶åç»´æŠ¤æœ‰å¤šå°‘æ§½ä½å¯ä¾›ä¸éœ€è¦çº¸çš„å’Œéœ€è¦çº¸çš„äººç”¨ï¼ˆä»£ç é‡Œçš„æ•°ç»„ï¼‰,ä¸éœ€è¦çº¸çš„äººä¹Ÿå¯ä»¥ç”¨éœ€è¦çº¸çš„äººçš„æ§½ä½ã€‚ç„¶åæ ¹æ®äººæ•°ç›¸åº”çš„æ›´æ–°æ•°ç»„ã€‚é˜Ÿå‹çš„èµ›æ—¶çš„æºä»£ç from collections import *\nfrom functools import *\nfrom math import *\nimport sys\n\ninput = sys.stdin.readline\nsys.setrecursionlimit(2147483647)\nml = lambda: map(int, input().split())\n\ns, n = ml()\npeople = defaultdict(lambda: [0, 0])\nfor _ in range(n):\n    deadline, need = input().split()\n    deadline = int(deadline)\n    people[deadline][need[0] == \"y\"] += 1\n\nhave = [0, 0]\nprev = 0\nfor deadline in sorted(people.keys()):\n    have[1] += deadline - prev\n    have[0] += (deadline - prev) * (s - 1)\n    prev = deadline\n\n    dont, need = people[deadline]\n\n    do = min(dont, have[0])\n    dont -= do\n    have[0] -= do\n\n    if dont + need > have[1]:\n        print(\"No\")\n        break\n    have[1] -= dont + need\nelse:\n    print(\"Yes\")æˆ‘ç”¨C++åˆå†™äº†ä¸€é:#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int s, n;\n    cin>>s>>n;\n    map<int, array<int, 2>> people;\n    for (int i=0; i<n; i++) {\n        int deadline;\n        char need;\n        cin>>deadline>>need;\n        people[deadline][need=='y']++;\n    }\n    ll have[2]{};\n    int prev=0;\n    for (auto& [deadline, v] : people) {\n        have[1]+=deadline-prev;\n        have[0]+=ll(deadline-prev)*(s-1);\n        prev=deadline;\n\n        auto [dont, need]=v;\n\n        int Do=min<ll>(dont, have[0]);\n        dont-=Do;\n        have[0]-=Do;\n        if (dont+need>have[1]) {\n            return cout<<\"No\\n\", 0;\n        }\n        have[1]-=dont+need;\n    }\n    cout<<\"Yes\\n\";\n    return 0;\n}Iè¿˜æ²¡è¡¥Jæ ¹æ®é¢˜æ„æ¨¡æ‹Ÿå³å¯#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector a(9, vector(9, 0));\n    for (auto& v: a) for (auto& i : v) cin>>i;\n    auto check_row=[&](int row, auto& cnt, int x) {\n        for (int i=0; i<9; i++) {\n            cnt[row][i][x]=0;\n        }\n    };\n    auto check_col=[&](int col, auto& cnt, int x) {\n        for (int i=0; i<9; i++) {\n            cnt[i][col][x]=0;\n        }\n    };\n    auto check_grid=[&](int r, int c, auto& cnt, int x) {\n        int num=r/3*3+c/3;\n        r=num/3*3, c=num%3*3;\n        for (int i=r; i<r+3; i++) {\n            for (int j=c; j<c+3; j++) {\n                cnt[i][j][x]=0;\n            }\n        }\n    };\n    auto count_row=[&](int row, auto& cnt, int x) {\n        int c=0;\n        for (int i=0; i<9; i++) {\n            if (a[row][i]) continue;\n            c+=cnt[row][i][x];\n        }\n        return c;\n    };\n    auto count_col=[&](int col, auto& cnt, int x) {\n        int c=0;\n        for (int i=0; i<9; i++) {\n            if (a[i][col]) continue;\n            c+=cnt[i][col][x];\n        }\n        return c;\n    };\n    auto count_grid=[&](int r, int c, auto& cnt, int x) {\n        int num=r/3*3+c/3;\n        r=num/3*3, c=num%3*3;\n        int cc=0;\n        for (int i=r; i<r+3; i++) {\n            for (int j=c; j<c+3; j++) {\n                if (a[i][j]) continue;\n                cc+=cnt[i][j][x];\n            }\n        }\n        return cc;\n    };\n    while (true) {\n        int found=0;\n        vector cnt(9, vector(9, vector(10, 1)));\n        for (int i=0; i<9; i++) {\n            for (int j=0; j<9; j++) {\n                cnt[i][j][0]=0;\n                if (a[i][j]!=0) {\n                    check_col(j, cnt, a[i][j]);\n                    check_row(i, cnt, a[i][j]);\n                    check_grid(i, j, cnt, a[i][j]);\n                }\n            }\n        }\n        for (int i=0; i<9; i++) {\n            for (int j=0; j<9; j++) {\n                if (a[i][j]==0) {\n                    if (count(all(cnt[i][j]), 1)==1) {\n                        found=1;\n                        auto it=find(all(cnt[i][j]), 1);\n                        a[i][j]=it-cnt[i][j].begin();\n                        goto next;\n                    }\n                    for (int v=1; v<=9; v++) {\n                        if ((count_col(j, cnt, v)==1 || count_row(i, cnt, v)==1 || count_grid(i, j, cnt, v)==1) && cnt[i][j][v]) {\n                            found=1;\n                            a[i][j]=v;\n                            goto next;\n                        }\n                    }\n                }\n            }\n        }\nnext:\n        if (found==0) break;\n    }\n    int cc=0;\n    for (auto& v : a) for (auto i : v) cc+=i==0;\n    if (cc) {\n        cout<<\"Not easy\\n\";\n        for (auto& v : a) {\n            for (auto& i : v) {\n                if (i==0) cout<<'.';\n                else cout<<i;\n                cout<<' ';\n            }\n            cout<<'\\n';\n        }\n    } else {\n        cout<<\"Easy\\n\";\n        for (auto& v : a) {\n            for (auto i : v) cout<<i<<' ';\n            cout<<'\\n';\n        }\n    }\n    return 0;\n}Kæˆ‘ä»¬å¯ä»¥ç”¨ä¸€æ¬¡å®éªŒæŠŠå½“å‰é—®é¢˜å˜æˆä¸¤ä¸ªæ›´å°çš„å­é—®é¢˜ï¼Œå‡è®¾å½“å‰çš„æœ€å¤§é«˜åº¦æ˜¯, è¿˜å‰©ä¸ªpalletï¼Œå¦‚æœæˆ‘ä»¬ç”¨ä¸ªç®±å­è¯•ä¸€æ¬¡ï¼Œå¦‚æœpalletåäº†çš„è¯é‚£ä¹ˆé—®é¢˜å°±å˜æˆäº†ï¼šæœ€å¤§é«˜åº¦ä¸º, è¿˜å‰©ä¸ªpalletï¼›å¦‚æœæ²¡åçš„è¯é—®é¢˜å°±å˜æˆäº†é«˜åº¦ä¸ºï¼Œè¿˜å‰©ä¸ªpalletã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨dpã€‚æ±‚èŒƒå›´çš„è¿‡ç¨‹ä¸dpç±»ä¼¼ã€‚#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin>>n>>m;\n    vector need(n+1, vector(m+1, 0));\n    for (int i=0; i<=n; i++) need[i][1]=i;\n\n    for (int i=1; i<=n; i++) {\n        for (int pallet=2; pallet<=m; pallet++) {\n            int mn=n+1;\n            for (int j=1; j<=i; j++) {\n                int v1=need[j-1][pallet-1], v2=need[i-j][pallet];\n                mn=min(mn, max(v1, v2));\n            }\n            need[i][pallet]=mn+1;\n        }\n    }\n    int l=n, r=0;\n    int ans=need[n][m];\n    for (int i=1; i<=n; i++) {\n        if (max(need[i-1][m-1], need[n-i][m])+1==ans){\n            l=min(l, i);\n            r=max(r, i);\n        }\n    }\n    cout<<ans<<' ';\n    if (l==r) cout<<l;\n    else cout<<l<<'-'<<r;\n    return 0;\n}é˜Ÿå‹çš„äºŒåˆ†åšæ³•ï¼šï¼ˆå’Œæ‰”é¸¡è›‹é—®é¢˜ç±»ä¼¼ï¼‰from collections import *\nfrom functools import *\nfrom math import *\nimport sys\n\ninput = sys.stdin.readline\nsys.setrecursionlimit(2147483647)\nml = lambda: map(int, input().split())\n\ndef binomialCoeff(x, n, k):\n    sum = 0\n    term = 1\n    i = 1\n    while (i <= n and sum < k):\n        term *= x - i + 1\n        term /= i\n        sum += term\n        i += 1\n    return sum\n\ndef minTrials(eggs, floors):\n    if eggs == 0:\n        return floors and inf\n    low = 1\n    high = floors\n\n    while low < high:\n        mid = low + high >> 1\n        if binomialCoeff(mid, eggs, floors) < floors:\n            low = mid + 1\n        else:\n            high = mid\n\n    return low\n\ndef findX(eggs, floors):\n    low = 1\n    high = floors\n\n    while low < high:\n        mid = low + high >> 1\n        if minTrials(eggs, floors - mid) <= ans - 1:\n            high = mid\n        else:\n            low = mid + 1\n\n    return low\n\n\ndef findY(eggs, floors):\n    low = 1\n    high = floors\n\n    while low < high:\n        mid = low + high + 1 >> 1\n        if minTrials(eggs - 1, mid - 1) <= ans - 1:\n            low = mid\n        else:\n            high = mid - 1\n\n    return low\n\n# range: x to y\nfloors, eggs = ml()\nn = floors\nm = eggs\n# worst case: doesn't break on x and breaks on y\n# find smallest x s.t. minTrials(floors - x, eggs) <= ans - 1\n# find biggest y s.t. minTrials(y - 1, eggs - 1) <= ans - 1\n\nans = minTrials(eggs, floors)\nx = findX(eggs, floors)\ny = findY(eggs, floors)\n\nif x == y:\n    print(ans, x)\nelse:\n    print(ans, str(x) + \"-\" + str(y))Lå¯ä»¥è§‚å¯Ÿåˆ°ä¸€å®šæ˜¯ä¸Šé¢çš„å‡ ä¸ªé—¨ç”¨Aé€šé“ï¼Œå‰©ä¸‹ä¸‹é¢çš„ç”¨Bé€šé“ï¼Œæ‰€ä»¥å¯ä»¥æšä¸¾Aå’ŒBåˆ†ç•Œçš„ä½ç½®ï¼Œç„¶åå‰©ä¸‹çš„é—®é¢˜å°±æ˜¯å…¬å¯“åŒ¹é…é—¨ã€é—¨åŒ¹é…å·¥ä½œç«™äº†ï¼Œè·‘ä¸¤æ¬¡äºŒåˆ†å›¾æœ€å¤§æƒåŒ¹é…å³å¯ã€‚ä¹‹å‰åšè¿‡åŒ¹é…çš„é¢˜çš„è¯è¿™é¢˜åº”è¯¥æ˜¯å¾ˆç®€å•çš„ï¼Œå¯ä»¥å½“æ—¶æ²¡äººè¯»åˆ°ï¼Œä½†é˜Ÿå‹è¯»äº†ä¹Ÿä¸ä¸€å®šèƒ½ååº”è¿‡æ¥æ˜¯åŒ¹é…é—®é¢˜233ã€‚#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\ntemplate<typename T>\nclass Hungarian {\npublic:\n    int n, m;\n    vector< vector<T> > a;\n    vector<T> u, v;\n    vector<int> pa, pb, way;\n    vector<T> minv;\n    vector<bool> used;\n    T inf;\n    Hungarian(int _n, int _m) : n(_n), m(_m), a(n, vector<T>(m)), u(n+1), v(m+1), pa(n+1, -1), pb(m+1, -1), way(m, -1), minv(m), used(m+1) {\n        assert(n <= m);\n        inf = numeric_limits<T>::max();\n    }\n    inline void add_row(int i) {\n        fill(minv.begin(), minv.end(), inf);\n        fill(used.begin(), used.end(), false);\n        pb[m] = i;\n        pa[i] = m;\n        int j0 = m;\n        do {\n            used[j0] = true;\n            int i0 = pb[j0];\n            T delta = inf;\n            int j1 = -1;\n            for (int j = 0; j < m; j++) {\n                if (!used[j]) {\n                    T cur = a[i0][j] - u[i0] - v[j];\n                    if (cur < minv[j]) {\n                        minv[j] = cur;\n                        way[j] = j0;\n                    }\n                    if (minv[j] < delta) {\n                        delta = minv[j];\n                        j1 = j;\n                    }\n                }\n            }\n            for (int j = 0; j <= m; j++) {\n                if (used[j]) {\n                    u[pb[j]] += delta;\n                    v[j] -= delta;\n                } else {\n                    minv[j] -= delta;\n                }\n            }\n            j0 = j1;\n        } while (pb[j0] != -1);\n        do {\n            int j1 = way[j0];\n            pb[j0] = pb[j1];\n            pa[pb[j0]] = j0;\n            j0 = j1;\n        } while (j0 != m);\n    }\n    inline T current_score() {\n        return -v[m];\n    }\n    inline T solve() {\n        for (int i = 0; i < n; i++) {\n            add_row(i);\n        }\n        return current_score();\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector g1(n, vector(2*n, 0));\n    auto g2=g1;\n    for (auto& v : g1)\n        for (auto& i : v) cin>>i;\n    for (auto& v : g2)\n        for (auto& i : v) cin>>i;\n    int mn_cost=1e9;\n    vector<array<int, 3>> ans(n);\n    for (int i=-1; i<n; i++) {\n        vector ng1(n, vector(n, 0));\n        auto ng2=ng1;\n        for (int j=0; j<n; j++) {\n            for (int u=0; u<n; u++) {\n                ng1[u][j]=g1[u][j*2+(j>i)];\n                ng2[u][j]=g2[u][j*2+(j>i)];\n            }\n        }\n        Hungarian<int> h1(n, n), h2(n, n);\n        h1.a=ng1, h2.a=ng2;\n        if (int cur=h1.solve() + h2.solve(); cur <mn_cost) {\n            mn_cost=cur;\n            for (int j=0; j<n; j++) {\n                ans[j]={j, h1.pa[j]*2+(h1.pa[j]>i),h2.pb[h1.pa[j]]};\n            }\n        }\n    }\n    cout<<mn_cost<<'\\n';\n    for (auto [x, y , z] : ans) {\n        cout<<x+1<<' '<<y/2+1<<char('A'+y%2)<<' '<<z+1<<'\\n';\n    }\n    return 0;\n}"},{"id":"2021-ECNA","title":"2021 ECNAåŒºåŸŸèµ›æ€»ç»“ä¸é¢˜è§£","content":"å·®ä¸å¤šæœ€åä¸€å¹´äº†ï¼Œæ˜å¹´é˜Ÿå‹ä¼°è®¡å°±éƒ½æ¯•ä¸šäº†ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½æ‰¾åˆ°å…¶ä»–äººå§ï¼Œæˆ–è€…soloä¹Ÿè¡Œï¼Ÿæ€»ç»“ä»Šå¹´ç”±äºç–«æƒ…ä¾ç„¶ä¸èƒ½å»æ¸©èçº¿ä¸‹æ¯”èµ›ï¼Œä½†ç›¸æ¯”å»å¹´ä¸‰äººä¸‰æœºä»Šå¤©å˜æˆäº†æ›´åƒçº¿ä¸‹çš„ä¸‰äººä¸€æœºï¼Œä¸è¿‡æ˜¯åœ¨å„è‡ªå­¦æ ¡æ¯”èµ›ï¼Œä½†ä»¤äººä¸èƒ½ç†è§£æ˜¯çš„å±…ç„¶ä¸€ç‚¹ç›‘æ§æªæ–½éƒ½æ²¡æœ‰ï¼Œå…¨å‡­è‡ªå·±è‡ªè§‰å’Œæ•™ç»ƒç›‘ç£ã€‚ã€‚ã€‚ã€‚å¯ä»¥ç†è§£ä¸ºæ‘†çƒ‚å§ğŸ˜‚ã€‚æˆ‘ä»¬é˜Ÿç®—æ˜¯åšåˆ°äº†éµå¾ªè§„åˆ™ï¼Œé™¤äº†å¤šæ¥äº†ä¸€ä¸ªæ˜¾ç¤ºå™¨ç”¨æ¥çœ‹ä»£ç ï¼ˆè‡ªå·±ç”µè„‘æ²¡æ³•è¿æœºæˆ¿çš„æ‰“å°æœºï¼‰ï¼Œä»¥åŠæˆ‘è¿˜æ˜¯ç”¨çš„è‡ªå·±çš„é”®ç›˜ï¼ˆç”¨40%é…åˆ—å¤ªä¹…äº†æ”¹ä¸å›æ¥äº†ï¼‰ã€‚æ’åæœ‰ç‚¹å‡ºä¹æ„æ–™ï¼Œè€ƒè™‘åˆ°é˜Ÿå‹å¿™äºå®ä¹ ä»ä¸è®­ç»ƒã€æˆ‘ä¸Šäº†å¤§ä¸‰ä¹‹åè¯¾ç¨‹éš¾åº¦å¢åŠ ï¼Œåªèƒ½é æ¯å‘¨cfç»´æŒä¸€ç‚¹åšé¢˜é‡ï¼Œè¿™ä¸ªæ’åå·²ç»å¾ˆæ»¡æ„äº†ï¼Œæ¯•ç«Ÿå¦‚æœæŒ‰NACæ™‹çº§è§„åˆ™æŒ‰å­¦æ ¡æ’åæ˜¯ç¬¬6ï¼Œæ ¡æ’åè¦æ˜¯ç¬¬5çš„è¯æ€»æ’åè¦ç¬¬6ï¼Œå®Œå…¨æƒ³peachğŸ˜‚ã€‚æ•´åœºæ¯”èµ›è¿˜æ˜¯æ¯”è¾ƒæµç•…çš„ï¼ŒåŸºæœ¬æ²¡æœ‰å¡å¤ªé•¿æ—¶é—´ï¼ŒAé¢˜ä½œä¸ºæ¯”è¾ƒç®€å•çš„é¢˜å¡äº†æœ‰ç‚¹ä¹…ï¼Œæœ€åè¿˜æ˜¯é çŒœç»“è®ºè¿‡çš„ï¼ŒFè®¡ç®—å‡ ä½•æŸé˜Ÿå‹åˆ°æœ€åä¹Ÿæ²¡æå‡ºæ¥ï¼Œä¸è¿‡æ²¡å ç”¨å¤ªå¤šæ­£å¸¸æ—¶é—´ã€‚æ—¶é—´å†ç¨å¾®å¤šä¸€ç‚¹ä¹Ÿè®¸èƒ½ææIæˆ–è€…Kï¼Œä¸è¿‡åˆ°æœ€åä¹Ÿæ¯”æœ‰ç‚¹ç´¯äº†ï¼Œæ˜¨æ™šä¹Ÿåªç¡äº†5ä¸ªåŠå°æ—¶ã€‚é¢˜ç›®é¢˜ç›®æ•´ä½“éš¾åº¦é€‚ä¸­ï¼Ÿæ¯”å»å¹´éš¾ä¸€ç‚¹ï¼Œï¼ˆè¯»äº†çš„é¢˜ï¼‰ä»¥æ€ç»´é¢˜ä¸ºä¸»ã€‚é™¤äº†Jé¢˜æ‘†çƒ‚å‡ºäº†æœ€å¤§å­çŸ©å½¢åŸé¢˜ï¼Œé¢˜ç›®è´¨é‡è¿˜å¯ä»¥ï¼ŸAä¸€å¼€å§‹waæ˜¯å› ä¸ºå¿˜äº†è€ƒè™‘ç›¸åŠ çš„è½¬ç§»ã€‚è€ƒè™‘åŠ çš„è¯è¦éå†ä¸€éæ•´ä¸ªdpæ•°ç»„ï¼Œæ—¶é—´å¤æ‚åº¦ä¼šå˜æˆï¼Œä½†å…¶å®ä¹Ÿèƒ½è¿‡å› ä¸ºæ—¶é—´ç»™äº†15sã€‚ã€‚ã€‚ï¼ˆæˆ‘tmå†™åšå®¢çš„æ—¶å€™æ‰å‘ç°ï¼‰ã€‚ä½†è²Œä¼¼åªè¦éå†å‰é¢ä¸€äº›æ•°å°±è¡Œäº†ï¼Œå› ä¸ºæ•°å¤§çš„æ—¶å€™ä¹˜è‚¯å®šæ¯”åŠ åˆ’ç®—ã€‚\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> dp(n + 1, 1e9);\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        dp[i] = i;\n\n        for (int j = 1; j <= min(i / 2 + 1, 1000); j++)\n            dp[i] = min(dp[i], dp[j] + dp[i - j]);\n\n        string s = to_string(i);\n        for (int j = 1; j < (int)size(s); j++) {\n            string s1 = s.substr(0, j), s2 = s.substr(j);\n            if (s2[0] == '0') continue;\n            dp[i] = min(dp[i], dp[stoi(s1)] + dp[stoi(s2)]);\n        }\n\n        for (int f = 2; f * f <= i; f++) {\n            if (i % f == 0) { dp[i] = min(dp[i], dp[f] + dp[i / f]); }\n        }\n    }\n    cout << dp[n] << endl;\n}Bèµ›æ—¶æ— è„‘æ•²äº†ä¸ªlcaï¼Œä½†å…¶å®ç¨å¾®å†æƒ³æƒ³å°±æœ‰æ›´ç®€å•çš„åšæ³•ï¼šdfsæ—¶ç»´æŠ¤åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»ä»¥åŠæœ€çŸ­çš„ä¸¤æ¡åˆ°å¶å­çš„è·¯å¾„çš„ä¸¾ä¾‹å³å¯ã€‚#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n);\n    vector<int> a(n);\n    for (auto &x : a)\n        cin >> x;\n    vector<int> indeg(n), sum(n), color(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(v);\n        indeg[v]++;\n    }\n    int c = 0;\n    int ans = 1e9;\n    auto dfs = [&](auto &slf, int u, int s) -> int {\n        sum[u] = s + a[u];\n        color[u] = c;\n        int mn0 = 1e9, mn1 = 1e9;\n        for (auto v : g[u]) {\n            auto res = slf(slf, v, s + a[u]);\n            if (res < mn1) mn1 = res;\n            if (mn1 < mn0) swap(mn0, mn1);\n        }\n        ans = min(ans, mn0 + mn1 + sum[u]);\n        return (mn0 == 1e9 ? 0 : mn0) + a[u];\n    };\n    for (int i = 0; i < n; i++) {\n        if (indeg[i] == 0) {\n            dfs(dfs, i, 0);\n            c++;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (g[i].empty() && g[j].empty()) {\n                if (color[i] != color[j]) {\n                    ans = min(ans, sum[i] + sum[j]);\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}Gç­¾åˆ°é¢˜ï¼Œæšä¸¾æ‰€æœ‰å‰ç¼€ä»¥åŠäº¤æ¢é¡ºåºå³å¯#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string a, b, c;\n    char op, _;\n    cin >> a >> op >> b >> _ >> c;\n    auto check = [&](string a_, string b_, string c_) {\n        __int128 a = stoll(a_), b=stoll(b_), c = stoll(c_);\n        if (op=='+') return a+b==c;\n        else return a*b==c;\n    };\n    for (int i=1; i<(int)size(a); i++) {\n        for (int j=1; j<(int)size(b); j++) {\n            for (int k=1; k<(int)size(c); k++) {\n                string a1=a.substr(0, i), a2=a.substr(0+i);\n                string b1=b.substr(0, j), b2=b.substr(0+j);\n                string c1=c.substr(0, k), c2=c.substr(0+k);\n                vector<string> s = {a1, b1, c1};\n                sort(begin(s), end(s));\n                do {\n                    if (check(s[0]+a2, s[1]+b2, s[2]+c2)) {\n                        cout << s[0]+a2 << ' ' << op << ' ' <<  s[1]+b2 << \" = \" << s[2]+c2;\n                        exit(0);\n                    }\n                } while (next_permutation(begin(s), end(s)));\n            }\n        }\n    }\n}Jç»å…¸æœ€å¤§å­çŸ©é˜µï¼Œå•è°ƒæ ˆææå³å¯ã€‚å…¶å®æˆ‘èµ›æ—¶å·²ç»åŸºæœ¬å¿˜äº†æ€ä¹ˆåšäº†ï¼Œåªè®°å¾—æ˜¯æ˜¯å•è°ƒæ ˆï¼Œæƒ³äº†åŠå¤©æ‰æƒ³å‡ºæ¥æ­£è§£ï¼Œè¿™ä¸‹åº”è¯¥ä»¥åå¿˜ä¸äº†äº†233#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; //}}}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    stack<pair<int, int>> stk;\n    ll ans = 0;\n    int s = 1e9, e = 0;\n\n    auto update = [&](ll cur, int curs, int cure) {\n        if (cur > ans || (cur == ans && curs < s)) {\n            ans = cur;\n            s = curs;\n            e = cure;\n        }\n    };\n    for (int i = 0; i < n; i++) {\n        int prev = i;\n        while (!stk.empty() && stk.top().first >= a[i]) {\n            prev = stk.top().second;\n            ll cur = ll(i - prev) * stk.top().first;\n            update(cur, prev, i - 1);\n            stk.pop();\n        }\n        ll cur = ll(i - prev + 1) * a[i];\n        update(cur, prev, i);\n        stk.push({a[i], prev});\n    }\n    while (!stk.empty()) {\n        auto [x, i] = stk.top();\n        stk.pop();\n        ll cur = ll(n - i) * x;\n        update(cur, i, n - 1);\n    }\n    cout << s + 1 << ' ' << e + 1 << ' ' << ans << endl;\n}Læšä¸¾å››ä¸ªè§’ç„¶åæ’åºåˆ†å±‚æä¸€æï¼Œé˜Ÿå‹å†™çš„import collections\nimport itertools\nimport sys\nints = lambda: list(map(int, sys.stdin.readline().split()))\ngrid = []\ngy, gx = ints()\nfor y in range(gy):\n  grid.append(ints())\nstatues = []\nfor row in grid:\n  for cell in row:\n    if ~cell:\n      statues.append(cell)\nstatues.sort()\n\ndef levels(grid):\n  ret1 = collections.defaultdict(set)\n  ret2 = collections.defaultdict(set)\n  for y in range(gy):\n    for x in range(gx):\n      cell = grid[y][x]\n      if ~cell:\n        ret1[y+x].add(cell)\n        ret2[y-x].add(cell)\n  return ret1, ret2\n\nret1, ret2 = levels(grid)\n\nkeys1 = sorted(ret1.keys())\nkeys2 = sorted(ret2.keys())\n\nimport math\nmoved = math.inf\n\nfor keys, ret in (keys1, ret1), (reversed(keys1), ret1), (keys2, ret2), (reversed(keys2), ret2):\n  this = len(statues)\n  it = iter(statues)\n  for key in keys:\n    st = set()\n    for _ in range(len(ret[key])):\n      st.add(next(it))\n    this -= len(st & ret[key])\n  moved = min(moved, this)\n\nprint(moved)Mæœ€çŸ­è·¯è€ƒè™‘ç”¨bfsï¼ŒæŠŠæ‰€æœ‰å­—ç¬¦ä¸²æ”¾å…¥ä¸€ä¸ªtrieå°±å¯ä»¥å¾ˆå®¹æ˜“çŸ¥é“å“ªäº›æ–¹å‘å¯ä»¥èµ°äº†ï¼Œæ‰€ä»¥çŠ¶æ€å°±æ˜¯[x][y][trieä¸­çš„èŠ‚ç‚¹çš„ä½ç½®][ä¸Šä¸€æ­¥çš„æ–¹å‘]ã€‚é™¤äº†çŠ¶æ€å¤æ‚ç‚¹å…¶ä»–å°±æ˜¯æ­£å¸¸bfsçš„å¥—è·¯ï¼Œæ³¨æ„å¦‚æœå½“å‰åœ¨å•è¯ç»“å°¾çš„ä½ç½®ï¼Œä¸‹ä¸€æ­¥å³å¯ä»¥å›åˆ°trieçš„æ ¹ï¼Œåˆå¯ä»¥ç»§ç»­é¡ºç€trieèµ°ã€‚#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Trie {\n    struct node {\n        map<char, int> ch;\n        bool term;\n    };\n    vector<node> t;\n    Trie() { new_node(); }\n    int new_node() {\n        t.emplace_back();\n        return t.size() - 1;\n    }\n    void insert(const string &s) {\n        int p = 0;\n        for (auto ch : s) {\n            if (!t[p].ch.count(ch)) { t[p].ch[ch] = new_node(); }\n            p = t[p].ch[ch];\n        }\n        t[p].term = true;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector s(n, vector<char>(m));\n    for (auto &v : s)\n        for (auto &c : v)\n            cin >> c;\n    Trie tr;\n    for (int i = 0; i < k; i++) {\n        string ss;\n        cin >> ss;\n        tr.insert(ss);\n    }\n    vector dis(n, vector(m, vector(size(tr.t), vector(3, -1))));\n    queue<array<int, 4>> q;\n    for (int i = 0; i < m; i++) {\n        if (tr.t[0].ch.count(s[0][i])) {\n            int st = tr.t[0].ch[s[0][i]];\n            dis[0][i][st][0] = 1;\n            q.push({0, i, st, 0});\n        }\n    }\n\n    const vector<pair<int, int>> dir{{1, 0}, {0, -1}, {0, 1}};\n    while (!q.empty()) {\n        auto [x, y, st, prev] = q.front();\n        int olddis = dis[x][y][st][prev];\n        q.pop();\n        for (int ii = 0; ii < (int)size(dir); ii++) {\n            auto [dx, dy] = dir[ii];\n            if ((prev == 1 && dy == 1) || (prev == 2 && dy == -1))\n                continue;\n            unsigned nx = x + dx, ny = y + dy;\n            if (nx < n && ny < m) {\n                auto go = [&](int st) {\n                    if (tr.t[st].ch.count(s[nx][ny])) {\n                        int nst = tr.t[st].ch[s[nx][ny]];\n                        if (dis[nx][ny][nst][ii] == -1) {\n                            dis[nx][ny][nst][ii] = olddis + 1;\n                            q.push({(int)nx, (int)ny, nst, ii});\n                        }\n                    }\n                };\n                go(st);\n                if (tr.t[st].term) {\n                    st = 0;\n                    go(st);\n                }\n            }\n        }\n    }\n    int ans = 1e9;\n    for (int i = 0; i < m; i++) {\n        for (int d = 0; d < 3; d++) {\n            for (int st = 0; st < (int)size(tr.t); st++) {\n                if (tr.t[st].term && dis[n - 1][i][st][d] != -1) {\n                    ans = min(ans, dis[n - 1][i][st][d]);\n                }\n            }\n        }\n    }\n    if (ans == 1e9) {\n        cout << \"impossible\\n\";\n    } else\n        cout << ans << endl;\n}"},{"id":"2x2-ortega","title":"äºŒé˜¶é­”æ–¹é¢å…ˆæ³•","content":"PBL0 Bar:R2 B2 R2R2' F2 R21 Bar:FU:R' F R' F2 R U' RR U' L U2' R' U L'BU: R' U R' F2 R F' RLU: L2 U R2 U' R2 U R2 U' R2RU: R2 U' L2 U L2 U' L2 U L2FD: R F' L U2 L' F R'BD: R U' R' U' R' F2 U' R U RLD: R2 U R2 U' R2 U R2 U' R2RD: L2 U' L2 U L2 U' L2 U L22Bar:B: R2 U' R2 U2' F2 U' R2F: R2 U' B2 U2' R2' U' R2L: F2 U' R2 U2' B2 U' R2R: F2 U' F2 U2' R2 U' R2Y:U: R U' R' U' F2 U' R U R' U F2D:R U' R' U' F2 U' R U R' U R2 B2F U2' R2 F R F' R U2 R' U R F'J:UL: R' F R F' R U2 R' U R U2 R'UR: R2 F2 R U R' F2 R F' RUB: R' F R' F2 R U' R' F2 R2UF: R' U R' F2 R F' R' F2 R2DB: x R U' R U2 R' F R U2 R2DL: R2 U' R' U L' U2 R U' R' U2 (å…ˆåšauf)DF: R U' R' U' F R2 U' R' U R' F' RDR: R' F R U' R U R2 F' U R U R'"},{"id":"3*3pb9.8","title":"9.80æ— è·³3é˜¶pbå¤ç›˜","content":"æ‰“ä¹±B U2 R2 U2 L2 B' D2 R2 U2 R2 F2 R B' U R F U2 L2 R' B2è§£æ³•ï¼šU' R2' F' //cross\ny U' R' U R//first pair\nU' L' U L U2 R U' R'//second pair\nU2 L' U' L2 U L'//third pair\ny' U R U2 R' U2 R U' R'//fourth pair\nU r U R' U R U2 r'//OLL\nU' R' U' F' R U R' U' R' F R2 U' R' U' R U R' U R//PLL"},{"id":"ABC159E","title":"AtCoder Beginner Contest 159E - Dividing Chocolate é¢˜è§£","content":"çœ‹äº†ä¸€ä¸Šåˆæ‰çœ‹æ˜ç™½å¤§ä½¬çš„ä»£ç é¢˜è§£è¡¨ç¤ºå‰iä¸ªæ•°é‡Œé¢åºåˆ—å’Œæ˜¯jçš„ç­”æ¡ˆï¼Œä¹Ÿå°±æ˜¯è¯´æŠŠé¢˜ç›®è¦æ±‚æ”¹æˆå‰iä¸ªæ•°ï¼Œå’Œæ˜¯jæ—¶çš„ç­”æ¡ˆã€‚å½“æˆ‘ä»¬å¤„ç†æ–°çš„æ•°çš„æ—¶å€™ï¼Œå‡è®¾è¿™ä¸ªæ•°æ˜¯xï¼Œå½“å‰åœ¨ç¬¬iä½ã€‚å¾ˆæ˜æ˜¾å‰é¢çš„åºåˆ—å¯ä»¥é‡å¤ä½¿ç”¨ã€‚ç°åœ¨æˆ‘ä»¬å†è€ƒè™‘æ–°çš„æ•°å¯¹ç­”æ¡ˆçš„è´¡çŒ®ï¼šé¦–å…ˆï¼Œæ–°æ•°è‡ªå·±å°±å¯ä»¥ä½œä¸ºä¸€ä¸ªåºåˆ—ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰ã€‚å…¶æ¬¡ï¼Œæ–°çš„æ•°è¿˜å¯ä»¥å’Œå‰é¢çš„åºåˆ—å½¢æˆæ–°çš„åºåˆ—ï¼Œæ‰€ä»¥å¯¹äºæ‰€æœ‰ï¼Œæˆ‘ä»¬æœ‰ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n#define de(x) cout<<#x<<\" = \"<<(x)<<endl\n#define de2(x,y) cout<<#x<<\" = \"<<(x) <<' '<< #y<<\" = \"<<y<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\nll nxt(){ll x;cin>>x;return x;}\n\nconst int N=3e3+5;\nint dp[N][N];\nconst int mod=998244353;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,s;\n    cin>>n>>s;\n    ll ans=0;\n    for1(i,n){\n        int x;\n        cin>>x;\n        dp[i][x]=i;//self sequence\n        for(int j=0;j<=s;j++){\n            (dp[i][j]+=dp[i-1][j])%=mod;//reuse the previous answer\n            if(j-x>=0) (dp[i][j]+=dp[i-1][j-x])%=mod;//with previous sequences\n        }\n        ans=(ans+dp[i][s])%mod;\n    }\n    cout<<ans;\n    return 0;\n}"},{"id":"ABC161E","title":"AtCoder Beginner Contest 161E - Yutori é¢˜è§£","content":"å¦™å•Šï¼é¢˜è§£æˆ‘ä»¬å¯ä»¥æ„é€ ä¸€ä¸ªæ•°ç»„ä½¿å¾—ç¬¬ä¸ªå·¥ä½œæ—¥ä¸æ—©äºç¬¬å¤©ï¼Œé€šè¿‡ä»å‰å¾€åå°½å¯èƒ½æ—©çš„é€‰æ‹©å·¥ä½œæ—¥ã€‚åŒæ ·åœ°ï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ æ•°ç»„ä½¿å¾—ç¬¬ä¸ªå·¥ä½œæ—¥ä¸æ™šäºå¤©ï¼Œé€šè¿‡ä»åå¾€å‰é€‰æ‹©ã€‚ä»–å¿…é¡»åœ¨ç¬¬å¤©å·¥ä½œå½“ä¸”ä»…å½“å­˜åœ¨ä½¿å¾—ã€‚å¯ä»¥åœ¨çš„æ—¶é—´å†…è§£å†³ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n,k,c;\n    cin>>n>>k>>c;\n    string s;\n    cin>>s;\n    vector<int> a,b;\n    forn(i,n){\n        if(s[i]=='o'){\n            a.pb(i);\n            i+=c;\n        }\n    }\n    ford(i,n){\n        if(s[i]=='o'){\n            b.pb(i);\n            i-=c;\n        }\n    }\n    forn(i,k){\n        if(a[i]==b[k-i-1]) cout<<a[i]+1<<endl;\n    }\n\n    return 0;\n}"},{"id":"ABC162F","title":"Atcoder beginner contest 162F -  Select Half Select Half é¢˜è§£","content":"yysyè¿™ç§é¢˜æƒ³å‡ºæ¥çœŸçš„çˆ½ã€‚é¢˜è§£è¿™é“é¢˜æœ‰å¾ˆå¤šä¸åŒçš„dpæ–¹æ³•ã€‚è¿™é‡Œæˆ‘å°†æè¿°ä¸€ä¸‹æˆ‘è®¤ä¸ºæ¯”è¾ƒæ ‡å‡†çš„æ–¹æ³•ã€‚å½“ç„¶æœ‰æ›´çŸ­çš„åšæ³•ä½†æ˜¯ä¹Ÿçœ‹ä¸æ‡‚å•ŠQAQã€‚é¦–å…ˆå®šä¹‰ä¸€ä¸‹dpçŠ¶æ€ï¼Œè®¾ä¸ºå‰iä¸ªæ•°çš„ç­”æ¡ˆå¹¶ä¸”æœ€åä¸€ä¸ªé€‰çš„æ•°çš„ä¸‹æ ‡æ˜¯ã€‚é€šè¿‡è§‚å¯Ÿä¸éš¾å‘ç°å¦‚æœæ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆjæœ€å¤§æ˜¯2ï¼Œå¦åˆ™jæœ€å¤§æ˜¯1ã€‚è¿™ç‚¹å¯ä»¥é€šè¿‡å–çš„æ•°æ¥éªŒè¯ã€‚ç°åœ¨æˆ‘ä»¬å¯ä»¥è€ƒè™‘çŠ¶æ€è½¬ç§»äº†ã€‚å¦‚æœæ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆé€‰çš„æ•°çš„ä¸ªæ•°å’Œæ˜¯ä¸€æ ·çš„ã€‚æ‰€ä»¥åº”è¯¥ç­‰äºé™¤äº†ï¼Œå› ä¸ºåœ¨è®¡ç®—çš„æ—¶å€™å¹¶æ²¡æœ‰è¢«è€ƒè™‘åˆ°ï¼Œæ‰€ä»¥åº”è¯¥ä»è½¬ç§»è¿‡æ¥ã€‚ä»¥ä¸‹æ˜¯çŠ¶æ€è½¬ç§»æ–¹ç¨‹:å½“ä¸ºå¶æ•°ï¼Œè¦æ¯”å¤šé€‰ä¸€ä¸ªæ•°ï¼Œæƒ³æ³•åŸºæœ¬ç±»ä¼¼ã€‚çŠ¶æ€è½¬ç§»å¦‚ä¸‹ï¼šCode#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(random_device{}());\ntemplate<typename... Args> void write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> a(n+1);\n    for(int i=1;i<=n;++i) cin>>a[i];\n    vector<vector<ll>> dp(n+1,vector<ll>(3,-1e18));\n    dp[1]={0,0,0};\n    for(int i=2;i<=n;++i){\n        if(i&1){\n            dp[i][0]=max({dp[i-2][0],dp[i-2][1],dp[i-2][2]})+a[i];\n            dp[i][1]=dp[i-1][0];\n            dp[i][2]=dp[i-1][1];\n        }else{\n            dp[i][0]=max({dp[i-1][1]+a[i],dp[i-1][2]+a[i]});\n            dp[i][1]=dp[i-1][2]+a[i-1];\n        }\n    }\n    cout<<*max_element(all(dp[n]));\n    return 0;\n}"},{"id":"ABC171F","title":"é¢˜è§£ Atcoder Beginner Contest 171F - Strivore","content":"æ€è€ƒçš„è§’åº¦å¾ˆå¦™é¢˜è§£ç­”æ¡ˆçš„ä¸ªæ•°ç­‰äºæœ‰å¤šå°‘ä¸ªé•¿åº¦ä¸ºçš„å­—ç¬¦ä¸²ä½¿å¾—æ˜¯ä»–çš„ä¸€ä¸ªå­åºåˆ—ã€‚è®¾åœ¨ä¸­çš„ä¸‹æ ‡ä¸ºã€‚ ä¸ºäº†é¿å…é‡å¤ï¼Œæˆ‘ä»¬åœ¨æ‰€æœ‰å¯èƒ½çš„ä¸­å–æœ€å°çš„ã€‚ä¸éš¾çœ‹å‡ºï¼Œå’Œä¹‹é—´çš„å­—ç¬¦æœ‰25ç§é€‰æ‹©ï¼Œä¹‹åçš„æœ‰26ç§å¯èƒ½ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æšä¸¾ä¹‹åçš„å­—ç¬¦çš„ä¸ªæ•°ï¼Œè¿™æ ·åœ¨å­—ç¬¦é€‰æ‹©æ–¹é¢æˆ‘ä»¬æœ‰ç§å¯èƒ½ã€‚ç„¶åå†è€ƒè™‘å¦‚ä½•åˆ†é…ä¸ªå­—ç¬¦ï¼Œæ ¹æ®æ’æ¿æ¨¡å‹ï¼Œæˆ‘ä»¬æœ‰ç§æ–¹å¼ï¼Œæ‰€ä»¥å¯¹äºæ¯ä¸ªxï¼Œç­”æ¡ˆå¢åŠ ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n#define pb push_back\n\nusing namespace std;\nusing ll=long long;\nusing pii= pair<int, int>;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    // constructor\n    ModInt(ll v = 0) : val(int(v % MOD)) {\n        if (val < 0) val += MOD;\n    };\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = int(ll(val) * x.val % MOD);\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint=ModInt<int(1e9+7)>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int k;\n    string s;\n    cin>>k>>s;\n    int n=sz(s);\n    vector<mint> fac(2e6+5);\n    fac[0]=1;\n    for(int i=1;i<=2e6;i++) fac[i]=fac[i-1]*i;\n    mint ans=0;\n    auto C=[&](int n,int r)->mint{\n        if(r>n) return 0;\n        return fac[n]/fac[r]/fac[n-r];\n    };\n    for(int i=0;i<=k;i++){\n        ans+=mint(25).pow(k-i)*mint(26).pow(i)*C(n-1+k-i,n-1);\n    }\n    cout<<ans;\n    return 0;\n}"},{"id":"ABC203E","title":"AtCoder Beginner Contest (ABC) 203E é¢˜è§£","content":"æœ‰ç‚¹ä¸çŸ¥å¦‚ä½•ä¸‹æ‰‹çš„é¢˜æœ¬æ–‡åŸºæœ¬æ˜¯ç…§ç€è¿™ä¸ªç¿»è¯‘çš„ã€‚Pawnæ˜¯å›½é™…è±¡æ£‹é‡Œçš„å…µã€‚ç”±äºåªèƒ½å¾€ä¸‹èµ°ï¼Œæˆ‘ä»¬ä»ä¸Šåˆ°ä¸‹ä¸€è¡Œä¸€è¡Œçš„å¤„ç†ï¼Œç»´æŠ¤æœ¬å±‚èƒ½å¤Ÿåˆ°è¾¾ çš„ä½ç½®ã€‚æ ¹æ®è§„åˆ™ï¼Œæœ‰ä¸¤ç§æƒ…å†µä¼šä½¿åˆ°è¾¾æ€§å‘ç”Ÿæ”¹å˜ï¼šå¦‚æœèƒ½åˆ°è¾¾ä¸Šä¸€è¡Œçš„iä½ç½®è€Œæœ¬è¡Œçš„iä½ç½®æœ‰ä¸€ä¸ªå…µï¼Œé‚£ä¹ˆæœ¬è¡Œçš„iä½ç½®å°±æ˜¯ä¸å¯è¾¾çš„ã€‚å¦‚æœä¸Šä¸€è¡Œçš„i-1æˆ–i+1èƒ½åˆ°è¾¾çš„è¯è€Œæœ¬è¡Œçš„iä½ç½®æœ‰ä¸€ä¸ªå…µï¼Œæœ¬è¡Œçš„iä½ç½®å°±æ˜¯å¯è¾¾çš„ã€‚ç”±äºç¬¬äºŒç§æƒ…å†µå¯ä»¥è¦†ç›–æ‰ç¬¬ä¸€ç§æƒ…å†µï¼ˆå³å¦‚æœiåŒæ—¶ç¬¦åˆä¸¤ç§æƒ…å†µé‚£ä»–ä¹Ÿæ˜¯å¯è¾¾çš„ï¼‰ï¼Œæ‰€ä»¥åœ¨æˆ‘ä»¬è®°å½•ä¸å¯è¾¾å’Œå¯è¾¾çš„å˜åŒ–ä¹‹åï¼Œå…ˆå¤„ç†ä¸å¯è¾¾çš„å˜åŒ–ï¼Œå†å¤„ç†å¯è¾¾çš„å˜åŒ–ã€‚ä»£ç ï¼š#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, int>> p(m);\n    for (auto &[x, y] : p) {\n        cin >> x >> y;\n    }\n    sort(p.begin(), p.end());\n    set<int> s{n};\n    for (int l = 0, r = 0; l < m; l = r) {\n        while (r < m && p[l].first == p[r].first) r++;\n        vector<int> rem, ins;\n        for (int i = l; i < r; i++) {\n            int y = p[i].second;\n            rem.push_back(y);\n            if (s.count(y - 1) || s.count(y + 1)) ins.push_back(y);\n        }\n        for (auto x : rem) s.erase(x);\n        for (auto x : ins) s.insert(x);\n    }\n    cout << s.size();\n    return 0;\n}"},{"id":"ABC266G","title":"AtCoder Beginner Contest 266 G é¢˜è§£","content":"ç›´æ¥åˆ©ç”¨ç»„åˆæ•°æ±‚è§£çš„åšæ³•æ¯”è¾ƒç®€å•ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ï¼Œç€é‡è®²åˆ©ç”¨äºŒé¡¹å¼åæ¼”çš„åšæ³•ã€‚é¦–å…ˆä¸éš¾æƒ³åˆ°ç”¨  ä¸ª RGï¼Œä¸ªRï¼Œä¸ªGï¼Œä¸ªBæ’ï¼Œå¾—åˆ°çœ‹ä¼¼æ˜¯â€œè‡³å°‘æœ‰çš„RGâ€çš„å­—ç¬¦ä¸²æ•°é‡ã€‚ä½†æ˜¯è¿™æ ·è®¡æ•°ä¼šæœ‰é‡å¤ï¼Œæ¯”å¦‚å’Œå…¶å®æ˜¯ä¸€æ ·çš„ä¸²ä½†è®¡æ•°çš„æ—¶å€™ç®—äº†ä¸¤æ¬¡ï¼Œå‡†ç¡®åœ°è¯´ï¼Œå«ä¸ªRGçš„ä¸²è¢«é‡å¤è®°äº†æ¬¡ï¼Œç”¨æ•°å­¦è¯­è¨€è¡¨ç¤ºå°±æ˜¯ï¼šè®¾ä¸ºæ°å¥½å«ä¸ªRGçš„å­—ç¬¦ä¸²çš„æ•°é‡ï¼Œæœ‰\nè¿™æ°å¥½æ˜¯äºŒé¡¹å¼åæ¼”çš„å½¢å¼äºŒï¼Œé‚£ä¹ˆç­”æ¡ˆä¸º\n#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) begin(x),end(x) //{{{\n#ifndef LOCAL // https://github.com/p-ranav/pprint\n#define de(...)\n#define de2(...)\n#endif\nusing ll = long long; //}}}\n\ntemplate <typename mint> struct Factorial {\n    std::vector<mint> fac, invfac;\n    Factorial(int n) : fac(n + 1), invfac(n + 1) {\n        fac[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fac[i] = fac[i - 1] * i;\n        }\n        invfac[n] = fac[n].inv();\n        for (int i = n - 1; i >= 0; i--) {\n            invfac[i] = invfac[i + 1] * (i + 1);\n        }\n    }\n    mint C(int n, int k) { // n choose m\n        if (k < 0 || k > n) return 0;\n        assert((int)size(fac) > n);\n        return fac[n] * invfac[n - k] * invfac[k];\n    }\n    mint P(int n, int m) { // n choose m with permutation\n        assert(!fac.empty());\n        return fac[n] * invfac[n - m];\n    }\n\n    // evaluate expressions consists of multiplication and division\n    // if the number is multiplied, pass the number as argument\n    // if divided, pass its negation\n    // Example: a! * b! / c! => eval(a, b, -c);\n    template<typename... Args>\n    constexpr mint eval(Args... args) {\n        return ((args > 0 ? fac[args] : invfac[-args]) * ...);\n    }\n};\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    ModInt(ll v = 0) : val(v % MOD) { if (val < 0) val += MOD; };\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const {\n        auto a = val, m = MOD, u = 0, v = 1;\n        while (a != 0) { auto t = m / a; m -= t * a; swap(a, m); u -= t * v; swap(u, v); }\n        assert(m == 1);\n        return u;\n    }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    friend ModInt operator+ (ModInt lhs, const ModInt& rhs) { return lhs += rhs; }\n    friend ModInt operator- (ModInt lhs, const ModInt& rhs) { return lhs -= rhs; }\n    friend ModInt operator* (ModInt lhs, const ModInt& rhs) { return lhs *= rhs; }\n    friend ModInt operator/ (ModInt lhs, const ModInt& rhs) { return lhs /= rhs; }\n    ModInt& operator+=(const ModInt& x) { if ((val += x.val) >= MOD) val -= MOD; return *this; }\n    ModInt& operator-=(const ModInt& x) { if ((val -= x.val) < 0) val += MOD; return *this; }\n    ModInt& operator*=(const ModInt& x) { val = int64_t(val) * x.val % MOD; return *this; }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<998244353>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int r, g, b, k;\n    cin >> r >> g >> b >> k;\n    int n = r + g + b;\n    Factorial<mint> fac(n);\n    mint ans = 0;\n    for (int i = k; i <= min(r, g); i++) {\n        ans += ((i - k) % 2 ? -1 : 1) * fac.C(i, k) * fac.eval(i + r - i + g - i + b, -i, -(r - i), -(g - i), -b);\n    }\n    cout << ans << endl;\n}"},{"id":"ABC_DP","title":"éƒ¨åˆ†é¢˜è§£ Atcoder Educational DP Contest","content":"éå¸¸å¥½çš„å­¦ä¹ dpçš„æ¯”èµ›ã€‚M - CandiesSolutionLet  be the number of ways to distribute  candies to the first  kids. If we give  candies to the -th kid, we should add  to . Since  takes all the values from  to , so . Note that we take a segment of , so we can use prefix sum.There's one optimization: the first dimension of  is useless, we only need to store the latest  array.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n#define pb push_back\n\nusing namespace std;\nusing ll=long long;\nusing pii= pair<int, int>;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\n\nconst int mod=1e9+7;\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    // constructor\n    ModInt(ll v = 0) : val(int(v % MOD)) {\n        if (val < 0) val += MOD;\n    };\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = int(ll(val) * x.val % MOD);\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint=ModInt<mod>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,k;\n    cin>>n>>k;\n    vector<int> a(n);\n    for(auto& it:a) cin>>it;\n    vector<mint> dp(k+1);\n    dp[0]=1;\n    for(int i=0;i<n;i++){\n        vector<mint> sum(k+2),ndp(k+1);\n        partial_sum(all(dp),sum.begin()+1);\n        for(int j=0;j<=k;j++){\n            ndp[j]+=sum[j+1];\n            if(j>=a[i]) ndp[j]-=sum[j-a[i]];\n        }\n        dp=ndp;\n    }\n    cout<<dp[k];\n    return 0;\n}O - MatchingSolution means the number of way to pair all the girls with 1-bit in the mask with the first  boys.Code#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    const int mod=1e9+7;\n    int n;\n    cin>>n;\n    vector a(n,vector(n,0));\n    for(auto& v:a) for(auto& it:v) cin>>it;\n    vector<int> dp(1<<n);\n    dp[0]=1;\n    for(int mask=1;mask<(1<<n);mask++){\n        int ones=__builtin_popcount(mask);\n        for(int bit=0;bit<n;bit++){\n            if(mask>>bit&1 && a[ones-1][bit]){\n                (dp[mask]+=dp[mask^(1<<bit)])%=mod;\n            }\n        }\n    }\n    cout<<dp[(1<<n)-1];\n    return 0;\n}S - Digit SumSolutionVery basic digit dp problem, we will write it in a recursive way with memoization.  means how many ways we can choose a number for the first  digits, with  and the -th digit can take value from 0-9 if  and  if .Code#include <bits/stdc++.h>\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll=long long;\n\nstring s;\nint D;\nconst int N=1e5+5,mod=1e9+7;\nll dp[N][105][2];\n\nll dfs(int i,int sum,bool strict){\n    if(i==sz(s)) return sum==0;\n    if(dp[i][sum][strict]!=-1) return dp[i][sum][strict];\n    ll ret=0;\n    int mx=9;\n    if(strict) mx=s[i]-'0';\n    for(int j=0;j<=mx;j++){\n        (ret+=dfs(i+1,(sum+j)%D,j==mx&&strict))%=mod;\n    }\n    return dp[i][sum][strict]=ret;\n}\n    \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>s>>D;\n    memset(dp,-1,sizeof(dp));\n    cout<<(dfs(0,0,1)-1+mod)%mod;\n    return 0;\n}T - PermutationSolutionLet  denotes the number of permutations of  such that the last element is j and all the first i - 1 inequalities are fulfilled.Transition is:  This can be calculated in  using prefix sum.One way to interpret the transition is that we add  to the end of the previous permutation and increase all the values greater or equal than  by 1. What a trick!Code#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    const int mod=1e9+7;\n    int n;\n    string s;\n    cin>>n>>s;\n    vector dp(n,vector(n,0));\n    dp[0][0]=1;\n    for(int i=1;i<n;i++){\n        vector<int> sum(n+1);\n        for(int j=1;j<=n;j++) sum[j]=(sum[j-1]+dp[i-1][j-1])%mod;\n        for(int j=0;j<=i;j++){\n            if(s[i-1]=='<') dp[i][j]=(sum.back()-sum[j]+mod)%mod;\n            else dp[i][j]=sum[j];\n        }\n    }\n    int ans=0;\n    for(auto it:dp[n-1]) (ans+=it)%=mod;\n    cout<<ans;\n    return 0;\n}U - Groupingé¢˜è§£è¡¨ç¤ºåªè€ƒè™‘çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æ˜¯1çš„ä½ç½®çš„å…”å­çš„ç­”æ¡ˆã€‚ä¸€å¼€å§‹å‡è®¾æ‰€æœ‰å…”å­éƒ½åœ¨åŒä¸€ä¸ªç»„é‡Œã€‚ç„¶åç”¨éå†çš„æ‰€æœ‰å­é›†ç„¶åæ›´æ–°ç­”æ¡ˆã€‚Code#include <bits/stdc++.h>\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nusing namespace std;\nusing ll=long long;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    int a[n][n];\n    forn(i,n) forn(j,n) cin>>a[i][j];\n    vector<ll> dp(1<<n);\n    forn(i,1<<n) forn(j,n) if(i>>j&1) forn(k,j) if(i>>k&1)\n        dp[i]+=a[j][k];\n    forn(i,1<<n){\n        for(int j=i;j;j=(j-1)&i){\n            dp[i]=max(dp[i],dp[j]+dp[j^i]);\n        }\n    }\n    cout<<dp[(1<<n)-1];\n    return 0;\n}"},{"id":"CF1027D","title":"CodeForces 1027D - Mouse Hunt","content":"æˆ‘æ€ä¹ˆè¿æ‰¾ç¯éƒ½ä¸ä¼šé¢˜è§£ä¸è®ºä»å“ªå¼€å§‹ï¼Œæœ€ç»ˆéƒ½ä¼šé™·å…¥å¾ªç¯ï¼ˆåŒ…æ‹¬è‡ªç¯ï¼‰ï¼Œæ‰€ä»¥æŠŠé™·é˜±æ”¾åœ¨ç¯ä¸Šæ°¸è¿œæ˜¯æœ€ä¼˜çš„ã€‚æ‰€ä»¥è¿™ä¸ªé¢˜å°±æ˜¯è¦æ‰¾åˆ°æ‰€æœ‰ç¯ç„¶åæ‰¾å‡ºæ¯ä¸ªç¯ä¸Šçš„æœ€å°èŠ±è´¹ã€‚æ‰¾ç¯åº”è¯¥ç®—æ˜¯æ¯”åŸºç¡€çš„æŠ€å·§äº†ï¼Œä½†æˆ‘æ˜¯ç¬¬ä¸€æ¬¡é‡åˆ°è¿™ç§é¢˜ï¼ˆå¤ªèœäº†ï¼‰ã€‚å¯ä»¥åœ¨è¿™å­¦å¦‚ä½•æ‰¾ç¯ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n#define de(x) cout<<#x<<\" = \"<<(x)<<endl\n#define de2(x,y) cout<<#x<<\" = \"<<(x) <<' '<< #y<<\" = \"<<y<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconstexpr int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nvector<int> a;\nvector<int> vis;\nvector<vector<int>> cycles;\nvector<int> fa;\nvoid dfs(int u){\n\tvis[u]=1;\n\tint to=a[u];\n\tif(vis[to]==1){\n\t\tcycles.pb({to});\n\t\tfor(int id=u;id!=to;id=fa[id]) cycles.back().pb(id);\n\t}else if(vis[to]==0){\n\t\tfa[to]=u;\n\t\tdfs(to);\n\t}\n\tvis[u]=2;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tcin>>n;\n\tvector<int> cost(n);\n\ta=vis=fa=vector<int>(n);\n\tfor(auto& it:cost ) cin>>it;\n\tfor(auto& it:a) cin>>it,it--;\n\tforn(i,n){\n\t\tif(vis[i]==0) dfs(i);\n\t}\n\tll ans=0;\n\tfor(auto& cycle:cycles){\n\t\tint mn=INF;\n\t\tfor(auto it:cycle) mn=min(mn,cost[it]);\n\t\tans+=mn;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"},{"id":"CF1037D","title":"CodeForces 1037D - Valid BFS? é¢˜è§£","content":"é¢˜è§£æˆ‘ä»¬å¯ä»¥å…ˆå¯¹é‚»æ¥è¡¨çš„èŠ‚ç‚¹ï¼Œæ ¹æ®èŠ‚ç‚¹åœ¨è¾“å…¥åºåˆ—çš„å‡ºç°é¡ºåºæ’åºã€‚ç„¶åå°±å¯ä»¥æ­£å¸¸è·‘ä¸€éBFSç„¶åæ£€æŸ¥å¾—åˆ°çš„åºåˆ—å’Œè¾“å…¥æ˜¯å¦ä¸€æ ·ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n#define de(x) cout<<#x<<\" = \"<<(x)<<endl\n#define de2(x,y) cout<<#x<<\" = \"<<(x) <<' '<< #y<<\" = \"<<y<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconstexpr int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst int N=2e5+5;\nvector<int> G[N];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        G[x].pb(y);\n        G[y].pb(x);\n    }\n    vector<int> input(n), a(n+1);\n    forn(i,n){\n        cin>>input[i];\n        a[input[i]]=i;\n    }\n    for1(i,n){\n        sort(all(G[i]),[&](int x,int y){return a[x]<a[y];});\n    }\n    queue<int> q;\n    q.push(1);\n    vector<bool> vis(n+1);\n    vector<int> ans;\n    while(!q.empty()){\n        int now=q.front();\n        q.pop();\n        ans.pb(now);\n        vis[now]=1;\n        for(auto it:G[now]) if(!vis[it]) q.push(it);\n    }\n    forn(i,n) if(ans[i]!=input[i]) return cout<<\"no\",0;\n    cout<<\"yes\";\n    return 0;\n}"},{"id":"CF1059C","title":"Codeforces 1059C - Sequence Transformation é¢˜è§£","content":"é¢˜æ„ï¼šå®šä¹‰å¦‚ä¸‹åºåˆ—çš„å˜æ¢ï¼ˆç”±ä¸€ä¸ªå·²çŸ¥åºåˆ—ç”Ÿæˆå¦ä¸€ä¸ªåºåˆ—ï¼‰ï¼šå¦‚æœåºåˆ—æ˜¯ç©ºçš„åˆ™åœæ­¢ï¼Œå¦åˆ™åœ¨æ–°åºåˆ—çš„æœ€ååŠ ä¸Šå½“å‰åºåˆ—æ‰€æœ‰å…ƒç´ çš„gcdï¼Œç„¶åä»åŸåºåˆ—ä¸­ç§»é™¤ä¸€ä¸ªå…ƒç´ ã€‚é‡å¤ä¸Šè¿°æ“ä½œç›´åˆ°åœæ­¢ï¼Œé—®èƒ½å¾—åˆ°çš„æœ€å¤§å­—å…¸åºçš„åºåˆ—ã€‚é¢˜å¾ˆç®€å•ï¼Œç›¸ä¿¡èªæ˜çš„ä½ ä¸€å®šèƒ½åšå‡ºæ¥ã€‚æ€è·¯å¾ˆæ˜¾ç„¶ï¼Œå‰é¢å‡ ä¸ªæ•°å¿…ç„¶æ˜¯1ï¼Œæ‰€ä»¥è¦æƒ³è®©å­—å…¸åºå°½é‡å¤§å°±å¾—å°½å¿«å‡ºç°åˆ«çš„æ•°ï¼Œè¦æƒ³è®©ä¸€ä¸ªæ•°å‡ºç°å°±å¾—åˆ æ‰å…¨éƒ¨ä¸æ˜¯å®ƒå€æ•°çš„æ•°ï¼Œé‚£ä¹ˆæœ€å¿«èƒ½å‡ºç°çš„æ•°å°±æ˜¯2äº†ï¼Œåªè¦æŠŠæ‰€æœ‰å¥‡æ•°åˆ æ‰å°±è¡Œäº†ã€‚ç„¶åå°±å‰©ä¸‹äº†ä¸€å †å¶æ•°ï¼Œæ˜¯ä¸æ˜¯çœ‹èµ·æ¥ä¼¼æ›¾ç›¸è¯†ï¼Ÿæ²¡é”™ä»–åˆå˜æˆäº†åˆšæ‰çš„é—®é¢˜åªä¸è¿‡æ‰€æœ‰æ•°éƒ½ä¹˜äº†2ï¼ˆç¦æ­¢å¥—å¨ƒï¼‰ã€‚é‚£å•¥æ—¶å€™åœå‘¢ï¼Ÿå½“nå°äº3çš„æ—¶å€™ï¼Œå› ä¸ºæ­¤æ—¶æ— æ³•ç”¨åˆšæ‰çš„è§„å¾‹ã€‚æ˜¯ä¸æ˜¯å¾ˆæœ‰æ„æ€å‘¢ï¼Ÿå…¶å®é€’å½’çš„é¢˜éƒ½æŒºæœ‰æ„æ€çš„ã€‚ä»£ç #include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define _ <<' '<<\n#define de(x) cout<<#x<<\" = \"<<(x)<<endl\n#define de2(x,y) cout<<#x<<\" = \"<<(x) _ #y<<\" = \"<<y<<endl;\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nvoid solve(int x,int mul){\n    if(x==1) cout<<mul<<' ';\n    else if(x==2) cout<<mul<<' '<<2*mul<<' ';\n    else if(x==3) cout<<mul<<' '<<mul<<' '<<3*mul<<' ';\n    else{\n        for(int i=1;i<=x;i+=2) cout<<mul<<' ';\n        solve(x/2,mul*2);\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    solve(n,1);\n    return 0;\n}"},{"id":"CF1128C","title":"CodeForces 1128C - Primes and Multiplication é¢˜è§£","content":"long longçˆ†çš„å¥½å•Šï¼ï¼é¢˜ç›®é“¾æ¥æˆ‘ä»¬æŠŠè¦æ±‚çš„å¼å­å±•å¼€ç„¶åæ¯æ¬¡è®¡ç®—ä¸€åˆ—ï¼Œç”±äºæ˜¯è´¨æ•°ï¼Œå½“ä¸”ä»…å½“æ—¶ï¼Œå¦åˆ™ã€‚ç”±äºåŒä¸€åˆ—ä¸­éƒ½æ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥åªè¦è®¡ç®—æŒ‡æ•°ä¹‹å’Œå°±è¡Œäº†ã€‚ç›´æ¥åˆ†æä»£ç ï¼šll tmp = it;\r\nll cnt = 0;\r\nwhile (tmp <= n) {\r\n    cnt += (n / tmp);\r\n    if (n / tmp < it)\r\n    break;\r\n    tmp *= it;\r\n}\r\nif (cnt == 0)\r\n    continue;\r\nans = ans * binpow(it, cnt) % mod;çš„ç»“æœå°±æ˜¯å¯¹äºå½“å‰çš„tmpï¼Œä¸­æœ‰å‡ ä¸ªå¯ä»¥æ•´é™¤tmpã€‚\r\nå¯¹äºæ¯ä¸ªæ•°å­—éƒ½è¢«ç­›è¿‡æ¬¡ï¼Œæ‰€ä»¥ç´¯åŠ æ¯ä¸€æ¬¡çš„å°±æ˜¯æŒ‡æ•°ä¹‹å’Œäº†ã€‚æ³¨æ„å¯èƒ½ä¼šçˆ†long longæ‰€ä»¥ä¹˜ä¹‹å‰è¦å…ˆæ£€æŸ¥ä¸€ä¸‹ï¼ˆåšçš„æ—¶å€™è¢«å¡äº†ï¼Œç›´æ¥è‡ªé—­ï¼‰ã€‚å®Œæ•´ä»£ç ï¼š#include<iostream>\r\n#include<vector>\r\n\r\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\r\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\r\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\r\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\r\n#define pb push_back\r\n#define ms(a, x) memset(a, x, sizeof(a))\r\n#define endl '\\n'\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nconst int INF = 0x3f3f3f3f;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int mod = 1e9 + 7;\r\n\r\nlong long binpow(long long a, long long b) {\r\n  long long res = 1;\r\n  while (b > 0) {\r\n    if (b & 1)\r\n      res = (res * a) % mod;\r\n    a = (a * a) % mod;\r\n    b >>= 1;\r\n  }\r\n  return res;\r\n}\r\nint main() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(0);\r\n  vector<int> pr;\r\n  ll x, n;\r\n  cin >> x >> n;\r\n  if (x % 2 == 0) {\r\n    while (x % 2 == 0)\r\n      x /= 2;\r\n    pr.pb(2);\r\n  }\r\n  for (int i = 3; i * i <= x; i += 2) {\r\n    if (x % i == 0) {\r\n      pr.pb(i);\r\n      while (x % i == 0)\r\n        x /= i;\r\n    }\r\n  }\r\n  if (x > 1)\r\n    pr.pb(x);\r\n  ll ans = 1;\r\n  for (auto it : pr) {\r\n    ll tmp = it;\r\n    ll cnt = 0;\r\n    while (tmp <= n) {\r\n      cnt += (n / tmp);\r\n      if (n / tmp < it)\r\n        break;\r\n      tmp *= it;\r\n    }\r\n    if (cnt == 0) continue;\r\n    ans = ans * binpow(it, cnt) % mod;\r\n  }\r\n  cout << ans;\r\n  return 0;\r\n}"},{"id":"CF1128d","title":"CodeForces1228D - Complete Tripartite é¢˜è§£","content":"è¿™å“ˆå¸Œé•¿è§è¯†äº†ã€‚è¿™ä¸ªæ˜¯åœ¨CFé¢˜è§£çš„è¯„è®ºåŒºé‡Œçœ‹åˆ°çš„è§£æ³•ï¼Œéå¸¸éœ‡æƒŠï¼Œä¸ç¦æƒ³åˆ°äº†å­¦é•¿å’Œæˆ‘ä»¬è¯´è¿‡çš„è¯:\"å“ˆå¸Œæ˜¯ä¸€ç§æ€æƒ³\"ã€‚è¿™æ¬¡çœŸçš„æ˜¯ä½“ä¼šåˆ°äº†ã€‚æ€è·¯ï¼šå®šä¹‰ç»™äº†è¿™ä¹ˆå¤šï¼Œå…¶å®å°±æ˜¯æŠŠå®Œå…¨äºŒåˆ†å›¾çš„æ¦‚å¿µæ‰©å±•æˆäº†å®Œå…¨ä¸‰åˆ†å›¾ã€‚æœ‰ä¸€ç‚¹å¾ˆé‡è¦çš„æ€§è´¨ï¼Œå°±æ˜¯å¦‚æœä¸¤ä¸ªç‚¹çš„ç›´æ¥è¿æ¥çš„ç‚¹æ˜¯ä¸€æ ·çš„è¯é‚£ä¹ˆè¿™ä¸¤ä¸ªç‚¹å¿…å®šå±äºåŒä¸€ä¸ªé›†åˆï¼Œè¿™æ ·å°±å¯ä»¥ç”¨å“ˆå¸Œçš„æ–¹æ³•å¿«é€Ÿåˆ¤æ–­ä¸¤ä¸ªç‚¹æ˜¯å¦å…·æœ‰ç›¸åŒçš„é‚»å±…: é€šè¿‡ç»™æ¯ä¸ªç‚¹ä¸€ä¸ªå€¼ï¼Œé‚£ä¹ˆä¸€ä¸ªç‚¹çš„å“ˆå¸Œå€¼å°±æ˜¯è¯¥ç‚¹é‚»å±…çš„ç‚¹å€¼çš„å’Œï¼Œå¦‚æœä¸¤ä¸ªç‚¹çš„å“ˆå¸Œå€¼ä¸€æ ·ï¼Œé‚£ä¹ˆå°±å¤§æ¦‚ç‡è‚¯å®šä¸¤ä¸ªç‚¹çš„é‚»å±…æ˜¯ä¸€æ ·çš„ã€‚ä»£ç #include <iostream>\r\n#include <map>\r\n \r\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\r\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\r\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\r\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\r\n#define pb push_back\r\n#define ms(a, x) memset(a, x, sizeof(a))\r\n#define endl '\\n'\r\nusing namespace std;\r\n \r\ntypedef long long ll;\r\nconst int INF = 0x3f3f3f3f;\r\ntypedef pair<int, int> pii;\r\n \r\nconst int N=1e5+5;\r\nll po[N],ha[N];\r\nconst int mod=1e9+7; \r\nint main() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(0);\r\n    int n,m;\r\n    cin>>n>>m;\r\n    po[0]=1;\r\n    for1(i,n) po[i]=po[i-1]*29;\r\n    forn(i,m){\r\n        int x,y;\r\n        cin>>x>>y;\r\n        ha[x]+=po[y];\r\n        ha[y]+=po[x];\r\n    }\r\n    map<ll,ll> mp;\r\n    int idx=0;\r\n    for1(i,n){\r\n        if(ha[i]==0){\r\n            cout<<-1;\r\n            return 0;\r\n        }\r\n        if(mp[ha[i]]==0) mp[ha[i]]=++idx;\r\n    }\r\n    if(idx==3){\r\n        for1(i,n) cout<<mp[ha[i]]<<' ';\r\n    }else cout<<-1;\r\n  return 0;\r\n}"},{"id":"CF1131F","title":"Codeforces 1131F - Asya And Kittens é¢˜è§£","content":"æ–°å¹´ç¬¬ä¸€poï¼é¢˜è§£è¿™ä¸ªé¢˜æˆ‘ä»¬ç”¨å¹¶æŸ¥é›†æ¥åˆå¹¶é›†åˆå¹¶ç”¨ æˆ– æ¥ç»´æŠ¤æ¯ä¸ªé›†åˆé‡Œé¢çš„å…ƒç´ ã€‚ï¼ˆç†è®ºä¸Šæ¥è¯´liståº”è¯¥å¿«å¾ˆå¤šï¼Œä½†æäº¤åçš„è¿è¡Œæ—¶é—´å·®ä¸å¤šï¼‰å…·ä½“æ­¥éª¤å°±æ˜¯ï¼šæ‰¾åˆ°ä¸¤ä¸ªçŒ«çš„ç¥–å…ˆçš„idåˆå¹¶ä¸¤ä¸ªé›†åˆï¼Œå¹¶ä¸”æ‹¼æ¥ä¸¤ä¸ªé“¾è¡¨ï¼ˆæˆ–è€…æ•°ç»„ï¼‰Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define _ <<' '<<\n#define de(x) cout<<#x<<\" = \"<<(x)<<endl\n#define de2(x,y) cout<<#x<<\" = \"<<(x) _ #y<<\" = \"<<y<<endl;\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst int N=15e4+5;\nint pre[N];\nint find(int x){\n    return pre[x]==x?x:pre[x]=find(pre[x]);\n}\nvoid join(int x,int y){\n    x=find(x),y=find(y);\n    pre[x]=y;\n}\nlist<int> v[N];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n    cin>>n;\n    for1(i,n) pre[i]=i,v[i].eb(i);\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        x=find(x),y=find(y);\n        v[x].splice(v[x].end(),v[y]);    \n        pre[y]=x;\n    }\n    for(auto it:v[find(1)]) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF1187D","title":"Codeforces 1187D - Subarray Sorting é¢˜è§£","content":"é¢˜è§£æˆ‘ä»¬å¯ä»¥åšçš„æœ€å°çš„æ“ä½œå°±æ˜¯åªæ’åºç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ ï¼Œä¹Ÿå°±æ˜¯è¯´äº¤æ¢å’Œå¦‚æœã€‚é€šè¿‡è¿™ç§æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæŒªåˆ°ä½ç½®ï¼Œå¦‚æœæ‰€æœ‰åˆ°çš„æ•°éƒ½æ¯”å°çš„è¯ã€‚æ˜ç™½äº†æ“ä½œçš„æœ¬è´¨ä¹‹åæˆ‘ä»¬å°±å¯ä»¥å°è¯•ä»ç”¨aæ•°ç»„çš„æ•°å·¦å¾€å³æ„é€ bæ•°ç»„äº†ã€‚è®¾å½“å‰çš„ä½ç½®ä¸º:é¦–å…ˆæ‰¾åˆ°æœ€å·¦çš„ä½ç½®ä½¿å¾—ï¼Œå¦‚æœæ‰¾ä¸åˆ°é‚£ä¹ˆç­”æ¡ˆæ˜¯noã€‚æˆ‘ä»¬å¯ä»¥ç”¨setæˆ–è€…å¾ˆå¤šä¸ªvectorç»´æŠ¤ä½ç½®ã€‚åˆ¤æ–­ï¼ˆæœ€åˆçš„ä¸‹æ ‡ï¼‰ä¸­çš„æœ€å°å€¼æ˜¯å¦æ¯”å°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨çº¿æ®µæ ‘å®ç°è¿™ä¸€æ“ä½œã€‚å°†è®¾ä¸ºæ— ç©·å¤§ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(random_device{}());\ntemplate<typename... Args> void write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nstruct SegTree{\n    int n;\n    vector<int> t;\n    SegTree(int n_):n(n_){\n        t=vector<int>(2*n);\n    }\n    SegTree(vector<int> a){\n        n=a.size();\n        t=vector<int>(2*n);\n        for (int i=0;i<n;i++) t[n+i]=a[i];\n        for (int i = n - 1; i > 0; --i) t[i] = min(t[i<<1], t[i<<1|1]);\n    }\n\n    void update(int p, int value) {  // set value at position p\n        t[p += n] = value;\n        for (; p > 1; p >>= 1) t[p>>1] =min(t[p], t[p^1]);\n    }\n\n    int query(int l, int r) {  // sum on interval [l, r)\n        int res = 1e9;\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if (l&1) res =min(res, t[l++]);\n            if (r&1) res =min(res, t[--r]);\n        }\n        return res;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt;\n    cin>>tt;\n    while(tt--){\n        int n;\n        cin>>n;\n        vector<int> a(n),b(n);\n        set<pii> s;\n        forn(i,n){\n            cin>>a[i];\n            s.insert({a[i],i});\n        }\n        for(auto& it:b) cin>>it;\n        SegTree tr(a);\n        forn(i,n){\n            auto it=s.lower_bound({b[i],0});\n            if(it==s.end()||it->F!=b[i]||tr.query(0,it->S+1)<b[i]){\n                cout<<\"NO\\n\";\n                goto next;\n            }\n            tr.update(it->S,1e9);\n            s.erase(it);\n        }\n        cout<<\"YES\\n\";\nnext:;\n    }\n    return 0;\n}"},{"id":"CF1208D","title":"Codeforces 1208D- Restore Permutation é¢˜è§£","content":"é¢˜ç›®æœ¬èº«å°±å¾ˆå¥½ï¼ŒåŒæ—¶åˆèƒ½å¸¦æ¥å¯¹æ ‘çŠ¶æ•°ç»„çš„ä¸€äº›æ€è€ƒã€‚é¢˜è§£æˆ‘ä»¬è¦å€’ç€å¤„ç†ï¼Œå¯¹äºå½“å‰çš„ï¼Œä¼šå­˜åœ¨ä¸€ä¸ªï¼Œä½¿å¾—ä¸ªè¿˜æ²¡æœ‰ç”¨è¿‡çš„æœ€å°çš„æ•°çš„å’Œä¸ºã€‚é‚£ä¹ˆå½“å‰çš„ç­”æ¡ˆå°±æ˜¯ã€‚å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„é…äºŒåˆ†æ‰¾ï¼Œä¹Ÿå¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„é…å€å¢é»‘ç§‘æŠ€æ±‚ã€‚CodeäºŒåˆ†#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate<typename... Args>\nvoid write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nstruct fenwick{\n    vector<ll> t;\n    int n;\n    fenwick(int n_):n(n_){\n        t=vector<ll>(n+1);\n    }\n    void update(int i,int x){\n        for(;i<=n;i+=i&-i){\n            t[i]+=x;\n        }\n    }\n    ll get(int i){\n        ll res=0;\n        for(;i>0;i-=i&-i) res+=t[i];\n        return res;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<ll> a(n);\n    for(auto& it:a) cin>>it;\n    fenwick tree(n);\n    for(int i=1;i<=n;i++) tree.update(i,i);\n    vector<int> ans(n);\n    for(int i=n-1;i>=0;i--){\n        int l=1,r=n;\n        while(l<=r){\n            int mid=(l+r)>>1;\n            if(tree.get(mid)<=a[i]) l=mid+1;\n            else r=mid-1;\n        }\n        ans[i]=l;\n        tree.update(l,-l);\n    }\n    for(auto it:ans) cout<<it<<' ';\n    return 0;\n}å€å¢#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate<typename... Args>\nvoid write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nstruct fenwick{\n    vector<ll> t;\n    int n;\n    fenwick(int n_):n(n_){\n        t=vector<ll>(n+1);\n    }\n    void update(int i,int x){\n        for(;i<=n;i+=i&-i){\n            t[i]+=x;\n        }\n    }\n    int search(ll prefix){\n        int pos=0;\n        ll sum=0;\n        for(int i=20;i>=0;i--){\n            if(pos+(1<<i)<=n&&(sum+t[pos+(1<<i)]<=prefix)){\n                pos+=(1<<i);\n                sum+=t[pos];\n            }\n        }\n        return pos+1;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<ll> a(n);\n    for(auto& it:a) cin>>it;\n    fenwick tree(n);\n    for(int i=1;i<=n;i++) tree.update(i,i);\n    vector<int> ans(n);\n    for(int i=n-1;i>=0;i--){\n        int x=tree.search(a[i]);\n        ans[i]=x;\n        tree.update(x,-x);\n    }\n    for(auto it:ans) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF1220D","title":"Codeforces 1220D - Alex and Julian é¢˜è§£","content":"å¦ˆä¸ªå”§çœ‹é”™é¢˜äº†SolutionIf there's only one element in the set, the graph is obvious bipartite. If there's more than two elements, the graph will contains some cycles due to each pair of elements.Suppose we have  and  in the set and the cycle will look like this:It easy to see that the length of the cycle is  which we want to be even. The length is even iff both  and  contains the same power of 2 in their factorizations. Otherwise  and  will have different parity, which means their sum is odd.(Try to prove by yourself)Finally we need to find the largest subset whose elements have the same power of two and remove the rest elements.é¢˜è§£ä¸€ç‚¹ä¸­æ–‡ä¸å†™ä¹Ÿä¸å¤ªå¥½ï¼Œä¸‡ä¸€æœ‰äººçœ‹å‘¢â€¦â€¦ç®€å•å†™ä¸€ä¸‹è¦ç‚¹å§ï¼Œè¿™é¢˜å…³é”®åœ¨äºç†è§£ç¯æ˜¯æ€ä¹ˆå½¢æˆçš„ï¼Œç¯çš„é•¿åº¦æ˜¯å¤šå°‘ï¼Œä»¥åŠä¸ºä»€ä¹ˆå½“ä¸”ä»…å½“ä¸¤ä¸ªæ•°åŒ…å«ç›¸åŒ2çš„å¹‚çš„æ—¶å€™ç¯çš„é•¿åº¦æ˜¯å¶æ•°ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate<typename... Args>\nvoid write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n    cin>>n;\n    vector<ll> cnt[60];\n    forn(i,n){\n        ll x;\n        cin>>x;\n        ll tmp=x;\n        int c=0;\n        while(x%2==0) x/=2,c++;\n        cnt[c].pb(tmp);\n    }\n    int mx=0,idx;\n    forn(i,60) if(size(cnt[i])>mx){\n        mx=size(cnt[i]);\n        idx=i;\n    }\n    cout<<n-size(cnt[idx])<<endl;\n    forn(i,60){\n        if(i!=idx){\n            for(auto it:cnt[i]) cout<<it<<' ';\n        }\n    }\n\n    return 0;\n}å‚è€ƒèµ„æ–™https://codeforces.com/blog/entry/69901https://codeforces.com/blog/entry/69899"},{"id":"CF1234E","title":"CodeForces1234E - Special Permutations é¢˜è§£","content":"ä¸€å¼€å§‹åšéº»çƒ¦äº†ï¼Œå…³é”®æ˜¯å†™éº»çƒ¦äº†è¿˜æ²¡è¿‡ï¼Œå¥½æ°”å“¦ã€‚è¿™é¢˜åº”è¯¥æœ‰å¾ˆå¤šä¸åŒçš„æ€è·¯ã€‚æˆ‘çš„æƒ³æ³•æ˜¯è®¡ç®—ç»™å‡ºçš„æ•°ç»„ä¸­æ¯ä¸€å¯¹ç›¸é‚»çš„æ•°åœ¨ä¹‹åçš„æ’åˆ—ï¼ˆPermutationï¼‰ä¸­è·ç¦»çš„å˜åŒ–ï¼Œç„¶ååªè¦ä»¥ç¬¬ä¸€ä¸ªæ’åˆ—çš„ç­”æ¡ˆä¸ºåŸºå‡†ï¼ŒåŠ ä¸Šä¹‹åæ’åˆ—çš„è·ç¦»å˜åŒ–å°±æ˜¯åé¢æ’åˆ—çš„ç­”æ¡ˆäº†ã€‚é‚£ä¹ˆè·ç¦»æ˜¯å¦‚ä½•å˜åŒ–çš„å‘¢ï¼Œæˆ‘ä»¬è®¾ä¸€å¯¹ç›¸é‚»çš„æ•°ä¸­æ¯”è¾ƒå°çš„æ•°æ˜¯ï¼Œæ¯”è¾ƒå¤§çš„æ•°æ˜¯ ï¼Œé‚£ä¹ˆä»–ä»¬åœ¨ç¬¬ä¸€ä¸ªæ’åˆ—ä¸­çš„ä½ç½®å°±æ˜¯è¿™æ ·çš„:\n\nåœ¨ç¬¬ä¸€ä¸ªä¸€ç›´åˆ°ç¬¬ä¸ªæ’åˆ—ä¸­ï¼Œå’Œçš„ä½ç½®éƒ½æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œè‡ªç„¶è·ç¦»ä¹Ÿä¸å˜ã€‚ä½†åœ¨ç¬¬ä¸ªæ’åˆ—ä¸­ï¼Œæˆäº†ç¬¬ä¸€ä¸ªæ•°ï¼š\nä¸çš„è·ç¦»å¢åŠ äº†ã€‚åœ¨ç¬¬åˆ°ä¸ªæ’åˆ—ä¸­ï¼Œä¸ä¸­çš„æŸä¸€ä¸ªæ•°ä¼šåœ¨æœ€å‰é¢ï¼Œæ‰€ä»¥ä¸çš„è·ç¦»æ¯”æœ€å¼€å§‹å°‘1ã€‚åœ¨ç¬¬ä¸ªæ’åˆ—ä¸­ï¼Œrè·‘åˆ°äº†æœ€å‰é¢ï¼š\n\næ³¨æ„æ­¤æ—¶lçš„ä½ç½®ä¾ç„¶æ˜¯ï¼Œæ‰€ä»¥è·ç¦»çš„å˜åŒ–æ˜¯å¦‚æœæˆ‘ä»¬ç”¨ä¸€ä¸ªæ•°ç»„aæ¥ä¿å­˜æ‰€æœ‰æ’åˆ—ä¸­ç­”æ¡ˆçš„å˜åŒ–ï¼Œé‚£ä¹ˆå¯¹äºæ¯ä¸€å¯¹,æˆ‘ä»¬åº”è¯¥åšå¦‚ä¸‹ä¸‰ä¸ªæ“ä½œï¼šç”±äºå…¶ä¸­æ¶‰åŠåˆ°åŒºé—´ä¿®æ”¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å·®åˆ†çš„æ€æƒ³æ¥å®ç°ï¼Œå¹¶ä¸”ç”±äºåªä¼šæŸ¥è¯¢ä¸€æ¬¡ï¼Œæ‰€ä»¥ç”¨æœ€ç®€å•çš„æ•°ç»„å°±å¯ä»¥äº†ï¼Œå…·ä½“å®ç°è§ä»£ç :#include <iostream>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long ll;\nconst int INF = 0x3f3f3f3f;\ntypedef pair<int, int> pii;\n\nconst int N=2e5+5;\nll sum[N];\nint n,m;\nvoid rgadd(int l,int r,int x){\n    sum[l]+=x;\n    sum[r+1]-=x;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n    cin>>n>>m;\n    int x,last;\n    cin>>last;\n    ll ans=0;\n    forn(i,m-1){\n        cin>>x;\n        int mn=min(x,last),mx=max(x,last);\n        ans+=mx-mn;\n        last=x;\n        if(mx==mn) continue;\n        rgadd(mn,mn,mn-1);\n        rgadd(mx,mx,(mn-mx+mn));\n        if(mx-mn>1)\n        rgadd(mn+1,mx-1,-1);\n    }\n    for1(i,n){\n        ans+=sum[i];\n        cout<<an<<' ';\n    }\n  return 0;\n}"},{"id":"CF1249D2","title":"Codeforces 1249D2 - Too Many Segments (hard version) é¢˜è§£","content":"è¶Šæ¥è¶Šèœäº†é¢˜è§£è´ªå¿ƒçš„ç­–ç•¥æ˜¯ï¼šéå†æ‰€æœ‰ç‚¹ï¼Œå½“æˆ‘ä»¬å‘ç°æœ‰è¢«è¶…è¿‡æ¡çº¿æ®µè¦†ç›–çš„ç‚¹æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥ç§»é™¤å³ç«¯ç‚¹æœ€é å³çš„çº¿æ®µã€‚ä¸ºäº†å®ç°æˆ‘ä»¬çš„ç­–ç•¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ•°ç»„ æ¥å­˜å‚¨ä»¥ç‚¹å¼€å§‹çš„çº¿æ®µï¼Œå’Œæ•°ç»„æ¥å­˜å‚¨ä»¥ç‚¹ç»“æŸçš„çº¿æ®µã€‚æˆ‘ä»¬åŒæ—¶è¿˜éœ€è¦ç»´æŠ¤è¦†ç›–å½“å‰ç‚¹çš„é›†åˆï¼Œä»¥åŠä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—æ¥å¯»æ‰¾å³ç«¯ç‚¹æœ€å³çš„çº¿æ®µã€‚å…·ä½“æ¥è¯´ï¼Œå°±æ˜¯å¯¹äºæ¯ä¸ªç‚¹ï¼Œæˆ‘ä»¬å…ˆå¾€é›†åˆé‡Œæ’å…¥ä»è¿™ä¸ªç‚¹å¼€å§‹çš„çº¿æ®µï¼Œç„¶åæ‰¾å‡ºåº”è¯¥åˆ é™¤çš„çº¿æ®µå¹¶åˆ é™¤ï¼Œæœ€åä»é›†åˆé‡Œç§»é™¤ä»¥è¿™ä¸ªç‚¹ç»“æŸçš„çº¿æ®µã€‚Code#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N=2e5+5;\nvector<pii> open[N];\nvector<int> close[N];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n,k;\n    cin>>n>>k;\n    for(int i=1;i<=n;i++){\n        int l,r;\n        cin>>l>>r;\n        close[r].emplace_back(i);\n        open[l].emplace_back(r,i);\n    }\n    set<int> now;\n    vector<int> ans;\n    priority_queue<pii> pq;\n    for(int i=1;i<=N-1;i++){\n        for(auto it:open[i]){\n            now.insert(it.S);\n            pq.push(it);\n        }\n        while(now.size()>k){\n            pii tmp=pq.top();\n            pq.pop();\n            now.erase(tmp.S);\n            ans.emplace_back(tmp.S);\n        }\n        for(int x:close[i]){\n            now.erase(x);\n        }\n    }\n    cout<<ans.size()<<endl;\n    for(int it:ans) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF1263E","title":"Codeforces 1263E - Editor é¢˜è§£","content":"è§£æ³•é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å‡ ç‚¹æ­£ç¡®åŒ¹é…çš„æ‹¬å·åºåˆ—çš„æ€§è´¨ï¼šå¦‚æœæˆ‘ä»¬æŠŠå·¦æ‹¬å·æ¢æˆ1ï¼ŒæŠŠå³æ‹¬å·æ¢æˆ-1çš„è¯ï¼šåºåˆ—çš„å’Œä¸º0ä»»æ„å‰ç¼€å’Œä¸å°äº0å‰ç¼€å’Œä¸­æœ€å¤§å€¼å°±æ˜¯åµŒå¥—æœ€å¤šçš„æ‹¬å·æ•°æ ¹æ®è¿™äº›æ€§è´¨ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥æ”¯æŒåŒºé—´ä¿®æ”¹å’ŒæŸ¥è¯¢æœ€å€¼çš„æ•°æ®ç»“æ„ï¼Œå¾ˆæ˜æ˜¾ï¼Œå°±æ˜¯çº¿æ®µæ ‘äº†ã€‚æ³¨æ„ï¼šæ•´ä¸ªåºåˆ—çš„å’Œå¯ä»¥é€šè¿‡æŸ¥è¯¢æœ€åä¸€ä¸ªå…ƒç´ çš„å€¼æ¥å¾—åˆ°ï¼Œqueryå‡½æ•°å°±æ˜¯ä¸ºäº†å¹²è¿™ä¸ªçš„ã€‚Code#include <bits/stdc++.h>\n \n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define tr t[root]\nusing namespace std;\n \nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n \nconst int N=1e6;\nint n;\nstruct segt{\n    int l,r;\n    ll min,max,tag;\n}t[N<<2];\nvoid build(int root,int l,int r){\n    t[root].l=l;\n    t[root].r=r;\n    if(l==r) return;\n    int mid=(l+r)>>1;\n    build(root<<1,l,mid);\n    build(root<<1|1,mid+1,r);\n}\nvoid addtag(int p,int x){\n    t[p].max+=x;\n    t[p].min+=x;\n    t[p].tag+=x;\n}\nvoid spread(int p){\n    if(t[p].tag){\n        addtag(p<<1|1,t[p].tag);\n        addtag(p<<1,t[p].tag);\n        t[p].tag=0;\n    }\n}\nvoid update(int root,int l,int r,int x){\n    if(l<=t[root].l&&r>=t[root].r){\n        addtag(root,x);\n        return;\n    }\n    spread(root);\n    int mid=(t[root].l+t[root].r)>>1;\n    if(l<=mid) update(root<<1,l,r,x);\n    if(r>mid) update(root<<1|1,l,r,x);\n    tr.max=max(t[root<<1].max,t[root<<1|1].max);\n    tr.min=min(t[root<<1].min,t[root<<1|1].min);\n}\nint query(int root,int x){\n    if(tr.l==tr.r) return tr.max;\n    spread(root);\n    int mid=(tr.l+tr.r)>>1;\n    if(mid>=x) return query(root<<1,x);\n    else return query(root<<1|1,x);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n;\n    int pos=1;\n    vector<int> a(n+1);\n    build(1,1,n);\n    for1(i,n){\n        char ch;\n        cin>>ch;\n       int val=0;\n       if(ch=='L'){\n           pos=max(1,pos-1);\n           goto write;\n       }else if(ch=='R'){\n           pos++;\n           goto write;\n       }else if(ch=='(') val=1;\n       else if (ch==')') val=-1;\n       update(1,pos,n,val-a[pos]);\n       a[pos]=val;\n       write:\n       if(t[1].min<0||query(1,n)!=0) cout<<-1<<' ';\n       else cout<<t[1].max<<' ';\n    }\n    return 0;\n}"},{"id":"CF1265D","title":"Codeforces 1265D - Beautiful Sequence é¢˜è§£","content":"æ¯”èµ›çš„æ—¶å€™å¤ªè ¢äº†ã€‚é¢˜è§£è¿™é¢˜çš„å…³é”®åœ¨äºç­”æ¡ˆçš„ç¬¬ä¸€ä¸ªæ•°è¦ä¹ˆæ˜¯æœ€å°çš„æ•°è¦ä¹ˆæ˜¯ç¬¬äºŒå°çš„æ•°ï¼Œä¸¤ç§æƒ…å†µéƒ½è¯•ä¸€ä¸‹ã€‚å¡«æŸä¸€ä½çš„æ—¶å€™ï¼Œè¦ä¹ˆæ˜¯ä¸Šä¸€ä½åŠ ä¸€ï¼Œè¦ä¹ˆæ˜¯ä¸Šä¸€ä½å‡ä¸€ï¼Œå…ˆè¯•å‡1ï¼Œå¦‚æœæ²¡æœ‰å‡1å¯ä»¥ç”¨äº†å°±è¯•åŠ 1ï¼Œå¦‚æœåŠ ä¸€ä¹Ÿæ²¡æœ‰äº†é‚£å°±å¯ä»¥åœæ­¢å»å°è¯•ä»¥å¦ä¸€ä¸ªæ•°å¼€å¤´çš„æƒ…å†µäº†ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tint a[5]={0},cnt[4],sum=0;\n    forn(i,4) cin>>cnt[i],a[i]=cnt[i],sum+=a[i];\n    int start;\n    forn(i,4){\n        if(a[i]){\n            start=i;\n            break;\n        }\n    }\n    vector<int> ans(sum);\n    bool flag=0;\n    for(int j=0;j<2&&!flag;j++){\n        forn(i,4) a[i]=cnt[i];\n        if(start+j>3||a[start+j]==0) break;\n        ans[0]=start+j;\n        a[start+j]--;\n        for(int i=1;i<sum;i++){\n            if(ans[i-1]==0){\n                if(a[1]){\n                    ans[i]=1;\n                    a[1]--;\n                }else break;\n            }else if(ans[i-1]==3){\n                if(a[2]){\n                    ans[i]=2;\n                    a[2]--;\n                }else break;\n            }else{\n                if(a[ans[i-1]-1]){\n                    ans[i]=ans[i-1]-1;\n                    a[ans[i-1]-1]--;\n                }else if(a[ans[i-1]+1]){\n                    ans[i]=ans[i-1]+1;\n                    a[ans[i-1]+1]--;\n                }else break;\n            }\n            if(i==sum-1) flag=1;\n        }\n        if(sum==1) flag=1;\n    }\n    if(flag){\n        cout<<\"YES\\n\";\n        for(int it:ans) cout<<it<<' ';\n    }else cout<<\"NO\";\n    return 0;\n}"},{"id":"CF1271C","title":"Codeforces 1271C - Shawarma Tent é¢˜è§£","content":"é¢˜è§£å¾ˆæ˜æ˜¾å¸ç¯·åº”è¯¥å’Œå­¦æ ¡æŒ¨ç€ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨å››ä¸ªå˜é‡æ¥è®°å½•å­¦æ ¡çš„æ¯ä¸€è¾¹æœ‰å‡ ä¸ªæˆ¿å­ï¼Œæœ€åè¾“å‡ºæœ€å¤šçš„é‚£ä¸€è¾¹å³å¯ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tint n,x,y;\n    cin>>n>>x>>y;\n    int a=0,b=0,c=0,d=0;\n    forn(i,n){\n        int k,j;\n        cin>>j>>k;\n        if(j>x) a++;\n        else if(j<x) b++;\n        if(k>y) c++;\n        else if(k<y) d++;\n    }\n    int mx=max({a,b,d,c});\n    cout<<mx<<endl;\n    if(mx==a) cout<<x+1<<' '<<y;\n    else if(mx==b) cout<<x-1<<' '<<y;\n    else if(mx==c) cout<<x<<' '<<y+1;\n    else cout<<x<<' '<<y-1;\n    return 0;\n}"},{"id":"CF1271D","title":"Codeforces 1271D - Portals é¢˜è§£","content":"é¢˜è§£é¦–å…ˆæˆ‘ä»¬è¦è®¡ç®—åœ¨æ¯ä¸ªåŸå ¡é€šå…³æ‰€éœ€è¦çš„æœ€å°‘å‹‡å£«çš„æ•°é‡()ï¼Œ è¿™æ ·æˆ‘ä»¬å°±èƒ½çŸ¥é“åœ¨æ‹›å‹Ÿä¹‹åæœ‰å¤šå°‘è‡ªç”±æ”¯é…çš„å‹‡å£«()ã€‚è¿™ä¹ˆè®¡ç®—ã€‚è¡¨ç¤ºæœ€åä¸€ä¸ªå¯ä»¥æ´¾å‹‡å£«æ¥å®ˆå«åŸå ¡çš„åŸå ¡ã€‚ç°åœ¨é—®é¢˜å°±è½¬åŒ–æˆäº†å¦‚ä½•åˆ†é…å‹‡å£«æ¥å®ˆå«è¿™äº›åŸå ¡ã€‚æˆ‘ä»¬ç”¨è´ªå¿ƒçš„æ€è·¯ï¼šæŒ‰ç…§åŸå ¡çš„é‡è¦ç¨‹åº¦æ¥å®ˆå«ï¼Œå¯¹äºåŸå ¡ï¼Œå¦‚æœæˆ‘ä»¬èƒ½åœ¨å‰é¢æ‰¾åˆ°æœ‰ç©ºé—²çš„å‹‡å£«é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å®ˆæŠ¤è¿™ä¸ªåŸå ¡ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tint n,m,k,tot;\n    cin>>n>>m>>k;\n    tot=k;\n    vector<int> a(n+1),b(n+1),last(n+1),fr(n+1),req(n+2);\n    vector<pii> c(n+1);\n    int flag=0;\n    for1(i,n){\n        cin>>a[i]>>b[i]>>c[i].F;\n        c[i].S=i;\n        if(tot<a[i]){\n            flag=1;\n        }else{\n            tot+=b[i];\n        }\n        last[i]=i;\n    }\n    forn(i,m){\n        int u,v;\n        cin>>u>>v;\n        last[v]=max(last[v],u);\n    }\n    if(flag) cout<<-1;\n    else{\n        for(int i=n;i>=1;i--){\n            if(i==n) req[i]=0;\n            else req[i]=max(a[i+1],req[i+1]-b[i+1]);\n        }\n        tot=k;\n        for1(i,n){\n            tot+=b[i];\n            fr[i]=tot-req[i];\n            tot=req[i];\n        }\n        sort(c.begin()+1,c.end(),[](pii a,pii b){\n            return a.F>b.F;\n        });\n        int ans=0;\n        for1(i,n){\n            int val=c[i].F,x=c[i].S;\n            int y=last[x];\n            while(!fr[y]&&y>0)y--;\n            if(y==0)continue;\n            fr[y]--;\n            ans+=val; \n        }\n        cout<<ans;\n    }\n    return 0;\n}"},{"id":"CF1278D","title":"Codeforces 1248D - Segment Tree é¢˜è§£","content":"è¿™è·Ÿæš´åŠ›åˆæœ‰ä»€ä¹ˆåŒºåˆ«å‘¢ï¼Ÿé¢˜è§£æˆ‘ä»¬å…ˆå°†æ‰€æœ‰çº¿æ®µçš„ä»¥çš„å½¢å¼å­˜åˆ°æ•°ç»„é‡Œï¼Œç„¶åå†å°†æ•°ç»„æ’åºï¼Œç„¶åéå†æ•°ç»„ã€‚åŒæ—¶æˆ‘ä»¬è¿˜éœ€è¦ç»´æŠ¤ä¸€ä¸ªâ€œå¼€æ”¾çš„çº¿æ®µâ€çš„å³ç«¯ç‚¹çš„é›†åˆã€‚å½“æˆ‘ä»¬æ·»åŠ ä¸€æ¡æ–°çš„çº¿æ®µæ—¶ï¼Œéå†é›†åˆï¼Œç„¶åæ‰¾åˆ°æ¯”æ–°çº¿æ®µæ—©ç»“æŸçš„çº¿æ®µã€‚è¿™çœ‹èµ·æ¥æ˜¯ä¸æ˜¯å¾ˆåƒæš´åŠ›ï¼Ÿå¦‚æœè¦æ˜¯å¤„ç†å®Œæ‰€æœ‰çº¿æ®µæ˜¯è‚¯å®šè¶…æ—¶çš„ï¼Œä½†æ˜¯å¦‚æœäº¤ç‚¹çš„ä¸ªæ•°å·²ç»å¤§äºäº†ï¼Œé‚£ä¹ˆç­”æ¡ˆè‚¯å®šæ˜¯noï¼Œæ‰€ä»¥ç›´æ¥ç»“æŸå°±è¡Œã€‚æœ€åè¿˜è¦æ£€æŸ¥ä¸€ä¸‹å›¾çš„è¿é€šæ€§ï¼Œç”¨dfsæˆ–å¹¶æŸ¥é›†éƒ½è¡Œã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N=5e5+5;\nvector<int> G[N];\nbool vis[N];\nvoid dfs(int v){\n    vis[v]=true;\n    for(auto it:G[v]){\n        if(!vis[it])\n            dfs(it);\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tint n;\n    cin>>n;\n    vector<pii> a(n),evs;\n    forn(i,n){\n        cin>>a[i].F>>a[i].S;\n        evs.eb(a[i].F,i);\n        evs.eb(a[i].S,i);\n    }\n    sort(evs.begin(),evs.end());\n    int cnt=0;\n    set<pii> cur;\n    for(auto it:evs){\n        if(cnt>=n) break;\n        if(cur.count(it)) cur.erase(it);\n        else{\n            int i=it.S;\n            int r=a[i].S;\n            for(auto j:cur){\n                if(j.F>r) break;\n                G[i].pb(j.S);\n                G[j.S].pb(i);\n                cnt++;\n                if(cnt>=n) break;\n            }\n            cur.insert({r,i});\n        }\n    }\n    dfs(0);\n    int tot=count(vis,vis+n,true);\n    cout<<(cnt==n-1&&tot==n?\"YES\":\"NO\");\n    return 0;\n}"},{"id":"CF1279D","title":"CodeForces 1279D - Santa's Bot é¢˜è§£","content":"ç°åœ¨çœ‹æ¥å½“æ—¶æ˜¯çœŸçš„èœï¼Œä¸è¿‡è¿˜æ˜¯èƒ½å­¦åˆ°ä¸€äº›å¥‡æ€ªçš„çŸ¥è¯†233é¢˜è§£æœ€å¤šæœ‰å¯¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥éå†æ‰€æœ‰çš„å¯¹ã€‚æ¯ä¸€å¯¹æœ‰çš„æ¦‚ç‡è¢«é€‰ä¸­ï¼Œæ‰€ä»¥ä¸€ä¸ªåˆæ³•çš„çš„æ¦‚ç‡æ˜¯ï¼Œå…¶ä¸­æ˜¯æƒ³è¦yç¤¼ç‰©çš„å­©å­çš„ä¸ªæ•°ã€‚ä¸€ä¸ªæœ‰æ„æ€çš„æ€§è´¨æ˜¯ï¼Œå½“ä¸åˆ†æ¯äº’è´¨çš„æ—¶å€™æˆç«‹ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨éå†çš„æ—¶å€™å¯ä»¥ç›´æ¥æŠŠæ¦‚ç‡è½¬æ¢æˆç„¶ååŠ åˆ°ç­”æ¡ˆä¸Šã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst int p=998244353;\nconst int N=1e6+5;\nvector<int> a[N];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n    cin>>n;\n    ll ans=0;\n    map<int,int> cnt;\n    vector<ll> inv(N+1);\n    inv[1]=1;\n    for(int i=2;i<=N;i++) inv[i]=ll(p-p/i)*inv[p%i]%p;\n    forn(i,n){\n        int k;\n        cin>>k;\n        a[i].resize(k);\n        for(auto& it:a[i]){\n            cin>>it;\n            cnt[it]++;\n        }\n    }\n    forn(i,n){\n        for(auto it:a[i]){\n            ll x=cnt[it]*inv[n]%p*inv[n]%p*inv[size(a[i])]%p;\n            ans=(ans+x)%p;\n        }\n    }\n    cout<<ans;\n    return 0;\n}"},{"id":"CF1282D","title":"Codeforces 1282D - Enchanted Artifact é¢˜è§£","content":"InTerEStinG.é¢˜è§£é¦–å…ˆæˆ‘ä»¬å¯ä»¥ç”¨300ä¸ªaå’Œ300ä¸ªbæ¥çŸ¥é“aå’Œbçš„ä¸ªæ•°ã€‚åŒæ—¶ç­”æ¡ˆçš„é•¿åº¦å°±æ˜¯ä»–ä»¬çš„å’Œã€‚ç„¶åå‡è®¾ç­”æ¡ˆéƒ½æ˜¯aï¼Œå¦‚æœæˆ‘ä»¬æŠŠå…¶ä¸­ä¸€ä½æ¢æˆbé‚£ä¹ˆç­”æ¡ˆè¦ä¹ˆæ˜¯bä¸ªä¸ªæ•°+1è¦ä¹ˆæ•°bçš„ä¸ªæ•°-1ï¼Œå¦‚æœæ˜¯-1é‚£ä¸ªé‚£ä¸€ä½å°±æ˜¯bå¦åˆ™æ˜¯aã€‚å¯¹æ‰€æœ‰ä½ç½®é‡å¤ä¸Šè¿°æ“ä½œå°±åŸºæœ¬æ˜¯ç­”æ¡ˆäº†ã€‚æ³¨æ„æ­¤æ—¶æˆ‘ä»¬ç”¨äº†æ¬¡è¯¢é—®ï¼Œè¶…è¿‡äº†é™åˆ¶ï¼Œä½†å…¶å®æœ€åä¸€ä½ä¸ç”¨è¯¢é—®ï¼Œç”¨å‰é¢çš„ä¿¡æ¯å°±èƒ½ç®—å‡ºæ¥ã€‚"},{"id":"CF1284D","title":"Codeforces 1284D - New Year and Conference é¢˜è§£","content":"é¢˜è§£é¢˜ç›®æœ¬è´¨æ˜¯åˆ¤æ–­èƒ½å¦æ‰¾åˆ°ä¸€å¯¹çº¿æ®µä½¿å¾—ä»–ä»¬åœ¨ä¸€ä¸ªç»´åº¦ä¸Šç›¸äº¤ä½†ä¸åœ¨å¦ä¸€ç»´åº¦ä¸Šä¸ç›¸äº¤ã€‚ä¸ºäº†å¾—åˆ°æ‰€æœ‰ç›¸äº¤çš„çº¿æ®µï¼Œæˆ‘ä»¬è¦çŸ¥é“å¯¹äºæ‰€æœ‰æ—¶é—´ç‚¹è¢«å“ªäº›çº¿æ®µè¦†ç›–äº†ã€‚å…·ä½“ä¸€ç‚¹å°±æ˜¯éœ€è¦å‡ ä¸ªæ•°ç»„å’Œï¼Œåˆ†åˆ«å­˜çš„æ˜¯ä»¥å¼€å¤´å’Œç»“å°¾çš„çº¿æ®µã€‚é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•çŸ¥é“æ˜¯å¦æœ‰ä¸€å¯¹çº¿æ®µä¸ç›¸äº¤å‘¢ï¼Ÿæˆ‘ä»¬è¿˜éœ€è¦ç»´æŠ¤ä¸¤ä¸ªmultisetï¼Œä¸€ä¸ªå­˜å½“å‰çº¿æ®µçš„èµ·ç‚¹ï¼Œå¦ä¸€ä¸ªå­˜ç»ˆç‚¹ã€‚å¦‚æœæœ€å³è¾¹çš„èµ·ç‚¹å¤§äºæœ€å·¦è¾¹çš„ç»ˆç‚¹é‚£ä¹ˆå°±è¯´æ˜æœ‰ä¸¤ä¸ªçº¿æ®µæ²¡é‡å ã€‚æœ€ååˆ«å¿˜äº†ç¦»æ•£åŒ–å¹¶ä¸”ä¸¤ä¸ªç»´åº¦éƒ½è¦æ£€æŸ¥ä¸€ä¸‹ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n\ntypedef vector<int> vi;\nbool check(vi& sa,vi& ea,vi& sb,vi& eb,int m){\n    vector<vector<int>> l(m),r(m);\n    int n=sa.size();\n    forn(i,n){\n        l[sa[i]].pb(i);\n        r[ea[i]].pb(i);\n    }\n    multiset<int,greater<int>> lmax;\n    multiset<int> rmin;\n    forn(i,m){\n        for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]);\n        if(!empty(lmax)&& *lmax.begin()> *rmin.begin()) return 0;\n        for(auto id:r[i]){\n            lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id]));\n        }\n    }\n    return 1;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> sa(n),sb(n),ea(n),eb(n);\n    forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]);\n    vector<int> time;time.reserve(4*n);\n    for(auto it:sa) time.pb(it);\n    for(auto it:ea) time.pb(it);\n    for(auto it:sb) time.pb(it);\n    for(auto it:eb) time.pb(it);\n    sort(all(time));\n    time.resize(unique(all(time))-time.begin());\n    forn(i,n){\n        sa[i]=lower_bound(all(time),sa[i])-time.begin();\n        ea[i]=lower_bound(all(time),ea[i])-time.begin();\n        sb[i]=lower_bound(all(time),sb[i])-time.begin();\n        eb[i]=lower_bound(all(time),eb[i])-time.begin();\n    }\n    if(check(sa,ea,sb,eb,time.size())&& check(sb,eb,sa,ea,time.size())) cout<<\"YES\";\n    else cout<<\"NO\";\n\n    return 0;\n}"},{"id":"CF1285C","title":"Codeforces 1285C - Fadi and LCM é¢˜è§£","content":"long longå¼€å°äº†ï¼Œè¡€çš„æ•™è®­ã€‚é¢˜è§£ä¸éš¾çœ‹å‡ºå’Œå¿…é¡»æ˜¯äº’è´¨çš„ï¼Œæˆ‘ä»¬è´¨å› æ•°åˆ†è§£Xï¼Œæœ€å¤šæœ‰11ä¸ªä¸åŒçš„è´¨å› æ•°å› ä¸ºå‰12ä¸ªè´¨å› æ•°çš„ç§¯å¤§äºã€‚æˆ‘ä»¬å¯ä»¥æš´åŠ›æšä¸¾æ‰€æœ‰çš„åˆ†é…æƒ…å†µæ¥å¾—åˆ°æœ€ä¼˜çš„ç­”æ¡ˆã€‚å¦ä¸€ç§è§£æ³•æ˜¯éå†Xçš„æ‰€æœ‰å› æ•°ç„¶ååˆ¤æ–­æ˜¯å¦æ˜¯1å¹¶æ›´æ–°ç­”æ¡ˆã€‚CodePrime factorization:#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e12;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tll x;\n    cin>>x;\n    vector<ll> vec;\n    for(ll f=2;f*f<=x;f++){\n        ll tmp=1;\n        while(x%f==0){\n            tmp*=f;\n            x/=f;\n        }\n        if(tmp!=1) vec.pb(tmp);\n    }\n    if(x>1)vec.pb(x);\n    ll aa=INF,ab=INF;\n    for(ll i=0;i<(1<<vec.size());i++){\n        ll a=1,b=1;\n        forn(j,vec.size()){\n            if((i&(1<<j))>0) a*=vec[j];\n            else b*=vec[j];\n        }\n        if(max(a,b)<max(aa,ab)){\n            aa=a;\n            ab=b;\n        }\n    }\n    cout<<ab<<' '<<aa;\n    return 0;\n}Looping factors:#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF=1e15;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tll x;\n    cin>>x;\n    ll ansa=INF,ansb=INF;\n    for(ll f=1;f*f<=x;f++){\n        if(x%f==0){\n            if(__gcd(f,x/f)==1){\n                if(x/f<ansb){\n                    ansa=f;\n                    ansb=x/f;\n                }\n            }\n        }\n    }\n    cout<<ansa<<' '<<ansb;\n    return 0;\n}"},{"id":"CF1285D","title":"Codeforces 1285D - Dr. Evil Underscores é¢˜è§£","content":"Almosté¢˜è§£æˆ‘ä»¬ä»æœ€é«˜ä½å¼€å§‹å› ä¸ºæœ€é«˜ä½å¯¹æ•°çš„å½±å“æœ€å¤§ã€‚æˆ‘ä»¬éœ€è¦æŠŠæ‰€æœ‰æ•°åˆ†æˆä¸¤ç»„ï¼Œä¸€ç»„æ˜¯å½“å‰ä½ä¸º1çš„æ•°ï¼Œå¦ä¸€ç»„æ˜¯å½“å‰ä½ä¸º0çš„æ•°ã€‚å¦‚æœå…¶ä¸­ä¸€ç»„æ˜¯ç©ºçš„é‚£ä¹ˆæˆ‘ä»¬æ€»æ˜¯å¯ä»¥ä½¿è¿™ä¸€ä½å˜æˆ0ç„¶ååˆ°ä¸‹ä¸€ä½ã€‚å¦åˆ™è¿™ä¸€ä½æ€»ä¼šæœ‰1ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦å¯¹é‚£ä¸¤ç»„è§£å†³åŒæ ·çš„é—®é¢˜æ¥çŸ¥é“è¿™ä½æ˜¯å¡«1è¿˜æ˜¯0ï¼Œè¿™å¾ˆæ˜æ˜¾æ˜¯ä¸ªé€’å½’ã€‚è®¾é‚£ä¸¤ç»„çš„ç­”æ¡ˆåˆ†åˆ«æ˜¯å’Œï¼Œå½“å‰åœ¨ç¬¬ä½ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ã€‚Code#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> a;\nint dfs(vector<int> v,int idx){\n    if(v.empty()) return 0;\n    if(idx==-1) return 0;\n    vector<int> a,b;\n    for(auto it:v){\n        if(it&(1<<idx)) a.pb(it);\n        else b.pb(it);\n    }\n    if(a.empty()) return dfs(b,idx-1);\n    if(b.empty()) return dfs(a,idx-1);\n    return min(dfs(a,idx-1),dfs(b,idx-1))+(1<<idx);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n    cin>>n;\n    a.resize(n);\n    for(int& it:a) cin>>it;\n    cout<<dfs(a,30);\n    return 0;\n}"},{"id":"CF1286B","title":"CodeForces 1286B/1287D - Numbers on Tree é¢˜è§£","content":"æƒ³æ˜ç™½äº†ä»¥åå…¶å®å¾ˆç®€å•é¢˜è§£é¦–å…ˆï¼Œå¦‚æœå¤§äºçš„å­æ ‘çš„å¤§å°ï¼Œé‚£ä¹ˆç­”æ¡ˆä¸å­˜åœ¨ã€‚å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬å»ºç«‹ä¸€ä¸ªæ•°ç»„ï¼Œè¿™ä¸ªæ•°ç»„åŒ…å«è¿™ä¸ªèŠ‚ç‚¹æ‰€æœ‰å­æ ‘çš„èŠ‚ç‚¹ï¼ŒæŒ‰ç…§çš„å¤§å°æ’åºï¼ˆè™½ç„¶æˆ‘ä»¬ç°åœ¨è¿˜ä¸çŸ¥é“çš„å…·ä½“æ•°å€¼ï¼Œæˆ‘ä»¬åªå…³å¿ƒç›¸å¯¹å¤§å°å…³ç³»ï¼‰ã€‚ä¸‹ä¸€ä¸ªé—®é¢˜å°±æ˜¯å¦‚ä½•ç»„åˆå­èŠ‚ç‚¹çš„æ•°ç»„ï¼Œç­”æ¡ˆå…¶å®å¾ˆç®€å•ï¼šç›´æ¥æ‹¼èµ·æ¥å°±å¯ä»¥äº†ï¼Œå› ä¸ºæ¯ä¸ªå­æ ‘æ˜¯äº’ç›¸ç‹¬ç«‹çš„ã€‚æœ€åä¸€æ­¥å°±æ˜¯æŠŠå½“å‰çš„èŠ‚ç‚¹æ”¾è¿›å»ï¼Œå› ä¸ºæ˜¯å·²çŸ¥çš„æ‰€ä»¥æ•°ç»„çš„ç¬¬ä¸ªæ•°åº”è¯¥æ˜¯.ç°åœ¨æˆ‘ä»¬æœ‰äº†åŒ…å«æ‰€æœ‰èŠ‚ç‚¹çš„æ•°ç»„ï¼Œæˆ‘ä»¬æŠŠ èµ‹ç»™ å°±è¡Œäº†ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n\nvector<vector<int>> G;\nvector<int> c;\nvector<int> dfs(int u){\n    vector<int> order;\n    for(auto it:G[u]){\n        auto child_order=dfs(it);\n        order.insert(order.end(),all(child_order));\n    }\n    if(size(order)<c[u]){\n        cout<<\"NO\";\n        exit(0);\n    }\n    order.insert(order.begin()+c[u],u);\n    return order;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    G.resize(n+1);\n    c.resize(n+1);\n    int R;\n    for1(i,n){\n        int pa;\n        cin>>pa>>c[i];\n        if(pa==0) R=i;\n        G[pa].push_back(i);\n    }\n    auto order=dfs(R);\n    vector<int> ans(n+1);\n    forn(i,n) ans[order[i]]=i+1;\n    cout<<\"YES\\n\";\n    for1(i,n) cout<<ans[i]<<' ';\n    return 0;\n}"},{"id":"CF1294D","title":"Codeforces 1294D - MEX maximizing é¢˜è§£","content":"è¿˜æ˜¯å¤§ä½¬çš„æ€è·¯å¼ºå•Šã€‚é¢˜è§£æˆ‘ä»¬å¯ä»¥å¾—åˆ°æ‰€æœ‰æ¨¡ç›¸åŒçš„æ•°é€šè¿‡åŠ æˆ–å‡æ‰€ä»¥æˆ‘ä»¬åªå…³æ³¨ã€‚ä¸ºäº†ä½¿mexæœ€å¤§åŒ–ï¼Œæˆ‘ä»¬éœ€è¦ä»0å¼€å§‹å°½å¯èƒ½é•¿çš„è¿ç»­çš„æ•°ã€‚åœ¨æ¨¡çš„æ„ä¹‰ä¸‹ï¼Œä¹Ÿå°±æ˜¯è¯´ã€‚æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ä¿å­˜åŒä½™ç±»é‡Œçš„æ•°çš„ä¸ªæ•°ç„¶åæ¯æ¬¡è¯¢é—®åå°è¯•å¢åŠ ç­”æ¡ˆå°±è¡Œäº†ã€‚Code#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int q, x;\n    cin >> q >> x;\n    vector<int> cnt(x);\n    int ans = 0;\n    while (q--) {\n        int n;\n        cin >> n;\n        cnt[n % x]++;\n        while (cnt[ans % x]) {\n            cnt[ans % x]--;\n            ans++;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"},{"id":"CF1295D","title":"Codeforces 1295D - Same GCDs é¢˜è§£","content":"FMLé¢˜è§£è®©ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰ï¼Œä¸éš¾å‘ç°ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦ä½¿ï¼Œ å¿…é¡»æ˜¯çš„å€æ•°ï¼Œè®¾ã€‚ è€Œä¸”ï¼Œå’Œå¿…é¡»è¦äº’è´¨ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æ‰¾åˆ°ä»åˆ°ä¸­ä¸äº’è´¨çš„æ•°çš„ä¸ªæ•°ã€‚å¯¹äºé‚£äº›å¤§äºçš„æ•°ï¼Œå¦‚æœ é‚£ä¹ˆã€‚åˆå› ä¸ºï¼Œæ‰€ä»¥æˆ‘ä»¬çœŸæ­£è¦ç®—çš„æ˜¯æ¯”å°å¹¶ä¸”ä¸äº’è´¨çš„æ•°çš„ä¸ªæ•°, ä¹Ÿå°±æ˜¯ã€‚Code#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll Phi(ll m){\n\tll ans=m;\n\tfor(ll i=2;i*i<=m;i++){\n\t\tif(m%i==0){\n\t\t\tans-=ans/i;\n\t\t\twhile(m%i==0) m/=i;\n\t\t}\n\t}\n\tif(m>1) ans-=ans/m;\n\treturn ans;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint tt;\n\tcin>>tt;\n\twhile(tt--){\n\t\tll a,m;\n\t\tcin>>a>>m;\n\t\tcout<<Phi(m/gcd(a,m))<<endl;\n\n\t}\n    return 0;\n}"},{"id":"CF1300E","title":"Codeforces 1300E - Water Balance é¢˜è§£","content":"é¢˜è§£è¿™ä¸ªé¢˜æœ‰ç‚¹è´ªå¿ƒçš„æ„æ€ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸€ä¸ªæ°´ç®±çœ‹ä½œæ˜¯ä¸€äº›ç”±è¿ç»­æ°´ç®±ç»„æˆçš„ç»„ï¼Œæ¯ä¸ªç»„ä¸€å¼€å§‹çš„å¤§å°éƒ½æ˜¯1ã€‚å¦‚æœå½“å‰çš„ç»„çš„å¹³å‡å€¼æ¯”å·¦è¾¹çš„ç»„çš„å¹³å‡å€¼å°çš„è¯ï¼Œå°±åˆå¹¶è¿™ä¸¤ä¸ªç»„ã€‚ç”¨æ ˆå­˜å‚¨ä¹‹å‰ç»„çš„å¤§å°å’Œæ°´é‡çš„å’Œã€‚Code#include <bits/stdc++.h>\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<ll> a(n);\n\tfor(auto& it:a) scanf(\"%lld\",&it);\n\tvector<double> ans(n);\n\tstack<pair<ll,ll>> st;\n\tforn(i,n){\n\t\tll sum=a[i],num=1;\n\t\twhile(!st.empty()&&(1.0*sum/num)<=(1.0*st.top().F/st.top().S)){\n\t\t\tsum+=st.top().F;\n\t\t\tnum+=st.top().S;\n\t\t\tst.pop();\n\t\t}\n\t\tst.push({sum,num});\n\t}\n\tint cnt=n-1;\n\twhile(!st.empty()){\n\t\tfor(int i=0;i<st.top().S;i++,cnt--){\n\t\t\tans[cnt]=1.0*st.top().F/st.top().S;\n\t\t}\n\t\tst.pop();\n\t}\n\tfor(auto it:ans) printf(\"%.9lf\\n\",it);\n\treturn 0;\n}"},{"id":"CF1324F","title":"CodeForces 1324F - Maximum White Subtree é¢˜è§£","content":"å¥½é¢˜ï¼é¢˜è§£ç­”æ¡ˆåˆ†ä¸¤æ­¥dfsï¼Œç¬¬ä¸€ä¸ªdfsç”¨æ¥è®¡ç®—ï¼š çš„å­æ ‘ä¸­çš„çš„å­å›¾çš„æœ€å¤§å·®å€¼ã€‚ç¨å¾®æœ‰ç‚¹ç»•ï¼Œå…¶å®é¢˜ç›®ä¸­çš„â€œå­æ ‘â€åº”è¯¥å«å­å›¾æ¯”è¾ƒåˆé€‚ï¼Œå› ä¸ºæ˜¯æ— æ ¹æ ‘ï¼Œè¯´å­å›¾æ²¡ä»€ä¹ˆæ„ä¹‰ã€‚ä½†æˆ‘ä»¬dfsçš„æ—¶å€™å…¶å®æ˜¯æŠŠå›¾å½“æˆæœ‰æ ¹æ ‘ï¼Œæ‰€ä»¥ç¬¬ä¸€æ¬¡dfså¾—åˆ°çš„ç­”æ¡ˆåªè€ƒè™‘äº†å­æ ‘çš„è´¡çŒ®ï¼Œå‰©ä½™éƒ¨åˆ†çš„è´¡çŒ®ç”±ç¬¬äºŒä¸ªdfsç®—ã€‚å…¶ä»–éƒ¨åˆ†çš„è´¡çŒ®çœ‹è‹±æ–‡å§â€¦â€¦æ‡’å¾—å†å†™ä¸€éäº†ï¼ˆé€ƒï¼‰ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=2e5+5;\nvector<int> G[N];\nint ans[N],a[N],dp[N];\nvoid dfs1(int u,int fa){\n\tdp[u]=a[u];\n\tfor(auto it:G[u]){\n\t\tif(it!=fa){\n\t\t\tdfs1(it,u);\n\t\t\tdp[u]+=max(0,dp[it]);\n\t\t}\n\t}\n}\nvoid dfs2(int u,int fa,int pd){\n\tans[u]=dp[u]+pd;\n\tfor(auto v:G[u]){\n\t\tif(v!=fa){\n\t\t\tdfs2(v,u,max(ans[u]-max(dp[v],0),0));\n\t\t}\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tcin>>n;\n\tfor1(i,n) {\n\t\tcin>>a[i];\n\t\tif(!a[i]) a[i]=-1;\n\t}\n\tforn(i,n-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tdfs1(1,-1);\n\tdfs2(1,-1,0);\n\tfor1(i,n) cout<<ans[i]<<' ';\n\treturn 0;\n}"},{"id":"CF1358E","title":"Codeforces 1358E - Are You Fired? é¢˜è§£","content":"å¥½å‡ å¤©æ²¡æ›´æ–°äº†é¢˜è§£é¦–å…ˆï¼Œå…ˆå®šä¹‰è¿™ä¸ªå‡½æ•°ï¼Œä¹Ÿå°±æ˜¯ä»å¼€å§‹å¾€åè¿ç»­ä¸ªæ•°çš„å’Œã€‚ç„¶åæˆ‘ä»¬è¯æ˜å¦‚æœkå’Œä¸€ä¸ªç­”æ¡ˆé‚£ä¹ˆ2kä¹Ÿæ˜¯ä¸€ä¸ªç­”æ¡ˆï¼šã€‚å› æ­¤æˆ‘ä»¬ä»èƒ½æ‰¾åˆ°ä¸€ä¸ªå¤§äºçš„ç­”æ¡ˆã€‚ç„¶åæˆ‘ä»¬åˆ†ç±»è®¨è®ºï¼Œå…ˆè€ƒè™‘çš„æƒ…å†µã€‚å¦‚æœkæ˜¯ç­”æ¡ˆï¼Œå› ä¸ºï¼Œæ‰€ä»¥k+1ä¹Ÿæ˜¯ä¸€ä¸ªç­”æ¡ˆï¼Œå› æ­¤æˆ‘ä»¬åªè¦åˆ¤æ–­æ˜¯ä¸æ˜¯ç­”æ¡ˆå°±è¡Œäº†ã€‚æœ€åï¼Œè€ƒè™‘ï¼Œæˆ‘ä»¬éœ€è¦å€ŸåŠ©ä»¥ä¸‹å‰ç¼€å’Œï¼Œå®šä¹‰ å¹¶ä¸” . æˆ‘ä»¬éœ€è¦æ‰¾åˆ°  ä½¿å¾—å¯¹äºæ‰€æœ‰:å› ä¸ºï¼Œâ€œçª—å£â€ä¹‹åçš„æ‰€æœ‰æ•°å­—éƒ½æ˜¯ï¼Œæ‰€ä»¥ä¸Šé¢çš„ä¸ç­‰å¼å¯ä»¥å†™æˆè¿™æ ·ï¼šå¯¹äºæ¯ä¸€ä¸ªï¼Œå¯¹åº”çš„kæ˜¯ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸ç­‰å¼å·¦è¾¹çš„æœ€å¤§å€¼å¦‚æœå°äºï¼Œé‚£ä¹ˆæ˜¯ä¸€ä¸ªç­”æ¡ˆã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    forn(i, (n + 1) / 2) {\n        cin >> a[i];\n    }\n    int x;\n    cin >> x;\n    for (int i = (n + 1) / 2; i < n; i++) a[i] = x;\n    vector<ll> ps(n + 1);\n    partial_sum(all(a), ps.begin() + 1);\n    if (ps.back() > 0) return cout << n, 0;\n    if (x >= 0) return cout << -1, 0;\n    ll N2 = n / 2, N1 = n - N2, sum = ps.back();\n    ll mx = -1e18;\n    for (int i = 0; i <= N1; i++) {\n        mx = max(mx, ps[i] + x * ll(n - i));\n        if (mx < sum + x * ll(n - i)) {\n            cout << n - i;\n            return 0;\n        }\n    }\n    cout << -1;\n    return 0;\n}"},{"id":"CF1367F2","title":"Codeforces 1367F2 - Flying Sort (Hard Version) é¢˜è§£","content":"å…¶å®å¹¶ä¸éš¾ï¼Œå®˜æ–¹é¢˜è§£ç»™çš„dpåšæ³•å¤ªå“äººäº†é¢˜è§£é¦–å…ˆå®šä¹‰ä¸€ä¸‹â€œæ’äº†åºçš„å­åºåˆ—â€ï¼šå®ƒæ˜¯ä¸€ä¸ªåŸæ•°ç»„çš„å­åºåˆ—å¹¶ä¸”åœ¨æ’åºä¹‹åçš„æ•°ç»„ä¸­æ˜¯ä¸€ä¸ªå­æ•°ç»„ã€‚ä¸éš¾çœ‹å‡ºæ²¡ç”¨è¢«ç§»åŠ¨è¿‡çš„å…ƒç´ ä¼šå½¢æˆä¸€ä¸ªæ’äº†åºçš„å­åºåˆ—ã€‚æ‰€ä»¥è¯´å¦‚æœæˆ‘ä»¬æ‰¾åˆ°æœ€é•¿çš„æ’äº†åºçš„å­åºåˆ—é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯æœ€å°çš„ã€‚å› ä¸ºæˆ‘ä»¬åªå…³æ³¨æ•°å­—çš„ç›¸å¯¹å¤§å°ï¼Œæˆ‘ä»¬å¯ä»¥å‹ç¼©ä¸€ä¸‹æ•°å­—ï¼Œè¿™æ ·å†™èµ·æ¥ä¼šç®€å•ä¸€äº›ã€‚ç„¶åæ¯ä¸ªæ•°ç»„å¼€ä¸€ä¸ªæ•°ç»„å­˜æ”¹æ•°å­—çš„æ‰€æœ‰ä¸‹æ ‡ã€‚ç„¶åéå†æ‰€æœ‰æ•°å­—ï¼Œå¦‚æœå½“å‰æ•°å­—çš„æœ€å°ä¸‹æ ‡å¤§äºä¹‹å‰æ•°å­—çš„æœ€å¤§ä¸‹æ ‡ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å­—çš„æ‰€æœ‰ä¸‹æ ‡éƒ½å¯ä»¥åŠ åˆ°å½“å‰çš„å­åºåˆ—é‡Œã€‚å¦åˆ™æˆ‘ä»¬éœ€è¦é‡æ–°å¼€å§‹ä¸€ä¸ªå­åºåˆ—ï¼Œä»¥ä¸‹ä¸¤ç‚¹éœ€è¦æ³¨æ„ï¼šå½“å‰æ•°å­—çš„ä¸€éƒ¨åˆ†ä¹Ÿæ˜¯å¯ä»¥è¢«åŠ åˆ°åˆšæ‰çš„å­åºåˆ—é‡Œçš„ï¼Œæ¯”å¦‚è¯´ï¼Œç¬¬äºŒä¸ª2å°±å¯ä»¥åŠ è¿›å»å˜æˆã€‚ä¹‹å‰çš„æ•°çš„ä¸€éƒ¨åˆ†ä¹Ÿå¯ä»¥è¢«åŠ åˆ°æ–°çš„å­åºåˆ—é‡Œï¼Œæ¯”å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠç¬¬ä¸€ä¸ª1åŠ è¿›æ¥å˜æˆã€‚ä½†æ˜¯è¿˜æœ‰ä¸€ç§ç‰¹æ®Šçš„æƒ…å†µï¼šè¿™ä¸ªå­åºåˆ—åªåŒ…å«ä¸¤ä¸ªæ•°çš„ä¸‹æ ‡ï¼Œå¹¶ä¸”è¿™ä¸¤ä¸ªæ•°çš„ä¸‹æ ‡éƒ½æ˜¯ä¸å®Œæ•´çš„ï¼Œæ¯”å¦‚ã€‚ä¸éš¾çœ‹å‡ºæˆ‘ä»¬è¦å–ç¬¬ä¸€ä¸ªæ•°çš„ä¸€ä¸ªå‰ç¼€ï¼Œå–ç¬¬äºŒä¸ªæ•°çš„ä¸€ä¸ªåç¼€ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥æšä¸¾å‰ç¼€çš„ä½ç½®ç„¶åæ‰¾åˆ°å¯¹åº”çš„åç¼€ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define size(x) int(x.size())\n#define pb push_back\n\nusing namespace std;\nusing ll=long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt;\n    cin>>tt;\n    for1(T,tt){\n        int n;\n        cin>>n;\n        vector<int> a(n),d(n);\n        forn(i,n){\n            cin>>a[i];\n            d[i]=a[i];\n        }\n        //coord compression \n        sort(all(d));\n        d.resize(unique(all(d))-d.begin());\n        vector<vector<int>> pos(size(d));\n        forn(i,n){\n            a[i]=lower_bound(all(d),a[i])-d.begin();\n            pos[a[i]].push_back(i);\n        }\n\n        int r=-1,mxlen=0,curlen=0;\n        forn(i,size(d)){\n            if(pos[i][0]>r){\n                curlen+=size(pos[i]);\n            }else{\n                //extend to the right for the old sequence\n                auto j=lower_bound(all(pos[i]),r);\n                mxlen=max(mxlen,curlen+int(pos[i].end()-j));\n                //extend to the left for the new sequence\n                auto it=lower_bound(all(pos[i-1]),pos[i][0]);\n                curlen=int(it-pos[i-1].begin())+size(pos[i]);\n            }\n            mxlen=max(mxlen,curlen);\n            r=pos[i].back();\n        }\n        //check the special case: sequence containing only two numbers\n        forn(i,size(d)-1){\n            forn(j,size(pos[i])){\n                auto it=lower_bound(all(pos[i+1]),pos[i][j]);\n                mxlen=max(mxlen,j+1+int(pos[i+1].end()-it));\n            }\n        }\n        cout<<n-mxlen<<endl;\n    }\n    return 0;\n}"},{"id":"CF1369E","title":"é¢˜è§£Codeforces 1369E - DeadLee","content":"è´ªå°±å®Œäº‹äº†é¢˜è§£é¦–å…ˆå…ˆç®—å‡ºï¼šå–œæ¬¢é£Ÿç‰©çš„äººçš„ä¸ªæ•°ã€‚å¯¹äºé£Ÿç‰©ï¼Œå¦‚æœï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºè¿™äº›äººæ— è®ºä½ ä»¥ä»€ä¹ˆé¡ºåºå«ä»–ä»¬éƒ½æœ‰é£Ÿç‰©åƒã€‚æ‰€ä»¥æˆ‘ä»¬å°½å¯èƒ½çš„æ™šå«ä»–ä»¬ã€‚æ•´ä¸ªè¿‡ç¨‹æœ‰ç‚¹åƒæ‹“æ‰‘æ’åºæˆ–è€…è¯´æ˜¯BFSï¼šä»æ‰€æœ‰æ»¡è¶³çš„ç‚¹å¼€å§‹ï¼Œå½“è®¿é—®æ–°çš„ç‚¹uæ—¶ï¼Œå‡1ï¼Œå¦‚æœçš„è¯ï¼Œå°±æŠŠuåŠ è¿›é˜Ÿåˆ—å¹¶æŠŠuåŠ åˆ°å«äººçš„åå•é‡Œã€‚æœ€ååè½¬åå•å°±å¾—åˆ°ç­”æ¡ˆäº†ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define pb push_back\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,m;\n    cin>>n>>m;\n    vector<int> a(n),deg(n);\n    for(auto& i:a) cin>>i;\n    vector<vector<pii>> G(n);\n    forn(i,m){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        deg[x]++,deg[y]++;\n        G[x].pb({y,i});\n        G[y].pb({x,i});\n    }\n    vector<int> ans;\n    vector<int> vis(m);\n    queue<int> q;\n    forn(i,n){\n        if(deg[i]<=a[i]){\n            q.push(i);\n        }\n    }\n    while(!q.empty()){\n        int u=q.front();\n        q.pop();\n        for(auto [to,i]:G[u]){\n            if(!vis[i]){\n                ans.pb(i+1);\n                vis[i]=1;\n                deg[to]--;\n                if(deg[to]<=a[to]) q.push(to);\n            }\n        }\n    }\n    if(sz(ans)!=m) return cout<<\"DEAD\",0;\n    reverse(all(ans));\n    cout<<\"ALIVE\\n\";\n    for(auto it:ans) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF1432recap","title":"Recap of Educational Codeforces round 86","content":"æ•°å­¦å¤ªåƒåœ¾aå†™é”™äº†ä¸€ä¸ªåœ°æ–¹ä½†æ ·ä¾‹è¿‡äº†ä¹Ÿå°±æ²¡å¤šæƒ³å°±äº¤äº†ï¼Œä¸Šæ¥å°±åƒä¸€å‘waâ€¦â€¦bé¢˜ä¹Ÿå·®ä¸å¤šï¼Œç®€å•æƒ³äº†æƒ³å°±å¼€å§‹å†™ï¼Œä¹Ÿæ²¡è€ƒè™‘ä¸€äº›æ›´å¤æ‚çš„æƒ…å†µï¼Œåˆåƒä¸€å‘waã€‚cé¢˜åº”è¯¥æ—©ç‚¹æ‰“è¡¨çš„ï¼Œæ‰‹åŠ¨æšä¸¾è¿˜æ˜¯è´¹æ—¶é—´ï¼Œè€Œä¸”è¿˜ç®—é”™äº†ä¸€ä¸ªï¼Œæ›´åŠ é˜»ç¢äº†å‘ç°è§„å¾‹ã€‚ç„¶åå°±æ˜¯è®¡æ•°é—®é¢˜ï¼Œç®—ç›¸ç­‰çš„æƒ…å†µç¡®å®æ²¡é”™ï¼Œä½†æœ‰ç‚¹è¿‡äºæƒ³æŠŠå…¬å¼ä¸€èˆ¬åŒ–äº†ï¼Œå°±åº”è¯¥æŒ‰ç…§è‡ªå·±çš„æƒ³æ³•æ¥ï¼Œå“ªæ€•å…¬å¼é•¿ä¸€äº›ï¼Œæ¯•ç«Ÿæ¯”èµ›è¿½æ±‚çš„è¿˜æ˜¯é€Ÿåº¦ã€‚dé¢˜è´ªå¿ƒç­–ç•¥æƒ³é”™äº†ï¼Œè²Œä¼¼ç»å¸¸çŠ¯è¿™æ ·çš„é”™è¯¯ï¼Œä¸€ç§ç­–ç•¥æ˜¯ä»å¤§å¾€å°å¡«ã€‚æ€»ç»“ï¼šè¿˜æ˜¯åº”è¯¥å³æ—¶å†³å®šå–èˆï¼Œé‡å†™å¾€å¾€æ¯”ä¿®æ”¹å¥½ï¼ˆåœ¨å¡é¢˜çš„æ—¶å€™ï¼‰ï¼Œè¿˜æœ‰å¿ƒæ€çš„é—®é¢˜ã€‚"},{"id":"CF1537E","title":"CodeForces 1537E - Erase and Extend é¢˜è§£","content":"å½“æ—¶æœ‰ä¸ªç»†èŠ‚æ²¡æƒ³åˆ°ï¼Œç›´æ¥fsté¦–å…ˆä¸éš¾è¯æ˜æœ€ç»ˆçš„å­—ç¬¦ä¸²ä¸€å®šæ˜¯ç”±sçš„ä¸€ä¸ªå‰ç¼€ä¸æ–­é‡å¤å¾—åˆ°çš„ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æšä¸¾å‰ç¼€çš„ä½ç½®i,å¦‚æœä»iå¼€å§‹é‡å¤èƒ½ä½¿å¾—æ–°å­—ç¬¦ä¸²æ¯”åŸå­—ç¬¦ä¸²å°çš„è¯è¿™ä¸ªä½ç½®å°±æ˜¯æœ‰åˆ©çš„ï¼ŒåŒæ—¶æ ¹æ®å­—å…¸åºçš„è§„åˆ™ï¼Œiè‚¯å®šæ˜¯è¶Šé å‰è¶Šå¥½ï¼Œäºæ˜¯æˆ‘ä»¬å°±å¾—åˆ°äº†ç­–ç•¥ï¼šå°†ä¸æ¯”è¾ƒï¼Œä»æ¯”å¤§çš„ä¸­æ‰¾å‡ºiæœ€å°çš„é‚£ä¸ªã€‚æˆ‘æ¯”èµ›çš„æ—¶å€™ä¸€çœ‹è¿™ä¸å°±æ˜¯åç¼€æ•°ç»„å˜›ï¼Œè¿‡äº†pretestå¿ƒé‡Œç¾æ»‹æ»‹ï¼Œç»“æœsystem testçš„æ—¶å€™ï¼šé‚£ä¹ˆé—®é¢˜å‡ºåœ¨å“ªäº†å‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹è¿™ä¸ªä¾‹å­ã€‚å½“æ—¶ï¼Œæ˜¯çš„ä¸€ä¸ªå‰ç¼€ï¼Œçœ‹ä¼¼æ¯”è¾ƒå°ï¼Œä½†ç”±äºå­—ç¬¦ä¸²æ˜¯å¾ªç¯çš„æ‰€ä»¥è¡¥ä¸Šä¸€ä¸ªä¹‹åå˜ä¸ºå°±æ¯”så¤§äº†ã€‚æ‰€ä»¥è¿™ç§æƒ…å†µä¹Ÿå°±æ˜¯è¯´çš„æŸä¸ªåç¼€ç­‰äºå‰ç¼€ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥è¯´æ˜æ‰”æ‰è¿™ä¸ªåç¼€å¯ä»¥è·å¾—æ›´å¥½çš„ç­”æ¡ˆï¼šå‡è®¾è¿™ä¸ªåç¼€çš„é•¿åº¦æ˜¯ï¼Œä¸å¾ªç¯ä¸€æ¬¡åä¼šåœ¨ä¸å¯¹åº”çš„ä½ç½®å‘ç”Ÿä¸åŒï¼Œæ¯”å¦‚è¯´å¾ªç¯ä¹‹åæ˜¯è¿™æ ·çš„å…¶ä¸­ç«–çº¿ç”¨æ¥åˆ†éš”å¾ªç¯ï¼Œä¸‹åˆ’çº¿æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²å¼€å§‹ä¸åŒçš„ä½ç½®ã€‚å¯ä»¥è¯æ˜,å› ä¸ºå¦‚æœå°äºçš„è¯ï¼Œç”±äºï¼Œæ‰€ä»¥å°±æ˜¯æ›´å¥½çš„ä½ç½®ï¼Œä¹Ÿå°±ç”¨ä¸åˆ°è€ƒè™‘åç¼€çš„æƒ…å†µäº†ï¼Œå› æ­¤æˆ‘ä»¬è¯´æ˜äº†æ‰”æ‰åç¼€ä¸€å®šæ˜¯æ›´å¥½çš„é€‰æ‹©ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æƒ³åŠæ³•è®©åç¼€åœ¨åç¼€æ•°ç»„ä¸­æ’åœ¨åé¢ï¼Œäºæ˜¯æˆ‘ä»¬å¯ä»¥åœ¨åé¢åŠ ä¸€ä¸ªå¤§äºæ‰€æœ‰å­—æ¯çš„å­—ç¬¦ï¼Œè¿™æ ·å°±ä¿è¯äº†å¦‚æœæœ‰åç¼€æ˜¯sçš„å‰ç¼€çš„æƒ…å†µï¼Œåç¼€ä¸€å®šæ’åœ¨såé¢ã€‚è¿™æ ·æˆ‘ä»¬å°±å¾—åˆ°äº†ç”¨æ¯”è¾ƒæ— è„‘çš„ç”¨åç¼€æ•°ç»„çš„åšæ³•ï¼š#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> suffix_array(string s) {\n    s += \"#\";\n    int n = s.size(), N = n + 256;\n    vector<int> sa(n), ra(n);\n    for (int i = 0; i < n; i++)\n        sa[i] = i, ra[i] = s[i];\n    for (int k = 0; k < n; k ? k *= 2 : k++) {\n        vector<int> nsa(sa), nra(n), cnt(N);\n        for (int i = 0; i < n; i++) nsa[i] = (nsa[i] - k + n) % n;\n        for (int i = 0; i < n; i++) cnt[ra[i]]++;\n        for (int i = 1; i < N; i++) cnt[i] += cnt[i - 1];\n        for (int i = n - 1; i >= 0; i--) sa[--cnt[ra[nsa[i]]]] = nsa[i];\n\n        int r = 0;\n        for (int i = 1; i < n; i++) {\n            if (ra[sa[i]] != ra[sa[i - 1]]) r++;\n            else if (ra[(sa[i] + k) % n] != ra[(sa[i - 1] + k) % n])\n                r++;\n            nra[sa[i]] = r;\n        }\n        ra = nra;\n    }\n    sa.erase(sa.begin());\n    return sa;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    string s;\n    cin >> n >> k >> s;\n    s += '|';\n    auto sa = suffix_array(s);\n    int ii = find(sa.begin(), sa.end(), 0) - sa.begin();\n    int mn = *min_element(sa.begin() + ii + 1, sa.end());\n    for (int i = 0; i < k; i++)\n        cout << s[i % mn];\n    return 0;\n}ä½†æ˜¯åç¼€æ•°ç»„æœ‰ç‚¹æ€é¸¡ç”¨ç‰›åˆ€äº†ï¼Œæˆ‘ä»¬å…¶å®åªç”¨å’Œåšæ¯”è¾ƒï¼Œæ‰€ä»¥å¦ä¸€ç§æ›´ç®€å•çš„åšæ³•æ˜¯ç”¨zå‡½æ•°ï¼Œå› ä¸ºzå‡½æ•°æ±‚çš„æ˜¯ä¸æ•´ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å‰ç¼€ï¼Œæ‰€ä»¥æ¯”è¾ƒå‰ç¼€åä¸‹ä¸€ä¸ªå­—ç¬¦å°±èƒ½çŸ¥é“å¤§å°å…³ç³»äº†ã€‚å¯¹äºåç¼€çš„ç‰¹æ®Šæƒ…å†µï¼Œå¦‚æœä¸‹ä¸€ä¸ªå­—ç¬¦çš„ä½ç½®æ˜¯ä¹Ÿå°±è¯´æ˜ æ˜¯çš„å‰ç¼€ï¼Œæ‰€ä»¥æ­¤æ—¶içš„ä½ç½®å°±æ˜¯æœ€ä½³ä½ç½®ã€‚ä»£ç å¦‚ä¸‹ï¼š#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> z_function(const string &s) {\n    int n = (int)s.size();\n    vector<int> z(n);\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\n        if (i <= r) z[i] = min(r - i + 1, z[i - l]);\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n            ++z[i];\n        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;\n    }\n    return z;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    string s;\n    cin >> n >> k >> s;\n    auto z = z_function(s);\n    for (int i = 1; i < n; i++) {\n        int f = z[i];\n        if (f + i >= n || s[f] < s[f + i]) {\n            s.erase(s.begin() + i, s.end());\n            break;\n        }\n    }\n    for (int i = 0; i < k; i++)\n        cout << s[i % s.size()];\n    return 0;\n}"},{"id":"CF1539F","title":"CodeForces 1539F - Strange Array é¢˜è§£","content":"é¢˜ç›®é“¾æ¥æ€è·¯ä¸éš¾ä½†çº¿æ®µæ ‘ç»´æŠ¤çš„å†…å®¹éœ€è¦ä¸€å®šçš„æŠ€å·§ã€‚é¢˜è§£é¦–å…ˆæˆ‘ä»¬çœ‹å¦‚ä½•å–lå’Œræ‰èƒ½ä½¿å¾—ç­”æ¡ˆæœ€å¤§ã€‚å¦‚æœçš„è¯ï¼Œåœ¨æ­£ä¸­é—´ï¼Œå¦‚æœåŠ å…¥ä¸€ä¸ªå°äºç­‰äºçš„æ•°ä¼šè®©å¾€å³åï¼Œåä¹‹ï¼ŒåŠ å…¥å¤§äºç­‰äºçš„æ•°ä¼šå¾€å·¦åï¼Œæ‰€ä»¥è®¾[l, r]ä¸­å¤§äº  çš„æ•°çš„ä¸ªæ•°ä¸ºï¼Œå°äºçš„æ•°çš„ä¸ªæ•°ä¸ºï¼Œï¼ˆç­‰äºçš„æ•°å¯ä»¥ç®—å…¥æˆ–å…¶ä¸­ä¹‹ä¸€ï¼‰æˆ‘ä»¬è¦è°ƒæ•´æ‰¾åˆ° çš„æœ€å¤§å’Œæœ€å°å€¼ï¼ˆåˆ†åˆ«å¯¹åº”åœ¨æœ€å·¦å’Œæœ€å³ï¼‰, æ­¤æ—¶çš„ç­”æ¡ˆä¸ºã€‚ç”±äºäº’ç›¸ç‹¬ç«‹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆ†åˆ«çœ‹ä¸¤ä¸ªåŒºé—´ï¼Œæ‰¾åˆ°, ä½¿å¾—ä¸­çš„æœ€å¤§æˆ–æœ€å°ã€‚å¦‚æœåªæ‰¾ä¸€ä¸ªçš„ç­”æ¡ˆçš„è¯ï¼Œå¯ä»¥éå¸¸è½»æ¾çš„ç”¨çº¿æ®µæ ‘è§£å†³ã€‚ä½†æ˜¯å¯¹äºæ•´ä¸ªæ•°ç»„çš„ç­”æ¡ˆå°±è¡Œä¸é€šäº†ï¼Œå¯¹äºå¤„ç†å¤§å°å…³ç³»çš„é¢˜ç›®ä¸€ç§å¸¸ç”¨çš„æŠ€å·§æ˜¯å°†æ•´ä¸ªæ•°ç»„æ’åºï¼Œä»å°åˆ°å¤§è¿›è¡Œå¤„ç†ï¼Œè¿™æ ·å°±èƒ½ä¿è¯ä¹‹å‰çš„æ•°éƒ½æ¯”å½“å‰æ•°å°ï¼Œå¤„ç†èµ·æ¥å°±ä¼šç®€å•å¾ˆå¤šã€‚å¯¹äºæœ¬é¢˜æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ•°ç»„ï¼Œå…¶ä¸­å¤§äºçš„ä½ç½®è®¾ä¸ºï¼Œå°äº çš„ä½ç½®è®¾ä¸º ï¼Œå¯¹äºæ¯ä¸ªä½ç½® ï¼Œæˆ‘ä»¬åªè¦æ‰¾åˆ°ä¸çš„æœ€å¤§å€¼ä¸æœ€å°å€¼ã€‚ç”±äºæˆ‘ä»¬æ˜¯ä»å°åˆ°å¤§å¤„ç†çš„æ‰€ä»¥æ¯æ¬¡åªæ”¹åŠ¨ä¸€ä¸ªä½ç½®(å°†1å˜æˆ-1)ï¼Œè¿™æ ·æ•°ç»„å°±å˜å¾—éå¸¸æ˜“äºç»´æŠ¤ã€‚ç»´æŠ¤æ•°ç»„çš„é¢˜æˆ‘ä»¬å¾ˆå®¹æ˜“æƒ³åˆ°ç”¨çº¿æ®µæ ‘ï¼Œä½†è¿™é¢˜çš„è¯¢é—®æ¯”è¾ƒç‰¹åˆ«ï¼Œçœ‹ä¼¼æ˜¯åŒºé—´æœ€å€¼ä½†å‡½æ•°å¯¹äºä¸åŒçš„iä¹Ÿä¼šæœ‰ä¸åŒçš„å€¼ã€‚è¿™é‡Œæˆ‘ä»¬ç”¨åˆ°ä¸€ç§åœ¨æœ€å¤§å­æ®µå’Œçš„é€’å½’å®ç°ä¸­ç”¨åˆ°çš„æŠ€å·§ï¼Œå³å¯¹äºçº¿æ®µæ ‘ä¸­çš„æ¯ä¸ªåŒºé—´ï¼Œç»´æŠ¤åŒºé—´å’Œï¼Œä»å·¦/å³ç«¯ç‚¹å¼€å§‹çš„æœ€å¤§/æœ€å°å­æ®µå’Œï¼Œç”¨æ•°å­¦è¯­è¨€æè¿°å°±æ˜¯:ä»¤å½“å‰ç»´æŠ¤çš„åŒºé—´æ˜¯äº†è§£äº†å®šä¹‰ä¹‹åï¼Œå¦‚ä½•åˆå¹¶åŒºé—´ä¹Ÿå°±å¾ˆå®¹æ˜“æƒ³åˆ°äº†ï¼ˆå…·ä½“çœ‹ä»£ç ï¼‰ï¼Œæ­¤å¤–ä¸ºäº†æ–¹ä¾¿å®ç°ï¼Œæˆ‘ä»¬åœ¨ä»£ç ä¸­å…è®¸æœ€å¤§/æœ€å°å­æ®µä¸åŒ…å«ä»»ä½•æ•°ã€‚è¿˜æœ‰ï¼Œç”±äºç›¸ç­‰çš„æ•°å¯ä»¥éšæ„æ’åˆ—ï¼Œæ‰€ä»¥æ—¢å¯ä»¥ç®—ä½œå¤§çš„æ•°åˆå¯ä»¥ç®—ä½œå°çš„æ•°ï¼Œæ‰€ä»¥è¦è¯¢é—®ä¸¤éä¸€æ¬¡å½“ä½œå°çš„æ•°ï¼Œä¸€æ¬¡å½“ä½œå¤§çš„æ•°ã€‚ä»£ç ï¼š#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T> struct SegTree {\n    int n;\n    vector<T> t;\n\n    SegTree(int n_) : n(n_), t(4 * n) { build(1, 0, n - 1, vector(n, T())); }\n\n    template <typename U> SegTree(const vector<T> &v) : SegTree((int)v.size()) {\n        build(1, 0, n - 1, v);\n    }\n\n    void pull(int node) { t[node] = t[node << 1] + t[node << 1 | 1]; }\n\n    template <typename U>\n    void build(int node, int l, int r, const vector<U> &v) {\n        if (l == r) {\n            t[node] = T(v[l]);\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(node << 1, l, mid, v);\n        build(node << 1 | 1, mid + 1, r, v);\n        pull(node);\n    }\n\n    void set(int node, int i, T x, int l, int r) {\n        if (l == r) {\n            t[node] = x;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (i <= mid) set(node << 1, i, x, l, mid);\n        else\n            set(node << 1 | 1, i, x, mid + 1, r);\n        pull(node);\n    }\n\n    T get(int node, int ql, int qr, int l, int r) {\n        if (ql <= l && qr >= r) return t[node];\n\n        int mid = (l + r) >> 1;\n        if (qr <= mid) return get(node << 1, ql, qr, l, mid);\n        if (ql > mid) return get(node << 1 | 1, ql, qr, mid + 1, r);\n        return get(node << 1, ql, qr, l, mid) +\n               get(node << 1 | 1, ql, qr, mid + 1, r);\n    }\n    // wrapper\n    void set(int i, T x) {\n        assert(i >= 0 && i < n);\n        set(1, i, x, 0, n - 1);\n    }\n\n    T get(int l, int r) {\n        // assert(l >= 0 && l <= r && r < n);\n        if (l > r) return T();\n        return get(1, l, r, 0, n - 1);\n    }\n};\nstruct node {\n    int sum = 0;\n    int mxl = 0, mxr = 0, mnl = 0, mnr = 0;\n\n    node(int x = 0)\n        : sum(x), mxl(max(0, x)), mxr(mxl), mnl(min(0, x)), mnr(mnl) {}\n    node(int a, int b, int c, int d, int e)\n        : sum(a), mxl(b), mxr(c), mnl(d), mnr(e) {}\n\n    node operator+(const node &b) const {\n        return {\n            sum + b.sum,\n            max(mxl, sum + b.mxl),\n            max(b.mxr, b.sum + mxr),\n            min(mnl, sum + b.mnl),\n            min(b.mnr, b.sum + mnr),\n        };\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> pos(n + 1);\n    SegTree<node> st(n);\n    for (int i = 0; i < n; i++) {\n        st.set(i, node(1));\n    }\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        pos[x].push_back(i);\n    }\n    vector<int> ans(n);\n    for (int i = 1; i <= n; i++) {\n        for (auto p : pos[i]) {\n            auto r = st.get(p + 1, n - 1);\n            auto l = st.get(0, p - 1);\n            ans[p] = max(ans[p], (r.mxl + l.mxr + 1) / 2);\n        }\n        for (auto p : pos[i])\n            st.set(p, node(-1));\n        for (auto p : pos[i]) {\n            auto r = st.get(p + 1, n - 1);\n            auto l = st.get(0, p - 1);\n            ans[p] = max(ans[p], (-r.mnl - l.mnr) / 2);\n        }\n    }\n    for (auto x : ans)\n        cout << x << ' ';\n    return 0;\n}"},{"id":"CF1562D2","title":"Codeforces Round #741 D2(1562D2) - Two Hundred Twenty One (hard version) é¢˜è§£","content":"ä¸€ç§æ¯”å®˜æ–¹é¢˜è§£ç®€å•ä¸€ç‚¹çš„åšæ³•å‰ç½®çŸ¥è¯†ç¡®ä¿ä½ å·²ç»çŸ¥é“D1çš„åšæ³•é¢˜è§£ç”±äºæˆ‘ä»¬å·²ç»çŸ¥é“äº†åŒºé—´é•¿åº¦ä¸ºå¶æ•°çš„æ—¶å€™æœ€å¤šåªç”¨å»æ‰ä¸¤ä¸ªæ•°è€Œé•¿åº¦ä¸ºå¥‡æ•°çš„æ—¶å€™è¦å»æ‰ä¸€ä¸ªæ•°ï¼Œæ‰€ä»¥å¯¹äºåŒºé—´é•¿åº¦ä¸ºå¶æ•°çš„è¯¢é—®ï¼Œæˆ‘ä»¬å¯ä»¥å»æ‰æœ€åä¸€ä¸ªæ•°ä»è€Œå°†å…¶è½¬åŒ–ä¸ºé•¿åº¦ä¸ºå¥‡æ•°çš„è¯¢é—®ï¼Œæ‰€ä»¥æˆ‘ä»¬åªè¦è€ƒè™‘å¦‚ä½•æ±‚é•¿åº¦ä¸ºå¥‡æ•°çš„è¯¢é—®å³å¯ã€‚é¦–å…ˆè¿˜æ˜¯åƒD1ä¸€æ ·æ±‚å‡ºå‰ç¼€å’Œï¼Œå°†çš„åŒºé—´å’Œè®°ä½œ ã€‚ä¸éš¾å¾—å‡ºå»æ‰ä¸€ä¸ªæ•°ä¹‹ååŒºé—´å’Œä¼šå˜æˆã€‚ æˆ‘ä»¬æƒ³ä½¿å…¶ä¸º0ï¼Œæ‰€ä»¥è¦æ‰¾åˆ°ä¸€ä¸ªä½¿å¾—ã€‚å°†ç­‰å¼åšå¦‚ä¸‹å˜æ¢ï¼šæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æç”¨æ‰€æœ‰çš„ çš„å€¼æ„å»ºåæŸ¥è¡¨ï¼ˆå³ç»™å‡ºçš„å€¼æŸ¥è¯¢ç¬¦åˆæ¡ä»¶çš„ï¼‰ã€‚è¿™æ ·å°±å¯ä»¥åšåˆ° å›ç­”è¯¢é—®äº†ï¼ˆlogæ¥è‡ªäºåœ¨åæŸ¥è¡¨ä¸­äºŒåˆ†ï¼‰ã€‚ä»£ç #include <bits/stdc++.h>\nusing namespace std;\n\nvoid test_case() {\n    int n, q;\n    string s;\n    cin >> n >> q >> s;\n    vector<int> ps(n + 1);\n    vector<vector<int>> pos(4 * n + 1);\n    for (int i = 0; i < n; i++) {\n        int x = (s[i] == '+' ? 1 : -1);\n        ps[i + 1] = ps[i] + (i % 2 ? -x : x);\n    }\n    const int OFFSET = 2 * n;\n    for (int i = 1; i <= n; i++) {\n        pos[ps[i] + ps[i - 1] + OFFSET].push_back(i);\n    }\n\n    auto solve = [&](int l, int r) {\n        int x = ps[l] + ps[r] + OFFSET;\n        auto it = lower_bound(pos[x].begin(), pos[x].end(), l + 1);\n        assert(it != end(pos[x]) && *it <= r);\n        return *it;\n    };\n    while (q--) {\n        int l, r;\n        cin >> l >> r;\n        l--;\n        if (ps[r] - ps[l] == 0) {\n            cout << \"0\\n\";\n        } else {\n            if ((r - l) % 2) cout << \"1\\n\";\n            else cout << \"2\\n\" << r-- << ' ';\n            cout << solve(l, r) << '\\n';\n        }\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt = 1;\n    cin >> tt;\n    while (tt--) {\n        test_case();\n    }\n}"},{"id":"CF1575H","title":"COMPFEST 13 - Finals H. Holiday Wall Ornaments é¢˜è§£","content":"ä»åŠ¨æ€è§„åˆ’çš„è§’åº¦è€ƒè™‘ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°çš„ä¸€ç§çŠ¶æ€æ˜¯å½“å‰ä½ç½®å‰çš„å­—ç¬¦çš„çŠ¶æ€ï¼Œä½†è¿™æ ·çš„çŠ¶æ€æ•°ä¸ºï¼Œæ˜¾ç„¶ä¸å¯è¡Œã€‚ä¸å¦¨è¿›ä¸€æ­¥æƒ³ï¼Œå½“å‰å­—ç¬¦ä¸²èƒ½å¯¹åé¢äº§ç”Ÿå½±å“çš„åªæœ‰ä¸å­—ç¬¦ä¸² çš„å‰ç¼€åŒ¹é…çš„éƒ¨åˆ†ï¼Œ æ‰€ä»¥çŠ¶æ€å¯ä»¥è¢«ä¼˜åŒ–ä¸ºå½“å‰å­—ç¬¦ä¸²çš„åç¼€ä¸çš„å‰ç¼€æœ€å¤§åŒ¹é…é•¿åº¦ã€‚æ•´ä¸ªdpçš„çŠ¶æ€ä¸ºå½“å‰ä½ç½® , ä½œä¸ºå­ä¸²å·²ç»å‡ºç°äº† æ¬¡ï¼Œ æœ€é•¿å…¬å…±å‰åç¼€çš„é•¿åº¦ä¸ºã€‚ä¸ºäº†å®ç°è½¬ç§»ï¼Œæˆ‘ä»¬è¿˜éœ€è¦é¢„å¤„ç†å¯¹äºçš„æ‰€æœ‰åç¼€ï¼Œåœ¨åé¢åŠ 0æˆ–è€…åŠ 1ä¹‹åå…¶åç¼€ä¸çš„å‰ç¼€çš„æœ€å¤§åŒ¹é…çŠ¶æ€ã€‚ä»£ç #include <bits/stdc++.h>\nusing namespace std;\nconst int N=500;\nshort dp[N+1][N+1][N+1], nxt[N+1][2];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    string a, b;\n    cin >> a >> b;\n    a=' '+a, b=' '+b;\n    for (int i=0; i<=m; i++) {\n        for (int x : {0, 1}) {\n            string s=b.substr(1, i)+char('0'+x);\n            for (int j=min(m, (int)size(s)); j>=1; j--) {\n                if (b.substr(1, j) == s.substr(size(s)-j)) {\n                    nxt[i][x]=j;\n                    break;\n                }\n            }\n        }\n    }\n    auto ckmin=[](auto& a, auto b) { if (b<a) a=b; };\n    for (int i=0; i<=n; i++)\n        for (int j=0; j<=n; j++)\n            for (int k=0; k<=m; k++) dp[i][j][k]=20000;\n    dp[0][0][0]=0;\n    for (int i=0; i<n; i++)\n        for (int j=0; j<=n; j++)\n            for (int k=0; k<=m; k++)\n                for (int x : {0, 1})\n                    ckmin(dp[i+1][j+(nxt[k][x]==m)][nxt[k][x]],\n                          dp[i][j][k]+(a[i+1]!='0'+x));\n    for (int i=0; i<=n-m+1; i++) {\n        auto ans=*min_element(dp[n][i], dp[n][i]+m+1);\n        cout << (ans==20000 ? -1 : ans) << \" \\n\"[i==n-m+1];\n    }\n}"},{"id":"CF1630C","title":"Codeforces Round #768 Div1C/Div2E Paint the Middleé¢˜è§£","content":"æœ‰æ®µæ—¶é—´æ²¡åšéš¾ä¸€ç‚¹çš„æ€ç»´é¢˜äº†æ€è·¯é¦–å…ˆä¸éš¾å‘ç°å¯¹äºæ¯ä¸ªæ•°æ¥è¯´ï¼Œå®ƒçš„ç¬¬ä¸€æ¬¡å’Œæœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®æ˜¯æœ€é‡è¦çš„ï¼Œå› ä¸ºä½¿ç”¨å…¶ä»–ä½ç½®çš„æ“ä½œéƒ½å¯ä»¥ä½¿ç”¨ä¸¤ç«¯çš„ä½ç½®å®Œæˆè€Œä¸”ä¸­é—´çš„ä½ç½®çš„cå€¼å¯ä»¥è¢«ä¸¤ç«¯å˜æˆ1ã€‚æˆ‘ä»¬å°†æ¯ä¸ªæ•°çš„ç¬¬ä¸€æ¬¡å’Œæœ€åä¸€æ¬¡ä½ç½®è®°ä½œï¼Œäºæ˜¯æˆ‘ä»¬å°±å¯ä»¥å°†æ¯ä¸ªæ•°è¡¨ç¤ºæˆä¸€ä¸ªçº¿æ®µ ã€‚å¯¹äºä¸€ä¸ªçº¿æ®µçš„é›†åˆï¼Œå¦‚æœè¿™äº›çº¿æ®µçš„å¹¶é›†ç­‰äºçº¿æ®µï¼Œæˆ‘ä»¬ç§°æ˜¯è¿é€šçš„ã€‚ å¯¹äºæ‰€æœ‰çº¿æ®µæˆ‘ä»¬å¯ä»¥å°†å…¶åˆ’åˆ†ä¸ºæå¤§è¿é€šå­é›†å¯¹äºæ¯ä¸ªå­é›†å…¶äº’ä¸å½±å“æ‰€ä»¥æœ€ç»ˆçš„ç­”æ¡ˆå°±æ˜¯æ¯ä¸ªå­é›†çš„ç­”æ¡ˆä¹‹å’Œã€‚å¯¹äºæ¯ä¸ªæå¤§å­é›†ï¼Œæˆ‘ä»¬å¯èƒ½æ‰¾åˆ°å…¶æœ€å°å­é›†ä½¿å¾—ä¸­çš„çº¿æ®µçš„å¹¶ç­‰äº ä¸­çº¿æ®µçš„å¹¶ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥å°†å°½é‡å¤šçš„çº¿æ®µçš„ç«¯ç‚¹çš„cå€¼å˜æˆ1.å¯¹äº ä¸­çš„çº¿æ®µæˆ‘ä»¬å¯ä»¥è¯æ˜æœ€å¤šå¯ä»¥å°† ä¸ªä½ç½®çš„cå€¼å˜æˆ1ã€‚ä»£ç #include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> l(n, n), r(n, -1);\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        x--;\n        l[x] = min(l[x], i);\n        r[x] = max(r[x], i);\n    }\n    vector<pair<int, int>> b, c;\n    for (int i = 0; i < n; i++) {\n        if (l[i] < r[i]) b.emplace_back(l[i], r[i]);\n    }\n    sort(begin(b), end(b));\n    for (auto [l, r] : b) {\n        // å»é™¤åœ¨åŒ…å«åœ¨å…¶ä»–çº¿æ®µä¹‹å†…çš„çº¿æ®µ\n        if (c.empty() || r > c.back().second) c.emplace_back(l, r);\n    }\n    int ans = 0, last = -1;\n    int m = size(c);\n    for (int i = 0; i < m; i++) {\n        if (c[i].first > last) { // æ–°çš„å­é›†çš„ç¬¬ä¸€ä¸ªçº¿æ®µï¼Œç«¯ç‚¹çš„cå€¼æ— æ³•å˜æˆ1\n            ans += c[i].second - c[i].first - 1;\n            last = c[i].second;\n        } else if (i == m - 1 || c[i + 1].first > last) { // å­é›†ä¸­çš„å…¶ä»–çº¿æ®µï¼Œå·¦ç«¯ç‚¹cå€¼ä¼šå˜æˆ1ï¼Œä¼šåœ¨ä¹‹å‰è¢«è®°å…¥ç­”æ¡ˆ\n            ans += c[i].second - last - 1;\n            last = c[i].second;\n        }\n    }\n    cout << ans << endl;\n}"},{"id":"CF1646","title":"Codeforces Round #774 (Div. 2) A-E é¢˜è§£","content":"Aè¾“å‡ºå³å¯ã€‚ä»£ç Bçº¢è‰²çš„å’Œè¦å°½é‡å¤§è€Œä¸”ä¸ªæ•°è¦å°½é‡å°ï¼Œæ‰€ä»¥æ’åºä¹‹åçº¢è‰²çš„æ˜¯ä¸€æ®µåç¼€ã€è“è‰²æ˜¯ä¸€æ®µå‰ç¼€è€Œä¸”é•¿åº¦æ¯”çº¢è‰²å¤§1ã€‚æšä¸¾çº¢è‰²çš„ä¸ªæ•°å³å¯ã€‚ä»£ç Cç”±äºï¼Œæ‰€ä»¥æœ€å¤šæœ‰15ä¸ªé˜¶ä¹˜æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æšä¸¾æ¯ä¸ªé˜¶ä¹˜æ˜¯å¦è¢«ç”¨ï¼Œç„¶åå‰©ä¸‹çš„æ•°è®¡ç®—å…¶äºŒè¿›åˆ¶è¡¨ç¤ºä¸­1çš„ä¸ªæ•°ã€‚è®°å¾—næ˜¯ï¼Œæ‰€ä»¥è¦ç”¨ã€‚ä»£ç Dé™¤äº†n=2çš„æƒ…å†µï¼Œä¸¤ä¸ªgoodèŠ‚ç‚¹å°±ä¸èƒ½ç›¸é‚»çš„ï¼Œæ‰€ä»¥é—®é¢˜å°±è½¬åŒ–æˆäº†æ ‘ä¸Šæœ€å¤§ç‹¬ç«‹é›†é—®é¢˜ï¼Œç”¨æ ‘ä¸Šdpå¯ä»¥è½»æ¾è§£å†³ï¼š ä»£è¡¨ çš„å­æ ‘ä¸­æœ€å¤§ç‹¬ç«‹é›†ï¼Œå…¶ä¸­chooseä¸º0æˆ–1ä»£è¡¨uæ˜¯å¦åœ¨ç‹¬ç«‹é›†å½“ä¸­ï¼Œè½¬ç§»ä¸º:"},{"id":"CF1713E","title":"Codeforces Round #812 E - Cross Swappingé¢˜è§£","content":"é¦–å…ˆå‘ç°æ— è®ºå¦‚ä½•æ“ä½œï¼Œåªæœ‰å…³äºå¯¹è§’çº¿å¯¹ç§°çš„ä¸¤ä¸ªä½ç½®ï¼ˆï¼‰ä¼šè¢«äº¤æ¢ï¼Œè€Œä¸”åªæœ‰å’Œçš„æ“ä½œä¼šå½±å“è¿™ä¸¤ä¸ªä½ç½®çš„äº¤æ¢ã€‚\næˆ‘ä»¬ç”¨æ¥è¡¨ç¤ºæ“ä½œæ˜¯å¦è¢«æ‰§è¡Œï¼Œå¦‚æœï¼Œæˆ‘ä»¬ä¸å¸Œæœ›ä»–ä»¬è¢«äº¤æ¢æ‰€ä»¥æˆ‘ä»¬å¸Œæœ›ï¼Œåä¹‹å¦‚æœï¼Œæˆ‘ä»¬å¸Œæœ›ä»–ä»¬äº¤æ¢æ‰€ä»¥æˆ‘ä»¬å¸Œæœ›ã€‚ï¼ˆä»£è¡¨æŒ‰ä½å¼‚æˆ–ï¼‰å¯¹äºå­—å…¸åºçš„é—®é¢˜ï¼Œå¾€å¾€é‡‡ç”¨ä»å‰å¾€åè´ªå¿ƒçš„ç­–ç•¥ã€‚å¯¹äºå½“å‰çš„æˆ‘ä»¬è¦çœ‹ä¹‹å‰çš„é™åˆ¶æ˜¯å¦å…è®¸æˆ‘ä»¬å¸Œæœ›çš„å€¼ã€‚é‚£ä¹ˆå¦‚ä½•åˆ¤æ–­å‘¢ï¼Ÿæˆ‘ä»¬ç”¨ä¸€ç§è®©å¹¶æŸ¥é›†çš„è¾¹å¸¦æƒçš„æŠ€å·§ï¼Œå³è¾¹çš„æƒå€¼ä»£è¡¨ï¼Œé‚£ä¹ˆä¸€ä¸ªåˆ†é‡ä¸­ä»»æ„ä¸¤ç‚¹çš„å¼‚æˆ–å€¼å³ä¸ºè·¯å¾„ä¸Šè¾¹çš„å¼‚æˆ–å€¼ã€‚ä¸ºäº†æ–¹ä¾¿å®ç°æˆ‘ä»¬ç”¨èŠ‚ç‚¹ä»£è¡¨åˆ°å…¶çˆ¶èŠ‚ç‚¹çš„è¾¹ã€‚åœ¨å’Œæ—¶è¦æ›´æ–°è¾¹æƒï¼ˆè§ä»£ç ï¼‰ã€‚æ¡ä»¶å°±ç›¸å½“äºç»™å’Œä¸­é—´è¿ä¸€æ¡æƒå€¼ä¸ºçš„è¾¹ï¼Œå¯¹åº”å¹¶æŸ¥é›†çš„æ“ä½œï¼Œå¦‚æœåŠ è¾¹ä¹‹å‰ä¸¤ä¸ªç‚¹ä¸åœ¨åŒä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œé‚£ä¹ˆæ¡ä»¶ä¸€å®šæ˜¯å¯ä»¥æ»¡è¶³çš„ã€‚å¦‚æœåœ¨åŒä¸€ä¸ªåˆ†é‡ä¸­ï¼Œé‚£ä¹ˆè¯´æ˜å·²ç»æ˜¯ç¡®å®šçš„ï¼Œå¦‚æœè¯´æ˜å½“å‰æ¡ä»¶ä¸èƒ½æ»¡è¶³ï¼Œæˆ‘ä»¬å°±è·³è¿‡å®ƒã€‚å…¶ä»–å®ç°ç»†èŠ‚è§ä»£ç ï¼š#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UF {\n    vector<int> fa, sz, parity;\n    UF(int n) : fa(n), sz(n, 1), parity(n) { iota(fa.begin(), fa.end(), 0); }\n\n    array<int, 2> find(int x) {\n        if (fa[x] == x) {\n            return {x, 0};\n        }\n        auto [f, z] = find(fa[x]);\n        fa[x] = f;\n        parity[x] ^= z;\n        return {fa[x], parity[x]};\n    }\n\n    bool same(int x, int y) { return find(x) == find(y); }\n\n    bool join(int x, int y, int p) {\n        auto [fx, px] = find(x);\n        auto [fy, py] = find(y);\n        if (fx == fy) \n            return (px ^ py ^ p) == 0;\n        if (sz[fx] > sz[fy]) swap(fx, fy);\n        fa[fx] = fy;\n        parity[fx] = px ^ py ^ p;\n        sz[y] += sz[x];\n        return true;\n    }\n};\n\nvoid test_case() {\n    int n;\n    cin >> n;\n    vector a(n, vector(n, 0));\n    for (auto& v : a) {\n        for (auto& x : v) {\n            cin >> x;\n        }\n    }\n    UF uf(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (a[i][j] == a[j][i]) {\n                continue;\n            }\n            if (uf.join(i, j, a[i][j] > a[j][i]) ^ (a[i][j] < a[j][i])) {\n                swap(a[i][j], a[j][i]);\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << a[i][j] << \" \\n\"[j == n - 1];\n        }\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt = 1;\n    cin >> tt;\n    while (tt--) {\n        test_case();\n    }\n}"},{"id":"CF1729G","title":"Codeforces Round #820 G. Cut Substrings é¢˜è§£","content":"è¿™æ˜¯ä¸€é“å¾ˆç›´æ¥çš„DPé¢˜ä½†éš¾ç‚¹åœ¨äºçŸ¥é“ä»å“ªè½¬ç§»ã€‚é¦–å…ˆæˆ‘ä»¬æ‰¾åˆ°  åœ¨  ä¸­çš„æ‰€æœ‰å‡ºç°ä½ç½®å¹¶è®°ä¸º ã€‚å®šä¹‰  ä¸ºæ¶ˆé™¤å‰  æ¬¡å‡ºç°æ‰€éœ€è¦çš„æœ€å°æ¬¡æ•°ï¼Œä¸”ç¬¬  ä¸ªå‡ºç°æ˜¯å®Œæ•´æ¶ˆé™¤çš„ï¼ˆè¿™æ ·å¯ä»¥é¿å…æ•°é‡ï¼‰ï¼Œå®šä¹‰  ä¸ºæ‰€å¯¹åº”çš„ä¸åŒæ–¹æ³•çš„æ¬¡æ•°ã€‚å½“è€ƒè™‘ç¬¬  ä¸ªå‡ºç°æ—¶ï¼Œé¦–å…ˆæ‰¾åˆ°  å·¦è¾¹ç¬¬ä¸€ä¸ªä¸ä¸  é‡å çš„å‡ºç° ï¼Œä¹Ÿå°±æ˜¯è¯´  æ˜¯æœ€å¤§çš„ä½¿  æˆç«‹çš„æ•°ï¼Œæˆ‘ä»¬ä¸éœ€è¦è€ƒè™‘  ä¸  ä¹‹é—´çš„ä½ç½®è½¬ç§»ï¼Œå› ä¸º  åˆ°  ä¹‹é—´çš„æ“ä½œä¼šä½¿  ä½ç½®çš„å‡ºç°è¢«éƒ¨åˆ†æ¶ˆé™¤ã€‚ç„¶åæˆ‘ä»¬å†æ‰¾åˆ°æœ€å·¦è¾¹ä¸  é‡å çš„å‡ºç° ï¼Œä¹Ÿå°±æ˜¯è¯´  æ˜¯æœ€å°æ˜¯ä½¿  æˆç«‹çš„æ•°ã€‚  å·¦è¾¹çš„å‡ºç°å°±ä¸èƒ½è€ƒè™‘äº†å› ä¸º  å‡ºç°å°±æ— æ³•è¢«æ¶ˆé™¤ï¼Œæ‰€ä»¥æˆ‘ä»¬è€ƒè™‘ä»  åˆ°  ä½ç½®çš„è½¬ç§»ï¼Œæœ€ç»ˆçš„ç­”æ¡ˆå°±æ˜¯æ‰€æœ‰æ»¡è¶³  ä¸”  ä¸ºæœ€å°å€¼çš„  çš„  çš„å’Œï¼Œå…¶ä¸­  ä¸ºæœ€åä¸€ä¸ªå‡ºç°çš„ä½ç½®ï¼Œå…·ä½“å®ç°è¯¦è§ä»£ç ï¼š#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    ModInt(long long v = 0) : val(v % MOD) { if (val < 0) val += MOD; };\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const {\n        auto a = val, m = MOD, u = 0, v = 1;\n        while (a != 0) { auto t = m / a; m -= t * a; swap(a, m); u -= t * v; swap(u, v); }\n        assert(m == 1);\n        return u;\n    }\n    ModInt pow(long long n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    friend ModInt operator+ (ModInt lhs, const ModInt& rhs) { return lhs += rhs; }\n    friend ModInt operator- (ModInt lhs, const ModInt& rhs) { return lhs -= rhs; }\n    friend ModInt operator* (ModInt lhs, const ModInt& rhs) { return lhs *= rhs; }\n    friend ModInt operator/ (ModInt lhs, const ModInt& rhs) { return lhs /= rhs; }\n    ModInt& operator+=(const ModInt& x) { if ((val += x.val) >= MOD) val -= MOD; return *this; }\n    ModInt& operator-=(const ModInt& x) { if ((val -= x.val) < 0) val += MOD; return *this; }\n    ModInt& operator*=(const ModInt& x) { val = int64_t(val) * x.val % MOD; return *this; }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<1'000'000'007>;\n\nvoid test_case() {\n    string s, t;\n    cin >> s >> t;\n    int n = s.size(), m = t.size();\n\n    vector<int> pos;\n    for (int i = 0; i + m <= n; i++) {\n        if (s.substr(i, m) == t) {\n            pos.push_back(i);\n        }\n    }\n    if (pos.empty()) {\n        cout << \"0 1\\n\";\n        return;\n    }\n\n    int sz = pos.size();\n    vector<int> f(sz, n);\n    vector<mint> g(sz);\n    for (int i = 0; i < sz; i++) {\n        int j = i - 1;\n        while (j >= 0 && pos[i] <= pos[j] + m - 1) {\n            j--;\n        }\n        if (j == -1) {\n            f[i] = 1;\n            g[i] = 1;\n        } else {\n            for (int k = j; k >= 0 && pos[j] <= pos[k] + m - 1; k--) {\n                if (f[k] + 1 < f[i]) {\n                    f[i] = f[k] + 1;\n                    g[i] = g[k];\n                } else if (f[k] + 1 == f[i]) {\n                    g[i] += g[k];\n                }\n            }\n        }\n    }\n    mint ans = 0;\n    int mn = f.back();\n    for (int i = sz - 1; i >= 0 && pos.back() <= pos[i] + m - 1; i--) {\n        if (f[i] < mn) {\n            mn = f[i];\n            ans = g[i];\n        } else if (f[i] == mn) {\n            ans += g[i];\n        }\n    }\n    cout << mn << ' ' << ans << '\\n';\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt = 1;\n    cin >> tt;\n    while (tt--) {\n        test_case();\n    }\n}"},{"id":"CF205C","title":"Codeforces 205D - Little Elephant and Interval é¢˜è§£","content":"é¢˜è§£è¿™ç§é¢˜å¸¸è§å¥—è·¯å°±æ˜¯å†™ä¸€ä¸ªæ±‚1åˆ°xç­”æ¡ˆçš„å‡½æ•°ç„¶åæœ€ç»ˆç­”æ¡ˆå°±æ˜¯ã€‚ä¸€ç§å¾ˆå¦™çš„æ–¹æ³•æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ä»»æ„æ•°å­—ä¹‹ååŠ ä¸€ä¸ªç¬¬ä¸€ä½çš„æ•°å­—ä»è€Œå¾—åˆ°é¢˜ç›®è¦æ±‚çš„æ•°å­—ã€‚æ‰€ä»¥å¦‚æœxå°äº10é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯xï¼Œå¦åˆ™ç­”æ¡ˆå°±æ˜¯å»æ‰æœ€åä¸€ä½çš„x+9ã€‚å¦‚æœæœ€åä¸€ä½å°äºç¬¬ä¸€ä½æˆ‘ä»¬è¿˜è¦æŠŠç­”æ¡ˆå‡1ã€‚Code#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll cal(ll x){\n\tif(x<10) return x;\n\tstring st=to_string(x);\n\tll ans=9;\n\tif(st[0]>st.back()) ans--;\n\tans+=x/10;\n\treturn ans;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tll l,r;\n\tcin>>l>>r;\n\tcout<<cal(r)-cal(l-1);\n    return 0;\n}"},{"id":"CF208B","title":"Codeforces 208B - Solitaire é¢˜è§£","content":"é¢˜è§£æˆ‘ä»¬å¯ä»¥ç”¨è®°å¿†åŒ–dfsï¼ŒdpçŠ¶æ€æ˜¯ä»¥ä¸‹4ä¸ªæ•°ï¼šå‰©ä½™çš„å †æ•°ã€æœ€å³è¾¹ä¸‰å †é‡Œé¡¶ç«¯çš„ç‰Œã€‚å¦‚æœæˆ‘ä»¬æœ€åèƒ½å‰©ä¸‹ä¸€å †çš„è¯ç­”æ¡ˆå°±æ˜¯yesã€‚è¿™é¢˜ä¹Ÿå¯ä»¥ç”¨bfsï¼ŒçŠ¶æ€æ˜¯dpæ˜¯ä¸€æ ·çš„ï¼Œå¯èƒ½æ›´å¥½ç†è§£ã€‚Code#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=60;\nstring s[N];\nint dp[N][N][N][N];\nbool dfs(int n,int i,int j,int k){\n\tif(n==0) return true;\n\tint& d=dp[n][i][j][k];\n\tif(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false;\n\tif(s[i][0]==s[j][0]||s[i][1]==s[j][1]){\n\t\tif(dfs(n-1,i,k,n-3)){\n\t\t\treturn d=1;\n\t\t}\n\t}\n\tif(n>=3&&(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){\n\t\tif(dfs(n-1,j,k,i)){\n\t\t\treturn d=1;\n\t\t}\n\t}\n\td=-1;\n\treturn false;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n\tcin>>n;\n\tforn(i,n) cin>>s[i];\n\tcout<<(dfs(n-1,n-1,n-2,n-3)?\"YES\":\"NO\");\n    return 0;\n}"},{"id":"CF220B","title":"Little Elephant and Array - CodeForces220B é¢˜è§£","content":"æ®è¯´è«é˜Ÿæ›´ç®€å•ï¼Œç„¶è€Œä¸ä¼šå•Šé¢˜ç›®é“¾æ¥è€ƒè™‘ç»´æŠ¤ä¸€ä¸ªæ•°ç»„ ï¼Œä½¿å¾—  çš„å’Œä¸ºè¯¢é—®  çš„ç­”æ¡ˆã€‚ç”¨çº¿æ®µæ ‘æˆ–æ ‘çŠ¶æ•°ç»„éƒ½è¡Œï¼ˆæ˜¾ç„¶æ ‘çŠ¶æ•°ç»„æ¯”è¾ƒå¥½å†™ï¼‰ã€‚ä»å·¦è¾¹å¼€å§‹éå†æ•°ç»„ï¼Œå½“ä¸‹æ ‡ä¸º  æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥å¤„ç†å®Œæ‰€æœ‰  çš„è¯¢é—®ã€‚ä¸‹é¢æˆ‘ä»¬ç”¨ä¸€ä¸ªæœ€ç®€å•çš„ä¾‹å­æ¥è¯´æ˜è¿™ä¸ªæ€è·¯ï¼ˆä¸‹æ ‡ä»1å¼€å§‹ï¼‰:"},{"id":"CF56E","title":"é¢˜è§£ Codeforces 56E - Domino Principle","content":"å•è°ƒæ ˆå¥½é¢˜ï¼Œéå¸¸ç‹¬ç‰¹çš„è§†è§’ã€‚é¢˜è§£æ ˆä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ä»£è¡¨çš„æ˜¯ä¸€ç»„è¿ç»­çš„å¤šç±³è¯ºï¼Œä½¿å¾—å¦‚æœæˆ‘ä»¬å¦‚æœæ¨å€’xå¤„çš„å¤šç±³è¯ºï¼Œä»ç¬¬iä¸ªå¼€å§‹ä¸€ç›´åˆ°ä¸‹ä¸€ç»„çš„å¤šç±³è¯ºéƒ½ä¼šè¢«æ¨æ‰ã€‚æ‰€ä»¥æˆ‘ä»¬å¤„ç†æ–°çš„å¤šç±³è¯ºçš„æ—¶å€™ï¼Œè¦å…ˆæŠŠå½“å‰å¤šç±³è¯ºå¤Ÿå¾—åˆ°çš„å¤šç±³è¯ºç»„å¼¹å‡ºï¼Œæœ€åæ ˆé¡¶çš„å…ƒç´ å°±æ˜¯æœ€è¿‘çš„å¤Ÿä¸ç€çš„å¤šç±³è¯ºï¼Œä¹Ÿå°±æ˜¯å½“å‰å¤šç±³è¯ºçš„ç­”æ¡ˆã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\nusing pii= pair<int, int>;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> x(n),h(n),id(n);\n    iota(all(id),0);\n    forn(i,n){\n        cin>>x[i]>>h[i];\n    }\n    sort(all(id),[&](int a,int b){return x[a]<x[b];});\n    vector<int> ans(n);\n    stack<pii> stk;\n    stk.push({1e9,n});\n    for(int i=n-1;i>=0;i--){\n        int ii=id[i];\n        while(!stk.empty()&&x[ii]+h[ii]>stk.top().F) stk.pop();\n        ans[ii]=(stk.empty()?1:stk.top().S-i);\n        stk.push({x[ii],i});\n    }\n    for(auto it:ans) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF5C","title":"CodeForces 5C - Longest Regular Bracket Sequence é¢˜è§£","content":"æ³¨ï¼šä¸‹æ–‡çš„regular bracket sequence ç®€å†™ä¸ºRBSé¦–å…ˆå¯¹äºæ¯ä¸ªå³æ‹¬å·ï¼Œæˆ‘ä»¬æ‰¾åˆ°ä¸å…¶é…å¯¹çš„å·¦æ‹¬å·ï¼ˆä¹Ÿå°±æ˜¯è¯¥å³æ‹¬å·å¾€å·¦æœ€çŸ­çš„RBSï¼‰çš„ä½ç½®ï¼ˆå¦‚æœæ²¡æœ‰é…å¯¹çš„å°±æ˜¯-1ï¼‰ï¼Œæ¯”å¦‚æ ·ä¾‹å¯¹åº”çš„ä½ç½®å°±æ˜¯ä¸‹æ ‡012345678910111213æ‹¬å·)((())))(()())-1321-19118æ•°ç»„å¯ä»¥å¾ˆå®¹æ˜“çš„ç”¨ä¸€ä¸ªæ ˆæ±‚å¾—ã€‚é‚£ä¹ˆå¦‚ä½•æ±‚æœ€é•¿çš„RBSå‘¢ï¼Ÿå¦‚æœä¸¤ä¸ªRBSç›¸é‚»çš„è¯æˆ‘ä»¬å¯ä»¥å°†ä»–ä»¬åˆå¹¶ä¸ºä¸€ä¸ªæ›´é•¿çš„RBSï¼Œäºæ˜¯æˆ‘ä»¬å¯ä»¥å†éå†ä¸€éæ•°ç»„å¹¶å°è¯•æ‰©å±•RBSçš„é•¿åº¦ï¼Œæˆ‘ä»¬ä¾¿å¾—åˆ°äº†ä»¥ç»“å°¾çš„æœ€é•¿çš„RBSï¼Œç›¸åº”åœ°æ›´æ–°ç­”æ¡ˆå³å¯ã€‚æ›´æ–°å®Œä¹‹åçš„æ•°ç»„å¦‚ä¸‹ï¼š(å¥½å§å…¶å®æ²¡ä»€ä¹ˆå˜åŒ–)ä¸‹æ ‡012345678910111213æ‹¬å·)((())))(()())-1321-1998å®Œæ•´ä»£ç ï¼š#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin >> s;\n    int n = (int)s.size();\n    vector<int> l(n, -1);\n    vector<int> stk;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '(') stk.push_back(i); // å¦‚æœæ˜¯å·¦æ‹¬å·å°±å…¥æ ˆ\n        else if (!stk.empty()) { // å¦åˆ™å°±æ˜¯å³æ‹¬å·ï¼Œå¦‚æœæ ˆéç©ºå°±è¯´æ˜æœ‰å¯¹åº”çš„å·¦æ‹¬å·\n            l[i] = stk.back();\n            stk.pop_back();\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        //å¦‚æœå½“å‰RBSå·¦è¾¹ä¹Ÿæœ‰ä¸€ä¸ªRBSå°±æ›´æ–°å·¦ç«¯ç‚¹\n        if (l[i] > 0 && l[l[i] - 1] != -1) l[i] = l[l[i] - 1];\n    }\n    int ans = 0, cnt = 1;\n    for (int i = 0; i < n; i++) {\n        if (l[i] == -1) continue;\n        int len = i - l[i] + 1;\n        if (len > ans) {\n            ans = len;\n            cnt = 1;\n        } else if (len == ans)\n            cnt++;\n    }\n    cout << ans << ' ' << cnt << '\\n';\n}"},{"id":"CF650B","title":"é¢˜è§£ Codeforces 650B/651D Image Preview","content":"æœ‰æ—¶å€™åŒæŒ‡é’ˆä¼šå¾ˆç®€å•é¢˜è§£ä¸éš¾çœ‹å‡ºæ‰€æœ‰æ‰“å¼€çš„å›¾ç‰‡æ˜¯æ‰€æœ‰å›¾ç‰‡çš„ä¸€ä¸ªå­æ®µã€‚æˆ‘ä»¬å¯ä»¥æšä¸¾æ‰€æœ‰å·¦ç«¯ç‚¹ç„¶åç”¨åŒæŒ‡é’ˆæ‰¾åˆ°æœ€å³çš„ç«¯ç‚¹ã€‚Code#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,a,b,T;\n    string s;\n    rd( n,a,b,T,s);\n    int ans=0;\n    vector<ll> t(2*n);\n    forn(i,n){\n        t[i]=t[i+n]=(s[i]=='w'?b+1:1);\n    }\n    for(int i=1;i<2*n;i++) t[i]+=t[i-1];\n    int r=n;\n    auto f=[&](int l,int r){\n        ll res=t[r]-t[l-1];\n        ll di=r-l+min(r-n,n-l);\n        return res+di*a;\n    };\n    for(int l=1;l<=n;l++){\n        while(r+1<l+n&&f(l,r+1)<=T) r++;\n        if(f(l,r)<=T) ans=max(ans,r-l+1);\n    }\n    cout<<ans;\n    return 0;\n}"},{"id":"CF743D","title":"Codeforces 743D - Chloe and pleasant prizes é¢˜è§£","content":"Good DFS problem.é¢˜è§£æˆ‘ä»¬éœ€è¦ç”¨DFSè®¡ç®—â€”â€”çš„å­æ ‘é‡Œæ‰€æœ‰æ•°çš„å’Œï¼Œä»¥åŠ å’Œ â€”â€”vçš„å­æ ‘é‡Œæ‰€æœ‰çš„é‡Œçš„æœ€å¤§å’Œæ¬¡å¤§å€¼(ä¸åŒ…æ‹¬). è®¡ç®—å®Œä¹‹åæ›´æ–°ç­”æ¡ˆã€‚å…·ä½“å®ç°å¯ä»¥çœ‹ä»£ç ï¼ŒæŒºå¥½ç†è§£çš„ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e18+1;\ntypedef pair<int, int> pii;\n\nconst int N=2e5+5;\nvector<int> G[N];\nll a[N],sum[N],mx[N];\n\nll ans=-INF;\nvoid dfs1(int v,int p){\n    sum[v]=a[v];\n    mx[v]=-INF;\n    ll m1=-INF,m2=-INF;\n    for(auto it:G[v]){\n        if(it==p) continue;\n        dfs1(it,v);\n        sum[v]+=sum[it];\n        mx[v]=max(mx[v],mx[it]);\n        ll val=mx[it];\n        if(val>m1) swap(m1,val);\n        if(val>m2) swap(m2,val);\n    }\n    if(m2> -INF) ans=max(ans,m1+m2);\n    mx[v]=max(mx[v],sum[v]);\n    return;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tint n;\n    cin>>n;\n    for1(i,n){\n        cin>>a[i];\n    }\n    forn(i,n-1){\n        int u,v;\n        cin>>u>>v;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    dfs1(1,1);\n    if(ans==-INF) cout<<\"Impossible\";\n    else cout<<ans;\n    return 0;\n}"},{"id":"CF762D","title":"Codeforces 762D - Maximum Path é¢˜è§£","content":"é¢˜è§£è¿™é¢˜å¦‚æœä¸èƒ½å¾€å·¦èµ°çš„è¯å°±æ˜¯ä¸€ä¸ªæ ‡å‡†çš„dpé¢˜ã€‚æ‰€ä»¥æˆ‘ä»¬è¦å¤„ç†ä¸€ä¸‹é¢å¤–çš„æƒ…å†µã€‚ä½†æ˜¯ç»è§‚å¯Ÿæˆ‘ä»¬å¯ä»¥å‘ç°æˆ‘ä»¬ä¸éœ€è¦å¾€å·¦èµ°è¶…è¿‡ä¸¤æ ¼ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„è¯æ˜ï¼šæ‰€ä»¥æˆ‘ä»¬åªè¦é¢å¤–è€ƒè™‘ä¸¤ç§çŠ¶æ€è½¬ç§»å°±è¡Œäº†ï¼Œæ‰€æœ‰çš„çŠ¶æ€è½¬ç§»å¦‚ä¸‹ï¼šCode#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\nvoid inline cmax(ll& a,ll b){\n    if(b>a) a=b;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<vector<ll>> a(n+2,vector<ll>(3)),dp(n+2,vector<ll>(3,-1e18));\n    forn(j,3) for1(i,n) cin>>a[i][j];\n    dp[0][0]=0;\n    for(int i=1;i<=n;i++){\n        cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]);\n        cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]);\n        cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]);\n        cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]);\n        cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]);\n    }\n    cout<<dp[n][2];\n    return 0;\n}"},{"id":"CF813E","title":"CodeForces 813E - Army Creationé¢˜è§£","content":"å¾ˆç¥å¥‡çš„æŠ€å·§é¢˜è§£æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªè¾…åŠ©æ•°ç»„å…¶ä¸­æ˜¯åç¬¬ä¸ªçš„ä¸‹æ ‡ï¼Œæˆ–è€…æ˜¯å¦‚æœåé¢æ²¡æœ‰ä¸ªäº†ã€‚æ¯”å¦‚è¯´ï¼Œæ ·ä¾‹çš„è¾…åŠ©æ•°ç»„æ˜¯.è€ƒè™‘è¯¢é—®ï¼Œå¯¹äºï¼Œå¦‚æœï¼Œè¯´æ˜åå‡ºç°äº†å¤šäºæ¬¡ï¼Œæ‰€ä»¥ä¸åº”è¯¥åœ¨å†›é˜Ÿé‡Œã€‚ æ‰€ä»¥ç­”æ¡ˆæ˜¯ã€‚æ‰¾åŒºé—´é‡Œå°äºçš„æ•°çš„ä¸ªæ•°å¯ä»¥ç”¨ä¸»å¸­æ ‘æˆ–è€…waveletæ ‘è§£å†³ã€‚Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct PST {\n    int n, tot=0;\n    vector<int> lc, rc, sum, roots; // left child, right child\n    PST(int n_) : n(n_), lc(n<<5), rc(n<<5), sum(n<<5), roots(1) {\n        build(0, n-1, roots[0]);\n    }\n    void pushup(int rt) {\n        sum[rt] = sum[lc[rt]] + sum[rc[rt]];\n    }\n    void build(int l, int r, int& rt) {\n        rt = ++tot;\n        if (l == r) return;\n        int mid = (l + r) >> 1;\n        build(l, mid, lc[rt]);\n        build(mid + 1, r, rc[rt]);\n        pushup(rt);\n    }\n    void update(int pos, int val, int l, int r, int old, int& rt) {\n        rt = ++tot;\n        lc[rt] = lc[old];\n        rc[rt] = rc[old];\n        if (l == r) {\n            sum[rt] = sum[old] + val;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        if (pos <= mid) update(pos, val, l, mid, lc[old], lc[rt]);\n        else update(pos, val, mid + 1, r, rc[old], rc[rt]);\n        pushup(rt);\n    }\n    int update(int pos, int val) { // return the root of the new version\n        int new_root;\n        update(pos, val, 0, n-1, roots.back(), new_root);\n        roots.push_back(new_root);\n        return new_root;\n    }\n    int query(int u, int v, int l, int r, int k) {\n        if (l==r) return sum[v]-sum[u];\n        int mid=(l+r)/2, x=sum[lc[v]]-sum[lc[u]];\n        if (mid<k) return x+query(rc[u], rc[v], mid+1, r, k);\n        return query(lc[u], lc[v], l, mid, k);\n    }\n    int query(int u, int v, int k) {\n        return query(u, v, 0, n-1, k);\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin>>n>>k;\n    constexpr int M=1e5;\n    vector<vector<int>> pos(M);\n    vector<int> a(n, n);\n    for (int i=0; i<n; i++) {\n        int x;\n        cin>>x;\n        pos[x].push_back(i);\n        if (pos[x].size()>k) {\n            a[*(pos[x].rbegin()+k)]=i;\n        }\n    }\n    int last=0;\n    vector<int> roots(n+1);\n    roots[0]=1;\n    PST tr(n+1);\n    for (int i=0; i<n; i++) {\n        roots[i+1]=tr.update(a[i], 1);\n    }\n    int q;\n    cin>>q;\n    while (q--) {\n        int x, y;\n        cin>>x>>y;\n        int l=(x+last)%n, r=(y+last)%n;\n        if (l>r) swap(l, r);\n        last=(r-l+1)-tr.query(roots[l], roots[r+1], r);\n        cout<<last<<'\\n';\n    }\n    return 0;\n}"},{"id":"COMPFEST14","title":"COMPFEST 14éƒ¨åˆ†é¢˜è§£ï¼ˆABCEFGHKLMï¼‰","content":"A. Accumulation of Dominoesç­¾åˆ°é¢˜ï¼Œå¦‚æœ  è¾“å‡º ï¼Œå¦åˆ™è¾“å‡º ã€‚B. Basketball Togetherè´ªå¿ƒï¼Œæ’åºåç”¨å¤§çš„æ•°é…å°çš„æ•°ã€‚C. Circular Mirrorç›´å¾„æ‰€å¯¹åœ†å‘¨è§’ä¸º90åº¦ï¼Œæ‰€ä»¥å½“ç›´å¾„ä¸Šä¸¤ä¸ªç‚¹é¢œè‰²ç›¸åŒæ—¶ï¼Œå…¶ä»–çš„ç‚¹ä¸èƒ½ä¸ç›´å¾„çš„é¢œè‰²ç›¸åŒã€‚è®¾ç›´å¾„çš„æ¡æ•°ä¸º ï¼Œäºæ˜¯æˆ‘ä»¬å¯ä»¥æšä¸¾ç›´å¾„é¢œè‰²ç›¸åŒçš„æ¡æ•° ï¼Œé¦–å…ˆé€‰ æ¡ç›´å¾„ï¼Œç„¶åä¸ºæ¯æ¡ç›´å¾„é€‰ä¸€ä¸ªé¢œè‰²ï¼Œç„¶åä»å‰©ä¸‹çš„  ä¸ªé¢œè‰²ä¸­ç»™å‰©ä¸‹çš„æ¯æ¡ç›´å¾„é€‰ä¸¤ä¸ªé¢œè‰²ï¼Œå†ä»å‰©ä¸‹çš„ ä¸ªé¢œè‰²ä¸­ç»™æ¯ä¸ªå‰©ä¸‹çš„éç›´å¾„çš„ç‚¹é€‰ä¸€ä¸ªé¢œè‰²ï¼Œæ‰€ä»¥ç­”æ¡ˆä¸º:\nE. Electrical Efficiencyè€ƒè™‘æ¯æ¡è¾¹å¯¹ç­”æ¡ˆçš„è´¡çŒ®ï¼Œéå†æ‰€æœ‰è´¨æ•°ï¼Œè®¾å½“å‰çš„è´¨æ•°ä¸º ï¼Œä»¤  ä¸ºå› å­å«  çš„ç‚¹çš„é›†åˆï¼Œå½“  ä¸­ä»»æ„ä¸¤ç‚¹çš„è·¯å¾„ç»è¿‡æŸæ¡è¾¹æ—¶ï¼Œè¯¥è¾¹ä¼šå¯¹ç­”æ¡ˆäº§ç”Ÿ1çš„è´¡çŒ®ã€‚ä»¥ä»»æ„ç‚¹ä¸ºæ ¹ï¼Œå¯¹è¾¹  ï¼ˆ ä¸º  çš„çˆ¶äº²ï¼‰æ¥è¯´ï¼Œæœ‰ï¼ˆ ä¸º  å­æ ‘çš„å¤§å°ï¼‰ä¸ªä¸‰å…ƒç»„ç»è¿‡è¿™æ¡è¾¹ï¼Œç”¨æ ‘å‹dpå°±èƒ½æ±‚è§£ï¼Œä½†è¦æ˜¯å¯¹äºæ¯ä¸ªè´¨æ•°éƒ½éå†ä¸€éæ•´ä¸ªæ ‘çš„è¯å¿…ç„¶è¦è¶…æ—¶æ‰€ä»¥æˆ‘ä»¬ä»¥  ä¸­çš„ç‚¹æ„é€ è™šæ ‘ï¼Œåœ¨è™šæ ‘ä¸Šè·‘dpï¼Œç”±äº  æœ€å¤šæœ‰  ä¸ªä¸é‡å¤çš„è´¨å› å­ï¼Œæ‰€ä»¥æ‰€æœ‰  çš„å’Œæ˜¯  çš„ã€‚#include <bits/stdc++.h>\n\nconstexpr unsigned lg(int x) {\n    return sizeof(int) * 8 - 1 - __builtin_clz(x);\n}\nconstexpr unsigned lg(unsigned int x) {\n    return sizeof(unsigned) * 8 - 1 - __builtin_clz(x);\n}\nconstexpr unsigned lg(long x) {\n    return sizeof(long) * 8 - 1 - __builtin_clzl(x);\n}\nconstexpr unsigned lg(unsigned long x) {\n    return sizeof(unsigned long) * 8 - 1 - __builtin_clzl(x);\n}\nconstexpr unsigned lg(long long x) {\n    return sizeof(long long) * 8 - 1 - __builtin_clzll(x);\n}\nconstexpr unsigned lg(unsigned long long x) {\n    return sizeof(unsigned long long) * 8 - 1 - __builtin_clzll(x);\n}\nconstexpr unsigned ceil_lg(int n) {\n    return n == 0 ? 0 : 32 - __builtin_clz(n - 1);\n}\n\ntemplate <typename T> struct SparseTable {\n    size_t n, logn;\n    std::vector<std::vector<T>> v;\n    std::function<T(T, T)> F;\n    SparseTable() = default;\n    SparseTable(const std::vector<T> &a, std::function<T(T, T)> func)\n        : n(a.size()), logn(lg(n)), v(logn + 1, std::vector<T>(n + 1)), F(func) {\n        v[0] = a;\n        for (size_t i = 1; i <= logn; i++)\n            for (size_t j = 0; j + (1 << i) - 1 < n; j++)\n                v[i][j] = F(v[i - 1][j], v[i - 1][j + (1 << (i - 1))]);\n    }\n    T query(size_t l, size_t r) {\n        assert(l < r);\n        assert(l < n);\n        assert(r <= n);\n        int s = lg(r - l);\n        return F(v[s][l], v[s][r - (1 << s)]);\n    }\n};\n\nstruct EulerLCA {\n    int n;\n    std::vector<int> pos, seq, dep;\n    SparseTable<int> st;\n    EulerLCA(const std::vector<std::vector<int>>& g, int root) : n(g.size()), pos(n), dep(n) {\n        seq.reserve(2 * n);\n        dfs(root, root, g);\n        st = SparseTable<int>(seq, [&](int u, int v) { return pos[u] < pos[v] ? u : v; });\n    }\n    void dfs(int u, int p, const std::vector<std::vector<int>>& g) {\n        pos[u] = seq.size();\n        seq.push_back(u);\n        for (auto v : g[u]) {\n            if (v == p) continue;\n            dep[v] = dep[u] + 1;\n            dfs(v, u, g);\n            seq.push_back(u);\n        }\n    }\n    int lca(int u, int v) {\n        if (pos[u] > pos[v]) std::swap(u, v);\n        return st.query(pos[u], pos[v] + 1);\n    }\n};\nstruct VirtualTree {\n    int n;\n    EulerLCA lca;\n    std::vector<std::vector<int>> tree;\n    VirtualTree(const std::vector<std::vector<int>> &g, int root)\n        : n(g.size()), lca(g, root), tree(n) {}\n    auto build_tree(const std::vector<int> &vertices)\n        -> std::pair<int, const std::vector<std::vector<int>> &> {\n        auto v(vertices);\n        std::sort(v.begin(), v.end(), [&](int u, int v) { return lca.pos[u] < lca.pos[v]; });\n        int len = v.size();\n        for (int i = 1; i < len; i++) {\n            v.push_back(lca.lca(v[i - 1], v[i]));\n        }\n        std::sort(v.begin(), v.end(), [&](int u, int v) { return lca.pos[u] < lca.pos[v]; });\n        v.erase(std::unique(v.begin(), v.end()), v.end());\n        for (int i = 1; i < (int)v.size(); i++) {\n            tree[lca.lca(v[i - 1], v[i])].push_back(v[i]);\n        }\n        return {v[0], tree};\n    }\n    void clear(const std::vector<int> v) {\n        for (auto u : v) {\n            tree[u].clear();\n        }\n    }\n    void clear(int root) {\n        for (auto v : tree[root]) {\n            clear(v);\n        }\n        tree[root].clear();\n    }\n};\ntemplate <typename mint> struct Factorial {\n    std::vector<mint> fac, invfac;\n    Factorial(int n) : fac(n + 1), invfac(n + 1) {\n        fac[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fac[i] = fac[i - 1] * i;\n        }\n        invfac[n] = fac[n].inv();\n        for (int i = n - 1; i >= 0; i--) {\n            invfac[i] = invfac[i + 1] * (i + 1);\n        }\n    }\n    mint C(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        assert((int)size(fac) > n);\n        return fac[n] * invfac[n - k] * invfac[k];\n    }\n    mint P(int n, int m) {\n        assert(!fac.empty());\n        return fac[n] * invfac[n - m];\n    }\n    template<typename... Args>\n    constexpr mint eval(Args... args) {\n        return ((args > 0 ? fac[args] : invfac[-args]) * ...);\n    }\n};\nusing namespace std;\nusing ll = long long;\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    ModInt(ll v = 0) : val(v % MOD) { if (val < 0) val += MOD; };\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const {\n        auto a = val, m = MOD, u = 0, v = 1;\n        while (a != 0) { auto t = m / a; m -= t * a; swap(a, m); u -= t * v; swap(u, v); }\n        assert(m == 1);\n        return u;\n    }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    friend ModInt operator+ (ModInt lhs, const ModInt& rhs) { return lhs += rhs; }\n    friend ModInt operator- (ModInt lhs, const ModInt& rhs) { return lhs -= rhs; }\n    friend ModInt operator* (ModInt lhs, const ModInt& rhs) { return lhs *= rhs; }\n    friend ModInt operator/ (ModInt lhs, const ModInt& rhs) { return lhs /= rhs; }\n    ModInt& operator+=(const ModInt& x) { if ((val += x.val) >= MOD) val -= MOD; return *this; }\n    ModInt& operator-=(const ModInt& x) { if ((val -= x.val) < 0) val += MOD; return *this; }\n    ModInt& operator*=(const ModInt& x) { val = int64_t(val) * x.val % MOD; return *this; }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<998244353>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    int mx = 0;\n    for (auto& x : a) {\n        cin >> x;\n        mx = max(mx, x);\n    }\n    vector<int> minp(mx + 1), primes;\n    for (int i = 2; i <= mx; i++) {\n        if (minp[i] == 0) {\n            minp[i] = i;\n            primes.push_back(i);\n        }\n        for (auto p : primes) {\n            if (i * p > mx) {\n                break;\n            }\n            minp[i * p] = p;\n            if (i % p == 0) {\n                break;\n            }\n        }\n    }\n    vector<vector<int>> p(mx + 1);\n    for (int i = 0; i < n; i++) {\n        int x = a[i];\n        while (x > 1) {\n            int f = minp[x];\n            p[f].push_back(i);\n            while (x % f == 0) {\n                x /= f;\n            }\n        }\n    }\n    vector<vector<int>> g(n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    VirtualTree tr(g, 0);\n    Factorial<mint> f(n);\n    mint ans = 0;\n    for (int fac = 1; fac <= mx; fac++) {\n        if (p[fac].size() < 3) {\n            continue;\n        }\n        auto res = tr.build_tree(p[fac]);\n        auto root = res.first;\n        const auto& tree = res.second;\n        auto dfs = [&](auto& slf, int u) -> int {\n            int size = a[u] % fac == 0;\n            for (auto v : tree[u]) {\n                int sz = slf(slf, v);\n                size += sz;\n                ans += (tr.lca.dep[v] - tr.lca.dep[u]) * (f.C(p[fac].size(), 3) - f.C(sz, 3) - f.C(p[fac].size() - sz, 3));\n            }\n            return size;\n        };\n        dfs(dfs, root);\n        tr.clear(root);\n    }\n    cout << ans << '\\n';\n}F. Field PhotographyORçš„æ¡ä»¶å¾ˆå¥½æ»¡è¶³ï¼šåªè¦å…ˆéƒ½å¾€å³ç§»åŠ¨è‹¥å¹²ä¸ª  å°±å¯ä»¥äº†ï¼Œä¸éš¾çœ‹å‡ºæœ€å°çš„ç§»åŠ¨å•ä½ä¸ºï¼ˆLeast Significant Bitï¼Œæœ€ä½ä½ï¼‰ï¼Œæ‰€ä»¥çº¿æ®µè¦†ç›–çš„ç‚¹çš„ä½ç½®æ¨¡æ˜¯ä¸å˜çš„ï¼Œäºæ˜¯è¿™ä¸ªé—®é¢˜å°±å˜æˆäº†æ¨¡æ„ä¹‰ä¸‹çš„çº¿æ®µè¦†ç›–é—®é¢˜ã€‚ç”±äºåªæœ‰31ç§æƒ…å†µï¼Œå¯ä»¥é¢„å¤„ç†ç„¶åå›ç­”è¯¢é—®ã€‚#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<int> ans(30);\n\n    vector<int> l(n), r(n);\n    for (int i = 0; i < n; i++) {\n        cin >> l[i] >> r[i];\n        l[i]--;\n    }\n\n    for (int j = 0; j < 30; j++) {\n        vector<array<int, 2>> events;\n        for (int i = 0; i < n; i++) {\n            if (r[i] - l[i] >= (1 << j)) {\n                events.push_back({0, 1});\n            } else {\n                int L = l[i] % (1 << j);\n                int R = r[i] % (1 << j);\n                if (L < R) {\n                    events.push_back({L, 1});\n                    events.push_back({R, -1});\n                } else {\n                    events.push_back({0, 1});\n                    events.push_back({L, 1});\n                    events.push_back({R, -1});\n                }\n            }\n        }\n\n        int cur = 0;\n        sort(events.begin(), events.end());\n        for (auto [_, v] : events) {\n            cur += v;\n            ans[j] = max(ans[j], cur);\n        }\n    }\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int x;\n        cin >> x;\n        cout << ans[__builtin_ctz(x)] << \"\\n\";\n    }\n}G. Garageä¸ä¼šæ•°å­¦ï¼Œæ‰“è¡¨+OEISæŸ¥çš„ã€‚ã€‚ã€‚H. Hot Black Hot Whiteé¦–å…ˆä¸éš¾è¯æ˜ ã€‚äºæ˜¯é¢˜ç›®ä¸­çš„ç­‰å¼å°±å˜æˆäº†:ç„¶åå¯ä»¥å‘ç°  åªå¯èƒ½æ˜¯0æˆ–è€…1ã€‚äºæ˜¯æˆ‘ä»¬å¾—åˆ°ä¸¤ç§æƒ…å†µï¼šå¦‚æœ  çš„çŸ³å¤´çš„ä¸ªæ•°å°äºç­‰äºçš„è¯ï¼Œå°†æ‰€æœ‰  çš„æ—¶å€™åˆ†åˆ°ä¸€ç»„å¹¶å–å°±å¯ä»¥é¿å…ä¸Šè¿°ç­‰å¼æˆç«‹ã€‚å¦åˆ™  çš„çŸ³å¤´çš„ä¸ªæ•°å°äºç­‰äºï¼Œç±»ä¼¼åœ°æˆ‘ä»¬å°† çš„çŸ³å¤´åˆ†åˆ°ä¸€ç»„å¹¶å–ã€‚#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> a(2);\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        if (x % 3 == 0) {\n            a[0].push_back(i);\n        } else {\n            a[1].push_back(i);\n        }\n    }\n    string ans(n, '0');\n    if (a[0].size() <= n / 2) {\n        cout << \"0\\n\";\n        for (auto& x : a[0]) ans[x] = '1';\n        for (int i = 0; i < n / 2 - a[0].size(); i++){\n            ans[a[1][i]] = '1';\n        }\n    } else {\n        cout << \"2\\n\";\n        for (auto& x : a[1]) ans[x] = '1';\n        for (int i = 0; i < n / 2 - a[1].size(); i++){\n            ans[a[0][i]] = '1';\n        }\n    }\n    cout << ans << endl;\n}K. Kingdom of Criticismç”±äºç¬¬ä¸‰ç§è¯¢é—®ä¼šä½¿é«˜åº¦çš„ç§ç±»å‡å°2åˆ°è‹¥å¹²ç§è€Œç¬¬ä¸€ç§è¯¢é—®åªä¼šä½¿é«˜åº¦çš„ç§ç±»å¢åŠ 1ï¼Œæ‰€ä»¥æ‰€æœ‰ç¬¬ä¸‰ç§æ“ä½œå‡å°‘çš„é«˜åº¦çš„ç§ç±»ä¸è¶…è¿‡  (ä¸ºåˆåˆå§‹çš„é«˜åº¦çš„ç§ç±»)ã€‚æ‰€ä»¥å¯ä»¥å°†é«˜åº¦ç›¸åŒçš„å»ºç­‘å½’ä¸ºä¸€ç»„ï¼Œç¬¬ä¸‰ç§æ“ä½œä¹Ÿå°±ç›¸å½“äºæŠŠé«˜åº¦åœ¨  ä¸­çš„å»ºç­‘ä¸é«˜åº¦ä¸º  çš„å»ºç­‘æˆ–é«˜åº¦ä¸º  çš„å»ºç­‘åˆå¹¶ï¼ˆæ ¹æ®ç¦»å“ªä¸ªç«¯ç‚¹è¿‘ï¼‰ã€‚äºæ˜¯æˆ‘ä»¬æƒ³åˆ°å¯ä»¥ä½¿ç”¨å¹¶æŸ¥é›†æ¥å®ç°åˆå¹¶æ“ä½œï¼ŒåŒæ—¶è®°å½•æ¯ä¸ªé«˜åº¦çš„ç»„åœ¨å¹¶æŸ¥é›†ä¸­æ‰€å¯¹åº”çš„æ ‘çš„æ ¹,è¿™æ ·å¯ä»¥å¿«é€ŸçŸ¥é“é«˜åº¦åœ¨å¹¶æŸ¥é›†ä¸­æ‰€å¯¹åº”çš„æ ‘ã€‚ä½†ç¬¬ä¸€ç§è¯¢é—®å¯¹åº”çš„å´æ˜¯ä¸€ç§åˆ é™¤çš„æ“ä½œï¼Œä½†å¹¶æŸ¥é›†ä¸æ”¯æŒåˆ é™¤æ“ä½œï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥ç»™å»ºç­‘  èµ‹äºˆä¸€ä¸ªæ–°çš„ç¼–å·ï¼Œè¿™æ ·å°±å˜ç›¸å®ç°äº†åˆ é™¤çš„æ•ˆæœã€‚#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UF {\n    vector<int> fa, sz;\n    UF(int n) : fa(n), sz(n, 1) { iota(fa.begin(), fa.end(), 0); }\n\n    int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\n    bool same(int x, int y) { return find(x) == find(y); }\n\n    bool join(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return false;\n        // if (sz[x] > sz[y]) swap(x, y);\n        fa[x] = y;\n        sz[y] += sz[x];\n        return true;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    map<int, int> leader;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    int q;\n    cin >> q;\n    UF uf(n + q);\n    vector<int> value(n + q), cur(n);\n    for (int i = 0; i < n; i++) {\n        value[i] = a[i];\n        cur[i] = i;\n        if (leader.count(a[i])) {\n            uf.join(i, leader[a[i]]);\n        } else {\n            leader[a[i]] = i;\n        }\n    }\n    int cnt = n;\n    while (q--) {\n        int op;\n        cin >> op;\n        if (op == 1) {\n            int k, w;\n            cin >> k >> w;\n            k--;\n            cur[k] = cnt++;\n            value[cur[k]] = w;\n            if (leader.count(w)) {\n                uf.join(cur[k], leader[w]);\n            } else {\n                leader[w] = cur[k];\n            }\n        } else if (op == 2) {\n            int k;\n            cin >> k;\n            k--;\n            cout << value[uf.find(cur[k])] << '\\n';\n        } else {\n            int l, r;\n            cin >> l >> r;\n            auto it = leader.lower_bound(l);\n            while (it != end(leader) && it->first <= r) {\n                int change_to = it->first <= (l + r) / 2 ? l - 1 : r + 1;\n                if (leader.contains(change_to)) {\n                    uf.join(it->second, leader[change_to]);\n                } else {\n                    leader[change_to] = it->second;\n                    value[it->second] = change_to;\n                }\n                it = leader.erase(it);\n            }\n        }\n    }\n}L. Lemper Cooking Competitionè§‚å¯Ÿåˆ°æ“ä½œå¯¹äºå‰ç¼€å’Œæ•°ç»„çš„å½±å“å°±æ˜¯äº¤æ¢ä½ç½®  ä¸ä½ç½® ï¼Œç”±äºæœ€åè¦æ±‚  ä¸ºéè´Ÿï¼Œé‚£ä¹ˆæœ€ç»ˆçš„å‰ç¼€å’Œæ•°ç»„ä¾¿æ˜¯éé™çš„ï¼Œäºæ˜¯é—®é¢˜å°±å˜æˆäº†æ•°é€†åºå¯¹ï¼Œä½†è¦æ³¨æ„ä½ç½®  ä¸ä½ç½®  æ˜¯ä¸èƒ½äº¤æ¢çš„ï¼Œæå‰ç‰¹åˆ¤ä¸€ä¸‹å³å¯ã€‚#include <algorithm>\n#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) begin(x),end(x)\nusing ll = long long;\n\ntemplate <typename T> struct fenwick {\n    int n; std::vector<T> t;\n    fenwick(int n_) : n(n_), t(n + 1) {}\n    fenwick(const std::vector<T> &v) : fenwick((int)v.size()) {\n        for (int i = 1; i <= n; i++) {\n            t[i] += v[i - 1];\n            int j = i + (i & -i);\n            if (j <= n) t[j] += t[i];\n        }\n    }\n    void add(int i, T x) {\n        assert(i >= 0 && i < n);\n        for (i++; i <= n; i += i & -i) {\n            t[i] += x;\n        }\n    }\n    template <typename U = T> U query(int i) {\n        assert(i >= 0 && i < n);\n        U res{};\n        for (i++; i > 0; i -= i & -i)\n            res += t[i];\n        return res;\n    }\n    template <typename U = T> U query(int l, int r) {\n        assert(l >= 0 && l <= r && r < n);\n        return query<U>(r) - (l ? query<U>(l - 1) : U{});\n    }\n    int search(T prefix) { // finds first pos s.t. sum(0, pos)>=prefix\n        int pos = 0;\n        T sum = 0;\n        for (int i = __lg(n); i >= 0; i--) {\n            // could change < to <= to make it find upper bound\n            if (pos + (1 << i) <= n && (sum + t[pos + (1 << i)] < prefix)) {\n                pos += (1 << i);\n                sum += t[pos];\n            }\n        }\n        return pos;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    for (auto& x : a) cin >> x;\n    for (int i = 1; i < n; i++) {\n        a[i] += a[i - 1];\n    }\n    auto b = a;\n    sort(begin(b), end(b) - 1);\n    if (!is_sorted(all(b)) || b[0] < 0) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    b.erase(unique(all(b)), end(b));\n    fenwick<int> tr(b.size());\n    ll ans = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        auto idx = lower_bound(all(b), a[i]) - begin(b);\n        if (idx > 0)\n            ans += tr.query(idx - 1);\n        tr.add(idx, 1);\n    }\n    cout << ans << '\\n';\n}M. Moving Both Handsæ–°å»ºä¸€å±‚å›¾ä¸ºåŸå›¾çš„åå‘å›¾ï¼Œç„¶åæ¯ä¸ªèŠ‚ç‚¹è¿ä¸€æ¡ä»åŸå›¾åˆ°æ–°å›¾ï¼Œé•¿åº¦ä¸º0çš„è¾¹ï¼Œç„¶åè·‘æœ€æœ€çŸ­è·¯çœ‹åˆ°æ–°å›¾æ¯ä¸ªèŠ‚ç‚¹çš„è·ç¦»å³å¯ã€‚#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr long long INF = 1e18;\ntemplate <typename G>\nstd::vector<long long> dijkstra(const G &g, int start) {\n    std::vector dis(g.size(), INF);\n    using node = std::pair<long long, int>;\n    std::priority_queue<node, std::vector<node>, std::greater<>> q;\n    dis[start] = 0;\n    q.emplace(0, start);\n    while (!q.empty()) {\n        auto [d, u] = q.top();\n        q.pop();\n        if (d != dis[u]) continue;\n        for (auto [v, cost] : g[u]) {\n            if (dis[v] > dis[u] + cost) {\n                dis[v] = dis[u] + cost;\n                q.emplace(dis[v], v);\n            }\n        }\n    }\n    return dis;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<pair<int, int>>> g(n * 2);\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        u--, v--;\n        g[u].push_back({v, w});\n        g[v + n].push_back({u + n, w});\n    }\n    for (int i = 0; i < n; i++) {\n        g[i].push_back({i + n, 0});\n    }\n    auto dis = dijkstra(g, 0);\n    for (int i = n + 1; i < 2 * n; i++) {\n        cout << (dis[i] == INF ? -1 : dis[i]) << \" \";\n    }\n    cout << endl;\n}"},{"id":"CP_tricks","title":"ç®—æ³•ç«èµ›æ‚è®°","content":"ä»…ç”¨åšæé†’è‡ªå·±ï¼Œçœ‹ä¸æ‡‚æ¦‚ä¸è´Ÿè´£ï½LIS å’Œ LNDSint LIS(vector<int> &a) {\n    vector<int> dp;\n    for (auto it : a) {\n        auto pos = lower_bound(begin(dp), end(dp), it);\n        if (pos == dp.end()) dp.push_back(it);\n        else\n            *pos = it;\n    }\n    return dp.size();\n}\n\nint LNDS(vector<int> &a) {\n    vector<int> dp;\n    for (auto it : a) {\n        auto pos = upper_bound(begin(dp), end(dp), it);\n        if (pos == dp.end()) dp.push_back(it);\n        else\n            *pos = it;\n    }\n    return dp.size();\n}Maximum subarray sumint cur = 0, max_sum = 0; // max_sum=-1e8 if at least one element must be chosen\nfor (auto it : a) {\n    cur = max(cur + it, it);\n    max_sum = max(max_sum, cur);\n}æ•´æ•°ä¸‰åˆ†ä»¥æ±‚å‡½æ•°æœ€å¤§å€¼ä¸ºä¾‹while (l < r - 2) {\n    int m = (l + r) / 2;\n    if (cal(m) > cal(m + 1)) r = m + 1;\n    else\n        l = m;\n}\nint ans = max({cal(l), cal(l + 1), cal(r)});æŠŠnåˆ†æˆkç»„\næœ‰ç»„æœ‰ä¸ªï¼Œç»„æœ‰ä¸ªã€‚å¿«é€ŸèŒƒå›´åˆ¤æ–­åˆ¤æ–­æ˜¯å¦åœ¨[0, N)ï¼Œå¸¸ç”¨äºbfs/dfsè¾¹ç•Œåˆ¤æ–­if ((unsigned)x < N)åˆ¤æ–­æ˜¯å¦åœ¨[l, r]å†…if ((x - l | r - x) >= 0)æ ¹æ®ä¸¤æ•°ä¹‹å’Œå’Œå¼‚æˆ–å€¼åæ¨ä¸¤æ•°åŸç†ï¼šå¦‚æœæ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆæ— è§£ã€‚å¦åˆ™ï¼Œæ ¹æ®Aå’Œxorçš„æ¯ä¸€ä½å¡«å°±è¡Œäº†ï¼Œæ³¨æ„å¦‚æœæŸä¸€ä½ä¸¤æ•°éƒ½æ˜¯1çš„è¯ä¹Ÿæ˜¯æ— è§£ã€‚ä¼˜å…ˆé˜Ÿåˆ—æ¨¡æ¿å‚æ•°è‡ªåŠ¨æ¨æ–­åˆ©ç”¨äº†ç±»æ¨¡æ¿å®å‚æ¨å¯¼ï¼ˆCTADï¼‰ï¼Œå¯ä»¥å°‘å†™ä¸€ç‚¹ä»£ç ï¼Œéœ€è¦C++17ã€‚priority_queue q(greater{}, vector<int>{});g++11 æœ‰ bugï¼Œè¦å†™æˆpriority_queue q{greater{}, vector<int>{}};ç²¾ç¡®è®¡ç®—x == 1 ? 0 : __lg(x - 1) + 1ç”¨äº¤æ¢ç›¸é‚»å…ƒç´ çš„æ’åºæ•°ç»„çš„æœ€å°æ“ä½œæ¬¡æ•°æ˜¯æ•°ç»„ä¸­é€†åºå¯¹çš„æ•°ç›®aä¸ª0ï¼Œbä¸ª1ç»„æˆçš„01å­—ç¬¦ä¸²å­—å…¸åºç¬¬kå°å…ˆé¢„å¤„ç†iä¸ª0,jä¸ª1çš„å­—ç¬¦ä¸²ä¸ªæ•°ï¼Œç„¶åä»é«˜ä½åˆ°åº•ä½æšä¸¾vector dp(a + 1, vector(b + 1, 0LL));\ndp[0][0] = 1;\nfor (int i = 0; i <= a; i++) {\n    for (int j = 0; j <= b; j++) {\n        if (i > 0) {\n            dp[i][j] += dp[i - 1][j];\n        }\n        if (j) {\n            dp[i][j] += dp[i][j - 1];\n        }\n    }\n}\nauto find_kth = [&](auto &find_kth, int A, int B, ll k) {\n    if (A == 0) return string(B, 'b');\n    if (B == 0) return string(A, 'a');\n    if (k <= dp[A - 1][B]) return \"a\" + find_kth(find_kth, A - 1, B, k);\n    return \"b\" + find_kth(find_kth, A, B - 1, k - dp[A - 1][B]);\n};ä½è¿ç®—æŠ€å·§å¯ä»¥çœ‹è¿™å†’æ³¡æ’åºéå†çš„æ¬¡æ•°åˆ›å»ºä¸€ä¸ªå¤åˆ¶æ•°ç»„bï¼Œå…¶ä¸­ï¼Œç„¶åæ’åºbï¼Œæ’åºåçš„æœ€å¤§å€¼å°±æ˜¯ç­”æ¡ˆï¼Œæœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªæ•°å‘å‰ç§»åŠ¨çš„è·ç¦»ï¼Œä¸éš¾æƒ³å‡ºæ¯ä¸ªä¼šå‘å‰ç§»åŠ¨çš„æ•°ä»ç¬¬ä¸€è½®éå†å°±ä¼šå¼€å§‹å‘å‰ç§»åŠ¨ï¼Œç›´åˆ°åˆ°è¾¾æ’åºåçš„ä½ç½®ï¼Œæ‰€ä»¥æœ€å¤§çš„å‘å‰ç§»åŠ¨è·ç¦»å°±æ˜¯éå†çš„è½®æ•°ã€‚"},{"id":"GYM102428F","title":"Gym 102428F - Fabricating Sculptures é¢˜è§£","content":"ä¼˜é›…çš„è§£æ³•ã€‚é¢˜è§£é¦–å…ˆæˆ‘ä»¬å¯ä»¥å¿½ç•¥ç¬¬ä¸€å±‚æ–¹å—ã€‚è®¾è¡¨ç¤ºæŠŠä¸ªæ–¹å—æ”¾åœ¨å †ä¸Šæ”¾æ³•çš„æ•°é‡ã€‚ï¼ˆæœ‰äº›å †å¯ä»¥æ˜¯ç©ºçš„)ç°åœ¨æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹è½¬ç§»æ–¹ç¨‹ï¼Œæœ‰ä¸‰ç§æƒ…å†µï¼šç¬¬ä¸€å±‚æ˜¯æ»¡çš„æœ€å·¦è¾¹çš„å †æ˜¯ç©ºçš„åœ¨å³è¾¹çš„å †æ˜¯ç©ºçš„ç¬¬ä¸€ç§æƒ…å†µæˆ‘ä»¬å¯ä»¥å¿½ç•¥æ‰ç¬¬ä¸€å±‚ï¼Œæ”¾ç½®çš„æ–¹æ³•å°±æ˜¯. ç¬¬äºŒï¼Œä¸‰ç§æƒ…å†µæˆ‘ä»¬å¯ä»¥å¿½ç•¥æ‰ç©ºçš„é‚£ä¸€å †ï¼Œæ‰€ä»¥æœ‰ç§æ”¾æ³•ï¼Œä½†ä¸¤ç§æƒ…å†µæœ‰é‡å ï¼Œå› ä¸ºæœ‰å¯èƒ½å·¦å³ä¸¤å †éƒ½æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥è¦å‡æ‰ã€‚ç»¼ä¸Šæ‰€è¿°ï¼Œè½¬ç§»æ–¹ç¨‹å°±æ˜¯ï¼šè¿™ä¸ªå¯ä»¥ç”¨è®°å¿†åŒ–æœç´¢æ¥æ±‚ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate<typename... Args>\nvoid write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nconst int N=5e3+5;\nll dp[N][N];\nconst int mod=1e9+7;\nll solve(int s,int b){\n    if(b==0) return 1;\n    if(s<=0) return 0;\n    ll& ret=dp[s][b];\n    if( ret) return ret;\n    ret=0;\n    if(s<=b) ret=solve(s,b-s);\n    ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod;\n    return ret;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int s,b;\n    cin>>s>>b;\n    cout<<solve(s,b-s);\n    return 0;\n}"},{"id":"HDU5592","title":"HDU 5592 - ZYB's Premutation é¢˜è§£","content":"å¦™å•ŠProblem Linké¢˜è§£æˆ‘ä»¬ç”¨è¡¨ç¤ºè¾“å…¥ï¼Œç”¨è¡¨ç¤ºç­”æ¡ˆã€‚å°±æ˜¯æ¯”å¤§çš„æ•°å­—çš„ä¸ªæ•°å› æ­¤æˆ‘ä»¬ä¹Ÿèƒ½çŸ¥é“æ¯”å°çš„æ•°çš„ä¸ªæ•°ã€‚æˆ‘ä»¬å¯ä»¥ç”¨æƒå€¼çº¿æ®µæ ‘ç„¶åä»åéå†ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½å¾—åˆ°æ‰€æœ‰æ²¡ç”¨è¿‡çš„æ¯”å°çš„æ•°çš„ä¸ªæ•°ï¼Œç„¶ååœ¨çº¿æ®µæ ‘ä¸­æ‰¾åˆ°å¯¹åº”çš„æ•°å¹¶æ›´æ–°çº¿æ®µæ ‘ã€‚Code#include <bits/stdc++.h>\n\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\nusing namespace std;\n\nconst int N=5e4+5;\nint sum[N<<2];\nvoid build(int k,int l,int r){\n\tsum[k]=r-l+1;\n\tif(l==r) return;\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n}\nint query(int root,int l,int r,int p){\n\tsum[root]--;\n\tif(l==r) return l;\n\tint mid=(l+r)>>1;\n\tif(sum[root<<1]>=p) return query(root<<1,l,mid,p);\n\telse return query(root<<1|1,mid+1,r,p-sum[root<<1]);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint tt;\n\tcin>>tt;\n\twhile(tt--){\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int> a(n+1),ans(n+1);\n\t\tfor1(i,n) cin>>a[i];\n\t\tbuild(1,1,n);\n\t\tfor(int i=n;i>0;i--){\n\t\t\tint p=a[i]-a[i-1];\n\t\t\tp=i-p;\n\t\t\tans[i]=query(1,1,n,p);\n\t\t}\n\t\tfor1(i,n) cout<<ans[i]<<(i==n?'\\n':' ');\n\t}\n    return 0;\n}"},{"id":"HDU6278","title":"HDU6278 - Just h-index é¢˜è§£","content":"ä¸»å¸­æ ‘ï¼é¢˜è§£ç”¨ä¸»å¸­æ ‘æˆ‘ä»¬å¯ä»¥çŸ¥é“åœ¨ç»™å®šåŒºé—´é‡Œçš„æ‰€æœ‰æ•°çš„å‡ºç°æ¬¡æ•°ã€‚æˆ‘ä»¬å¯ä»¥æ¯”è¾ƒå®¹æ˜“çš„æƒ³åˆ°ä¸€ä¸ªäºŒåˆ†åšæ³•ï¼šint l=0,r=INF;\nwhile(l<=r){\n    int mid=(l+r)>>1;\n    if(occurrence_of_numbers_bigger_than(mid)>=mid) l=mid+1;\n    else r=mid-1;\n}\ncout<<r<<endl;è¿™ç§åšæ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ã€‚è¶³å¤Ÿé€šè¿‡æœ¬é¢˜ï¼Œä½†è¿˜æœ‰ä¼˜åŒ–çš„åœ°æ–¹ã€‚äº‹å®ä¸Šï¼ŒäºŒåˆ†éƒ¨åˆ†å¯ä»¥åœ¨æ ‘ä¸ŠæŸ¥è¯¢çš„æ—¶å€™å®Œæˆã€‚é¦–å…ˆæˆ‘ä»¬è§„å®šå‡ ä¸ªå˜é‡ï¼šä¸ºå½“å‰è¯¢é—®çš„åŒºé—´ï¼Œä¸ºå½“å‰åœ¨æ ‘ä¸ŠæŸ¥è¯¢çš„åŒºé—´ï¼Œä¸ºé‡Œæ•°å­—çš„å‡ºç°æ¬¡æ•°ã€‚ä¼ªä»£ç å¤§æ¦‚æ˜¯è¿™æ ·ï¼šint query(int l,int r,int s){\n    int mid=(l+r)>>1;\n    int cnt=occurrence_of_number_from_mid_to_r();\n    if(cnt+s>=mid+1) return query(mid+1,r,s);//(mid,y]ä¸­çš„æ•°æ¯”midå¤§ï¼Œä¹Ÿå°±æ˜¯è¯´ç­”æ¡ˆåœ¨å³è¾¹çš„åŒºé—´\n    return query(l,mid,s+cnt);//(mid,y]çš„æ•°ä¸å¤Ÿå¤šï¼Œç­”æ¡ˆåœ¨å·¦è¾¹çš„åŒºé—´\n}Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nstruct PerSegTree {\n    vector<int> lson, rson, sum, root;\n    int tot;\n    PerSegTree(int n) {\n        lson = rson = sum = vector<int>(n << 5);\n        root = vector<int>(n + 1);\n        tot = 0;\n    }\n    void pushup(int rt) {\n        sum[rt] = sum[lson[rt]] + sum[rson[rt]];\n    }\n    void build(int l, int r, int& rt) {\n        rt = ++tot;\n        if (l == r) return;\n        int mid = (l + r) >> 1;\n        build(l, mid, lson[rt]);\n        build(mid + 1, r, rson[rt]);\n        pushup(rt);\n    }\n    void update(int pos, int val, int l, int r, int ord, int& rt) {\n        rt = ++tot;\n        lson[rt] = lson[ord];\n        rson[rt] = rson[ord];\n        if (l == r) {\n            sum[rt] = sum[ord] + val;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        if (pos <= mid) update(pos, val, l, mid, lson[ord], lson[rt]);\n        else update(pos, val, mid + 1, r, rson[ord], rson[rt]);\n        pushup(rt);\n    }\n    int query(int pos, int l, int r, int lrt, int rrt) {\n        if (l == r) return sum[rrt] - sum[lrt];\n        int mid = (l + r) >> 1;\n        if (pos <= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]);\n        return query(pos, mid + 1, r, rson[lrt], rson[rrt]);\n    }\n};\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,q;\n    while(cin>>n>>q){\n        PerSegTree tree(n);\n        tree.build(1,n,tree.root[0]);\n        for1(i,n){\n            int x;\n            cin>>x;\n            tree.update(x,1,1,n,tree.root[i-1],tree.root[i]);\n        }\n        while(q--){\n            int x,y;\n            cin>>x>>y;\n            int l=0,r=1e5;\n            while(l<=r){\n                int mid=(l+r)>>1;\n                int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]);\n                if(ans>=mid) l=mid+1;\n                else r=mid-1;\n            }\n            cout<<r<<endl;\n        }\n    }\n    return 0;\n}#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nstruct PerSegTree {\n    vector<int> lson, rson, sum, root;\n    int tot;\n    PerSegTree(int n) {\n        lson = rson = sum = vector<int>(n << 5);\n        root = vector<int>(n + 1);\n        tot = 0;\n    }\n    void pushup(int rt) {\n        sum[rt] = sum[lson[rt]] + sum[rson[rt]];\n    }\n    void build(int l, int r, int& rt) {\n        rt = ++tot;\n        if (l == r) return;\n        int mid = (l + r) >> 1;\n        build(l, mid, lson[rt]);\n        build(mid + 1, r, rson[rt]);\n        pushup(rt);\n    }\n    void update(int pos, int val, int l, int r, int ord, int& rt) {\n        rt = ++tot;\n        lson[rt] = lson[ord];\n        rson[rt] = rson[ord];\n        if (l == r) {\n            sum[rt] = sum[ord] + val;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        if (pos <= mid) update(pos, val, l, mid, lson[ord], lson[rt]);\n        else update(pos, val, mid + 1, r, rson[ord], rson[rt]);\n        pushup(rt);\n    }\n    int query(int l, int r, int old_rt, int rt,int s) {\n        if(l==r) return l;\n        int mid=(l+r)>>1;\n        int cnt=sum[rson[rt]]-sum[rson[old_rt]];\n        if(mid<cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s);\n        return query(l,mid,lson[old_rt],lson[rt],s+cnt);\n    }\n};\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,q;\n    while(cin>>n>>q){\n        PerSegTree tree(n);\n        tree.build(1,n,tree.root[0]);\n        for1(i,n){\n            int x;\n            cin>>x;\n            tree.update(x,1,1,n,tree.root[i-1],tree.root[i]);\n        }\n        while(q--){\n            int x,y;\n            cin>>x>>y;\n            cout<<tree.query(1,n,tree.root[x-1],tree.root[y],0)<<endl;\n        }\n    }\n    return 0;\n}"},{"id":"HDU6602","title":"é¢˜è§£ HDU6602 - Longest Subarray","content":"linké¢˜è§£è®©æˆ‘ä»¬å…ˆå°è¯•å›ºå®šå³ç«¯ç‚¹ï¼Œç„¶åå¯¹äºæ¯ä¸ªå³ç«¯ç‚¹æ‰¾åˆ°æœ€é•¿çš„å­æ•°ç»„ã€‚ä»¤ä¸ºç¬¬iä¸ªçš„ä¸‹æ ‡ã€‚å‡è®¾å½“å‰çš„å³ç«¯ç‚¹æ˜¯ï¼Œå¯¹äºæ¯ä¸ª,å·¦ç«¯ç‚¹ä¸å¯èƒ½è½åœ¨åŒºé—´ï¼Œå…¶ä¸­æ˜¯ç›´åˆ°ä¸ºæ­¢çš„å‡ºç°æ¬¡æ•°ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœå·¦ç«¯ç‚¹åœ¨è¿™ä¸ªåŒºé—´å†…ï¼Œåˆ™çš„å‡ºç°å°†å¤§äºé›¶ä¸”å°äºï¼Œä¸æ»¡è¶³çº¦æŸæ¡ä»¶ã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¿™äº›åŒºé—´ä¸ŠåŠ 1ï¼Œé‚£ä¹ˆæœ€å·¦çš„ç«¯ç‚¹æ˜¯å€¼ä¸º0çš„æœ€å°ä¸‹æ ‡ã€‚ç°åœ¨è®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸‹å½“å³ç«¯ç‚¹ç§»è‡³æ—¶åŒºé—´å¦‚ä½•å˜åŒ–ã€‚æ˜¾è€Œæ˜“è§ï¼Œåªæœ‰çš„åŒºé—´ä¼šæ”¹å˜ã€‚\nåŒºé—´å°†ä»å˜ä¸ºã€‚è¯·æ³¨æ„ï¼Œåœ¨ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¸å¿…æ›´æ”¹é‡å çš„éƒ¨åˆ†ã€‚ç»¼ä¸Šæ‰€è¿°ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ”¯æŒåŒºé—´ä¿®æ”¹å’Œå…¨å±€æœ€å°å€¼æŸ¥è¯¢çš„æ•°æ®ç»“æ„,akaçº¿æ®µæ ‘ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define size(x) int(x.size())\n#define pb push_back\n\nusing namespace std;\n\nstruct SegTree{\n    int n;\n    vector<int> t,lazy,pos;\n    SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){\n        build(1,0,n-1);\n    }\n    void pushup(int node){\n        t[node]=min(t[node<<1],t[node<<1|1]);\n        pos[node]=(t[node]==t[node<<1]?pos[node<<1]:pos[node<<1|1]);\n    }\n    void build(int node,int l,int r){\n        if(l==r){\n            pos[node]=l;\n            return;\n        }\n        int mid=(l+r)>>1;\n        build(node<<1,l,mid);\n        build(node<<1|1,mid+1,r);\n        pushup(node);\n    }\n    void addtag(int p,int x){\n        t[p]+=x;\n        lazy[p]+=x;\n    }\n    void spread(int p){\n        if(lazy[p]){\n            addtag(p<<1,lazy[p]);\n            addtag(p<<1|1,lazy[p]);\n            lazy[p]=0;\n        }\n    }\n    void update(int node,int ql,int qr,int l,int r,int x){\n        if(ql<=l&&qr>=r){\n            addtag(node,x);\n            return;\n        }\n        spread(node);\n        int mid=(l+r)>>1;\n        if(ql<=mid) update(node<<1,ql,qr,l,mid,x);\n        if(qr>mid) update(node<<1|1,ql,qr,mid+1,r,x);\n        pushup(node);\n    }\n    int query(int i){\n        return t[1]==0?i-pos[1]+1:0;\n    }\n\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,c,k;\n    while(cin>>n>>c>>k){\n        vector<vector<int>> pos(c+1,{-1});\n        vector<int> a(n);\n        for(auto& it:a) cin>>it;\n        SegTree st(n);\n        int ans=0;\n        forn(i,n){\n            auto& v=pos[a[i]];\n            v.pb(i);\n            int sz=size(v)-1;\n            if(sz<k) st.update(1,v[sz-1]+1,i,0,n-1,1);\n            else{\n                st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1);\n                st.update(1,v[sz-1]+1,i,0,n-1,1);\n            }\n            ans=max(ans,st.query(i));\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"},{"id":"ICPC-WF-2020-Invitational-L","title":"ICPC WF Moscow Invitational Contest L - Labyrinth é¢˜è§£","content":"é¢˜ç›®é“¾æ¥é¢˜è§£é¦–å…ˆï¼Œä»¥ä¸‹ä¸¤ç‚¹ä¸éš¾æƒ³åˆ°ï¼šæˆ‘ä»¬åªä¼šåœ¨æœ€å¤§ç”Ÿæˆæ ‘çš„è¾¹ä¸Šèµ°ï¼Œè¿™æ ·æˆ‘ä»¬å°±æŠŠå›¾å˜æˆäº†æ ‘ã€‚å¯¹äºæ‰€æœ‰è¾¹ï¼Œæœ€ä¼˜ç­–ç•¥æ°¸è¿œæ˜¯å…ˆåƒæ ‘ä¸Šä¸€è¾¹çš„æ‰€æœ‰ç‚¹ç„¶åå†åƒå¦ä¸€è¾¹ã€‚ç”±äºå®½åº¦å°çš„è¾¹ä¼šæœ€å…ˆä¸æ»¡è¶³æ¡ä»¶ï¼Œå› æ­¤è¦ä¼˜å…ˆè€ƒè™‘å®½åº¦å°çš„è¾¹ï¼Œä½†è¾¹ä¸¤ä¾§çš„è¿é€šå—çš„æƒ…å†µè¿˜ä¸çŸ¥é“ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å…ˆç»§ç»­å¤„ç†ä¸¤ä¾§çš„ä¿¡æ¯å†ç¡®å®šåƒçš„æ–¹å‘ï¼Œè€Œæ¯ä¾§çš„è¿é€šå—ä¸­æœ€çª„çš„è¾¹åˆä¼šæŠŠè¿é€šå—ä¸€åˆ†ä¸ºäºŒâ€¦â€¦è¿™æ ·ä¸€ç›´é€’å½’ä¸‹å»ç›´åˆ°æ¯ä¸ªè¿é€šå—åªå‰©ä¸€ä¸ªç‚¹ã€‚åˆå¹¶çš„é¡ºåºå°±æ˜¯ä»å®½è¾¹åˆ°çª„è¾¹ï¼Œè¿™æ­£å¥½ä¹Ÿæ˜¯æ±‚æœ€å¤§ç”Ÿæˆæ ‘çš„é¡ºåºï¼Œäºæ˜¯å¯ä»¥åœ¨æ±‚æœ€å¤§ç”Ÿæˆæ ‘çš„åŒæ—¶ç»´æŠ¤ç­”æ¡ˆã€‚å¯¹äºæ¯ä¸ªè¿é€šå—ï¼Œæˆ‘ä»¬ç»´æŠ¤è¿›å…¥è¿™ä¸ªè¿é€šå—æ—¶äººçš„æœ€å¤§å®½åº¦ã€‚å‡è®¾å¾…åˆå¹¶çš„ä¸¤ä¸ªè¿é€šå—ä¸ºï¼Œæ¯ä¸ªå—çš„å€¼çš„å’Œä¸ºï¼Œä¹‹é—´çš„è¾¹çš„å®½åº¦ä¸ºï¼Œä»åˆ°è¦æ»¡è¶³å’Œï¼Œå˜å½¢ä¸€ä¸‹å°±æ˜¯ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœå…ˆåƒå†åƒ çš„è¯ï¼Œè¿›å…¥åˆå¹¶ä¹‹åçš„è¿é€šå—æ—¶æœ€å¤§çš„å®½åº¦ä¸º ï¼Œå…ˆåƒå†åƒçš„æƒ…å†µç±»ä¼¼ï¼Œå–ä¸¤ç§æƒ…å†µä¸­å®½åº¦æ›´å¤§çš„æƒ…å†µã€‚ä»£ç #include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(), (x).end()\nusing ll = long long;\n\nconstexpr ll INF = 1e18;\nstruct UF {\n    vector<int> fa, sz;\n    vector<ll> mx, sum;\n    UF(int n) : fa(n), sz(n, 1), mx(n, INF), sum(n) {\n        iota(all(fa), 0);\n    }\n\n    int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\n    void join(int u, int v, ll w) {\n        u = find(u), v = find(v);\n        if (u == v) return;\n        if (sz[u] > sz[v]) swap(u, v);\n        ll fromV = -INF, fromU = -INF;\n        if (sum[v] <= mx[u]) fromV = min(mx[u], w) - sum[v];\n        if (sum[u] <= mx[v]) fromU = min(mx[v], w) - sum[u];\n        mx[v] = max(fromU, fromV);\n        sum[v] += sum[u];\n        fa[u] = v;\n        sz[v] += sz[u];\n        return;\n    }\n    auto check() { return mx[find(0)]; }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<array<int, 3>> edges(m);\n    UF uf(n);\n    for (int i = 0; i < n; i++)\n        cin >> uf.sum[i];\n    for (auto &[u, v, c] : edges)\n        cin >> u >> v >> c, u--, v--;\n    sort(begin(edges), end(edges), [&](auto& i, auto& j) { return i[2] > j[2]; });\n    for (auto &[u, v, c] : edges)\n        uf.join(u, v, c);\n    if (auto mx = uf.check(); mx < 1) cout << \"-1\\n\";\n    else\n        cout << mx << endl;\n}"},{"id":"JOIOC18-bubblesort2","title":"JOI '18 Open P1 - Bubble Sort 2 é¢˜è§£","content":"é¢˜ç›®é“¾æ¥é¦–å…ˆæˆ‘ä»¬è¦çŸ¥é“å¯¹äºå›ºå®šçš„æ•°ç»„å¦‚ä½•æ±‚éå†è½®æ•°ï¼š åˆ›å»ºä¸€ä¸ªå¤åˆ¶æ•°ç»„bï¼Œå…¶ä¸­ï¼Œç„¶åæ’åºbï¼Œæ’åºåçš„æœ€å¤§å€¼å°±æ˜¯ç­”æ¡ˆï¼Œæœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªæ•°å‘å‰ç§»åŠ¨çš„è·ç¦»ï¼Œä¸éš¾æƒ³å‡ºæ¯ä¸ªä¼šå‘å‰ç§»åŠ¨çš„æ•°ä»ç¬¬ä¸€è½®éå†å°±ä¼šå¼€å§‹å‘å‰ç§»åŠ¨ï¼Œç›´åˆ°åˆ°è¾¾æ’åºåçš„ä½ç½®ï¼Œæ‰€ä»¥æœ€å¤§çš„å‘å‰ç§»åŠ¨è·ç¦»å°±æ˜¯éå†çš„è½®æ•°ã€‚ç°åœ¨è€ƒè™‘ä¿®æ”¹åŸæ•°ç»„åï¼Œæ•°ç»„ä»¥åŠçš„å€¼ä¼šæœ‰ä»€ä¹ˆæ”¹å˜ï¼Œä¸éš¾å‘ç°å…¶å®å°±æ˜¯åˆ æ‰äº†ï¼Œç„¶åå†æ’å…¥ï¼ˆxä¸vçš„å«ä¹‰ä¸é¢˜ç›®ç›¸åŒï¼‰ï¼Œbæ•°ç»„ä¸­åœ¨è€ä½ç½®ä¸æ–°ä½ç½®ä¸­é—´çš„å…ƒç´ ä¼šç§»åŠ¨ä¸€ä½ï¼Œæ‰€ä»¥ä»–ä»¬çš„ä¼š+1æˆ–è€…-1ï¼ˆç”±æ–°è€ä½ç½®çš„å…³ç³»è€Œå®šï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥æ’å…¥åˆ é™¤åˆèƒ½åŒºé—´åŠ çš„æ•°æ®ç»“æ„ï¼Œå¹¶ä¸”æ”¯æŒæŸ¥è¯¢å…¨å±€æœ€å¤§å€¼ï¼Œé‚£åªèƒ½æ˜¯å¹³è¡¡æ ‘äº†ã€‚ä»£ç #include <bits/stdc++.h>\nusing namespace std;\n\nauto seed=chrono::high_resolution_clock::now().time_since_epoch().count();\nmt19937 gen(seed);\ntemplate <typename T> struct Treap {\n    struct node {\n        int ch[2], sz;\n        unsigned k;\n        pair<int, int> d;\n        T mx, lazy, dif;\n        node(pair<int, int> d_, int dd, int z = 1) : sz(z), k((unsigned)gen()), d(d_), mx(dd), lazy(), dif(dd) {\n            ch[0] = ch[1] = 0;\n        }\n    };\n    vector<node> nodes;\n    int root=0, recyc=0;\n    Treap(int size = 2e5) {\n        nodes.reserve(size);\n        nodes.emplace_back(pair{0, 0}, -1e9, 0);\n    }\n    inline int &ch(int rt, int r) { return nodes[rt].ch[r]; }\n    int new_node(const pair<int, int> &d, int dd) {\n        nodes.emplace_back(d, dd);\n        return nodes.size()-1;\n    }\n    int pull(int rt) {\n        node &n = nodes[rt];\n        n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;\n        n.mx = max({n.dif, nodes[n.ch[0]].mx, nodes[n.ch[1]].mx});\n        return rt;\n    }\n    void add(int rt, const T &d) {\n        node &n = nodes[rt];\n        n.lazy += d;\n        n.mx += d;\n        n.dif+=d;\n    }\n    void pushdown(int rt) {\n        node &n = nodes[rt];\n        if (n.lazy) {\n            add(n.ch[0], n.lazy);\n            add(n.ch[1], n.lazy);\n            n.lazy = T();\n        }\n    }\n    int merge(int tl, int tr) {\n        if (!tl) return tr;\n        if (!tr) return tl;\n        if (nodes[tl].k < nodes[tr].k) {\n            pushdown(tl);\n            ch(tl, 1) = merge(ch(tl, 1), tr);\n            return pull(tl);\n        } else {\n            pushdown(tr);\n            ch(tr, 0) = merge(tl, ch(tr, 0));\n            return pull(tr);\n        }\n    }\n    void split(int rt, pair<int, int> k, int &x, int &y) { // split out element less than or equal to k\n        if (!rt) {\n            x = y = 0;\n            return;\n        }\n        pushdown(rt);\n        if (k < nodes[rt].d) {\n            y = rt;\n            split(ch(rt, 0), k, x, ch(rt, 0));\n        } else {\n            x = rt;\n            split(ch(rt, 1), k, ch(rt, 1), y);\n        }\n        pull(rt);\n    }\n    // interface\n    void insert(pair<int, int> v, int d) {\n        int rt = new_node(v, d);\n        root = merge(root, rt);\n    }\n    void move_right(int old, int ne, int idx) {\n        int a, b, c, d;\n        split(root, {ne, idx}, c, d);\n        split(c, {old, idx}, b, c);\n        split(b, {old, idx-1}, a, b);\n        if (c) add(c, 1);\n        nodes[b]=node({ne, idx}, idx-(nodes[a].sz+nodes[c].sz));\n        root = merge(merge(merge(a, c), b), d);\n    }\n    void move_left(int old, int ne, int idx) {\n        int a, b, c, d;\n        split(root, {old, idx}, c, d);\n        split(c, {old, idx-1}, b, c);\n        split(b, {ne, idx}, a, b);\n        if (b) add(b, -1);\n        nodes[c]=node({ne, idx}, idx-(nodes[a].sz));\n        root=merge(merge(merge(a, c), b), d);\n    }\n    int query() {\n        return nodes[root].mx;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, q;\n    cin>>n>>q;\n    vector<int> a(n);\n    for (auto& x  : a) cin>>x;\n    vector<pair<int, int>> b(n);\n    for (int i=0; i<n; i++) {\n        b[i]={a[i], i};\n    }\n    sort(b.begin(), b.end());\n    Treap<int> tr;\n    for (int i=0; i<n; i++) {\n        tr.insert(b[i], b[i].second-i);\n    }\n    while (q--) {\n        int x, v;\n        cin>>x>>v;\n        if (a[x]<v) {  // move right\n            tr.move_right(a[x], v, x);\n        } else { // move left\n            tr.move_left(a[x], v, x);\n        }\n        a[x]=v;\n        cout<<tr.query()<<'\\n';\n    }\n}"},{"id":"LOJ2097","title":"ã€ŒCQOI2015ã€ä»»åŠ¡æŸ¥è¯¢ç³»ç»Ÿé¢˜è§£","content":"é¢˜è§£æœ¬é¢˜è¦æ±‚çš„æ˜¯åœ¨æŸä¸€æ—¶åˆ»å‰kå°çš„ä¼˜å…ˆçº§çš„å’Œï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸å¦¨ä»¥ä¼˜å…ˆçº§ï¼ˆè¦å…ˆç¦»æ•£åŒ–ï¼‰ä¸ºä¸‹æ ‡å»ºç«‹å¯æŒä¹…åŒ–çº¿æ®µæ ‘ï¼ˆä¸»å¸­æ ‘ï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´ä»ä»»ä¸€æ ¹èŠ‚ç‚¹å‡ºå‘å¾—åˆ°çš„æ˜¯æŸä¸€æ—¶åˆ»æ­£åœ¨è¿è¡Œçš„æ‰€æœ‰ä»»åŠ¡ã€‚è¿™æ ·ä¸€ä¸ªä»»åŠ¡å¯ä»¥è¢«æ‹†åˆ†æˆä¸¤ä¸ªäº‹ä»¶ï¼šåœ¨Sç§’æ—¶åŠ å…¥æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡çš„é›†åˆï¼ˆä¹Ÿå°±æ˜¯åœ¨ä¸»å¸­æ ‘ä¸Šå¯¹åº”çš„ä¼˜å…ˆçº§ä¸Š+1ï¼‰åœ¨E+1ç§’æ—¶ä»æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡çš„é›†åˆä¸­ç§»é™¤ï¼ˆä¹Ÿå°±æ˜¯åœ¨ä¸»å¸­æ ‘ä¸Šå¯¹åº”çš„ä¼˜å…ˆçº§ä¸Š-1ï¼‰æˆ‘ä»¬æŠŠæ‰€æœ‰äº‹ä»¶æŒ‰æ—¶é—´é¡ºåºæ’åºå¹¶ä¾æ¬¡æ›´æ–°ä¸»å¸­æ ‘ï¼Œå¹¶è®°å½•å¯¹äºæ¯ä¸ªæ—¶åˆ»ï¼Œè¯¥æ—¶åˆ»å‰æœ€æ–°ç‰ˆæœ¬çš„çº¿æ®µæ ‘çš„æ ¹èŠ‚ç‚¹ï¼ŒæŸ¥è¯¢æ—¶å°±ä»è¯¥æ ¹èŠ‚ç‚¹å‡ºå‘ã€‚çº¿æ®µæ ‘è¦ç»´æŠ¤ä¸¤ä¸ªä¿¡æ¯ï¼Œä¸€ä¸ªæ˜¯åŒºé—´å†…æ­£åœ¨è¿è¡Œä»»åŠ¡çš„æ•°é‡ï¼Œä¸€ä¸ªæ˜¯æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡çš„ä¼˜å…ˆçº§ä¹‹å’Œã€‚å€¼å¾—æ³¨æ„çš„æ˜¯æŸ¥è¯¢çš„æ˜¯å•ä¸€æ—¶åˆ»çš„ä¿¡æ¯ï¼Œä¸åƒæ±‚åŒºé—´ç¬¬kå°æ—¶è¦ä¸¤ä¸ªåŒºé—´ä¿¡æ¯ç›¸å‡ï¼Œæ‰€ä»¥å†™èµ·æ¥ä¹Ÿç®€å•ä¸€ç‚¹ã€‚ä¸€ä¸ªéå¸¸å®¹æ˜“é”™çš„åœ°æ–¹æ˜¯æŸ¥è¯¢æ˜¯å½“èµ°åˆ°å¶å­èŠ‚ç‚¹æ—¶ï¼Œå¦‚æœè¯¥ä¼˜å…ˆçº§çš„ä»»åŠ¡æ•°é‡å¤§äºå½“å‰çš„kå€¼ï¼Œä¸èƒ½ç›´æ¥åŠ ä¸Šå¶å­èŠ‚ç‚¹ä¸­çš„ä¼˜å…ˆçº§ä¹‹å’Œï¼Œè¦å…ˆé™¤ä»¥ä»»åŠ¡æ•°é‡å†ä¹˜kå€¼ã€‚ä»£ç #include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct PST {\n    int n, tot = 0;\n    struct node {\n        int lc, rc, cnt;\n        ll sum;\n    };\n    vector<node> t;\n    vector<int> roots; // left child, right child\n    PST(int n_) : n(n_), t(n << 6), roots(1) {\n        build(0, n - 1, roots[0]);\n    }\n#define lc(rt) t[rt].lc\n#define rc(rt) t[rt].rc\n    void pushup(int rt) {\n        t[rt].sum = t[lc(rt)].sum + t[rc(rt)].sum;\n        t[rt].cnt = t[lc(rt)].cnt + t[rc(rt)].cnt;\n    }\n    void build(int l, int r, int &rt) {\n        rt = ++tot;\n        if (l == r) return;\n        int mid = (l + r) >> 1;\n        build(l, mid, lc(rt));\n        build(mid + 1, r, rc(rt));\n        pushup(rt);\n    }\n    void update(int pos, int dcnt, int dsum, int l, int r, int old, int &rt) {\n        rt = ++tot;\n        t[rt] = t[old];\n        if (l == r) {\n            t[rt].cnt = t[old].cnt + dcnt;\n            t[rt].sum = t[old].sum + dsum;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        if (pos <= mid) update(pos, dcnt, dsum, l, mid, lc(old), lc(rt));\n        else update(pos, dcnt, dsum, mid + 1, r, rc(old), rc(rt));\n        pushup(rt);\n    }\n    int update(int pos, int dcnt, int dsum) { // return the root of the new version\n        int new_root;\n        update(pos, dcnt, dsum, 0, n - 1, roots.back(), new_root);\n        roots.push_back(new_root);\n        return new_root;\n    }\n    ll query(int v, int l, int r, int k) {\n        if (l == r)\n            return (t[v].cnt > k ? t[v].sum / t[v].cnt * k : t[v].sum);\n        int mid = (l + r) / 2, x = t[lc(v)].cnt;\n        ll sum = t[lc(v)].sum;\n        if (k <= x) return query(lc(v), l, mid, k);\n        return sum + query(rc(v), mid + 1, r, k - x);\n    }\n    ll query(int v, int k) { return query(v, 0, n - 1, k); }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, q;\n    cin >> n >> q;\n    vector<tuple<int, int, int>> tasks(n);\n    vector<int> p; // æ‰€æœ‰çš„ä¼˜å…ˆçº§ï¼Œç”¨äºç¦»æ•£åŒ–\n    for (auto &[s, e, pp] : tasks) {\n        cin >> s >> e >> pp;\n        p.push_back(pp);\n    }\n    sort(begin(p), end(p));\n    p.erase(unique(begin(p), end(p)), end(p)); // ç¦»æ•£åŒ–\n    vector<pair<int, int>> events;\n    for (auto [s, e, pp] : tasks) {\n        int id = lower_bound(begin(p), end(p), pp) - begin(p);\n        // ä¸¤ä¸ªäº‹ä»¶ï¼Œç”¨ä¼˜å…ˆçº§çš„æ­£è´Ÿæ¥è¡¨ç¤ºåŠ å…¥æˆ–è€…åˆ é™¤\n        events.emplace_back(s, id + 1);\n        events.emplace_back(e + 1, -id - 1);\n    }\n    sort(begin(events), end(events));\n    PST tr(size(p));\n    vector<int> roots(n + 1); // root[i]ä»£è¡¨iæ—¶åˆ»å‰æœ€æ–°çš„çº¿æ®µæ ‘çš„ç‰ˆæœ¬\n    roots[0] = 1;\n    for (auto [time, id] : events) {\n        if (id > 0) {\n            roots[time] = (tr.update(id - 1, 1, p[id - 1]));\n        } else {\n            id = -id - 1;\n            roots[time] = (tr.update(id, -1, -p[id]));\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        // å¯¹äºæ²¡æœ‰äº‹ä»¶å‘ç”Ÿçš„æ—¶åˆ»iï¼Œå…¶æœ€æ–°çš„ç‰ˆæœ¬ä¸ºä¸Šä¸€æ—¶åˆ»çš„æœ€æ–°ç‰ˆæœ¬\n        if (!roots[i]) roots[i] = roots[i - 1];\n    ll pre = 1;\n    while (q--) {\n        int x, a, b, c;\n        cin >> x >> a >> b >> c;\n        auto k = 1 + (a * pre + b) % c;\n        auto res = tr.query(roots[x], k);\n        cout << res << '\\n';\n        pre = res;\n    }\n}"},{"id":"NC5447C","title":"é¢˜è§£ Nowcoder 5447C - å¼ è€å¸ˆçš„æ—…è¡Œ","content":"é¢˜è§£è§‚å¯Ÿæ˜“çŸ¥ï¼Œè‹¥æƒ³ç”¨æœ€å°çš„æ—¶é—´è¦†ç›–ä¸€æ®µçº¿æ®µï¼Œé‚£ä¹ˆç»“æŸæ—¶çš„ä½ç½®ä¸€å®šåœ¨çº¿æ®µçš„å·¦ç«¯ç‚¹æˆ–å³ç«¯ç‚¹ã€‚é‚£ä¹ˆæˆ‘ä»¬çš„dpçŠ¶æ€å°±å¯ä»¥è®¾ä¸ºï¼Œä»£è¡¨è¦†ç›–ä»låˆ°rçš„çº¿æ®µæ‰€ç”¨çš„æœ€çŸ­æ—¶é—´å¹¶ä¸”ä»¥å·¦ç«¯ç‚¹ç»“å°¾ï¼ˆp=0ï¼‰ï¼Œå³ç«¯ç‚¹ç»“å°¾ï¼ˆp=1ï¼‰ã€‚çŠ¶æ€è½¬ç§»æ˜¯ä¸éš¾æƒ³çš„ï¼Œå¯ä»¥ç”±æˆ–å¾—åˆ°ï¼ŒåŒç†å¯ä»¥ç”±æˆ–å¾—åˆ°ï¼Œåˆ«å¿˜äº†åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦åœ¨è§„å®šçš„æ—¶é—´ä¹‹å†…ã€‚å…·ä½“è½¬ç§»çœ‹ä»£ç ï½Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N=1005;\nint dp[N][N][2];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> p(n+1),t(n+1);\n    ms(dp,INF);\n    for1(i,n){\n        cin>>p[i];\n        dp[i][i][0]=dp[i][i][1]=0;\n    }\n    for1(i,n) cin>>t[i];\n    for(int len=2;len<=n;len++){\n        for(int l=1;l+len-1<=n;l++){\n            int r=l+len-1;\n            int t1=min(dp[l+1][r][0]+p[l+1]-p[l],dp[l+1][r][1]+p[r]-p[l]);\n            int t2=min(dp[l][r-1][0]+p[r]-p[l],dp[l][r-1][1]+p[r]-p[r-1]);\n            if(t1<=t[l]) dp[l][r][0]=t1;\n            if(t2<=t[r]) dp[l][r][1]=t2;\n        }\n    }\n    int ans=min(dp[1][n][0],dp[1][n][1]);\n    cout<<(ans==INF?-1:ans);\n    return 0;\n}"},{"id":"NonPuzzle-Segment-Pair","title":"2023ç‰›å®¢å¤šæ ¡9 I - Non-Puzzle: Segment Pair é¢˜è§£","content":"é¦–å…ˆæˆ‘ä»¬è€ƒè™‘æŸä¸€ä¸ªç‚¹è¢«æ‰€æœ‰çº¿æ®µè¦†ç›–çš„æ–¹æ¡ˆæ•°ï¼šå¦‚æœä¸€å¯¹çº¿æ®µä¸­æœ‰åªæœ‰ä¸€æ¡çº¿æ®µèƒ½è¦†ç›–è¿™ä¸ªç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±åªèƒ½é€‰è¿™æ¡çº¿æ®µï¼Œå¦‚æœä¸¤æ¡çº¿æ®µéƒ½èƒ½è¦†ç›–è¿™ä¸ªç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥ä»»é€‰å…¶ä¸€ã€‚ä½†æ˜¯é¢˜ç›®è¦æ±‚çš„æ˜¯å­˜åœ¨ä¸€ä¸ªç‚¹è¢«æ‰€æœ‰çº¿æ®µè¦†ç›–ï¼Œå¦‚æœæˆ‘ä»¬å¯¹æ•°è½´ä¸Šçš„æ¯ä¸€ä¸ªç‚¹æ±‚æ–¹æ¡ˆæ•°çš„è¯ï¼Œå…¶ä¸­å¿…ç„¶æœ‰é‡å¤çš„æ–¹æ¡ˆï¼Œæˆ‘ä»¬è€ƒè™‘ä»€ä¹ˆæ ·çš„æƒ…å†µæ–¹æ¡ˆä¼šé‡å¤ã€‚ä¸éš¾å‘ç°ï¼Œå¯¹äºä¸¤ä¸ªç‚¹ï¼Œå¦‚æœè¦†ç›–ç¬¬ä¸€ä¸ªç‚¹çš„çº¿æ®µçš„é›†åˆä¸è¦†ç›–ç¬¬äºŒä¸ªç‚¹çš„çº¿æ®µçš„é›†åˆç›¸åŒçš„è¯ï¼Œè¿™ä¸¤ä¸ªç‚¹æ‰€å¯¹åº”çš„æ–¹æ¡ˆçš„é›†åˆæ˜¯ç›¸åŒçš„ã€‚åä¹‹ï¼Œè¿™ä¸¤ä¸ªç‚¹å¯¹åº”çš„æƒ…å†µæ˜¯ä¸åŒçš„ï¼Œå…·ä½“æ¥è¯´æœ‰ä¸¤ç§æƒ…å†µï¼šå­˜åœ¨ä¸€å¯¹çº¿æ®µï¼Œä¸€ä¸ªç‚¹åªè¢«å…¶ä¸­çš„ä¸€æ¡çº¿æ®µè¦†ç›–ï¼Œè€Œå¦ä¸€ä¸ªç‚¹åªè¢«å¦ä¸€æ¡çº¿æ®µè¦†ç›–ã€‚è¿™ä¸¤ä¸ªç‚¹æ‰€å¯¹åº”çš„æ–¹æ¡ˆçš„é›†åˆæ˜¯ä¸äº¤çš„ã€‚å¦åˆ™ï¼Œå­˜åœ¨ä¸€å¯¹çº¿æ®µï¼Œä¸€ä¸ªç‚¹åªè¢«å…¶ä¸­çš„ä¸€æ¡çº¿æ®µè¦†ç›–ï¼Œè€Œå¦ä¸€ä¸ªç‚¹åªè¢«ä¸¤æ¡çº¿æ®µè¦†ç›–ã€‚ä¸€ä¸ªç‚¹æ‰€å¯¹åº”çš„æ–¹æ¡ˆçš„é›†åˆæ˜¯å¦ä¸€ä¸ªç‚¹å¯¹åº”çš„é›†åˆçš„å­é›†ã€‚äºæ˜¯æˆ‘ä»¬åœ¨æ¯æ¬¡çº¿æ®µè¦†ç›–æƒ…å†µå˜åŒ–çš„æ—¶å€™è®¡ç®—å½“å‰çš„æ–¹æ¡ˆæ•°å¹¶åŠ å…¥åˆ°ç­”æ¡ˆä¸­ã€‚æˆ‘ä»¬å¯ä»¥æŠŠæ¯æ¡çº¿æ®µ  æ‹†æˆä¸¤ä¸ªäº‹ä»¶ï¼šåœ¨  å¤„çº¿æ®µè¦†ç›–å¼€å§‹åœ¨  å¤„çº¿æ®µè¦†ç›–ç»“æŸæˆ‘ä»¬å°†æ‰€æœ‰äº‹ä»¶æ’åºï¼Œä»å°åˆ°å¤§éå†å°±å¯ä»¥å¾—åˆ°æ‰€æœ‰çº¿æ®µè¦†ç›–çš„æƒ…å†µã€‚éå†çš„è¿‡ç¨‹ä¸­ç»´æŠ¤  ä¸ºä¸€å¯¹çº¿æ®µä¸­æœ‰  æ¡çº¿æ®µè¦†ç›–å½“å‰ç‚¹çš„çº¿æ®µå¯¹çš„æ•°é‡ã€‚æ³¨æ„åˆ°çº¿æ®µè¦†ç›–å˜åŒ–æœ‰å››ç§æƒ…å†µï¼šæœ‰ä¸€å¯¹çº¿æ®µä»é›¶æ¡è¦†ç›–å˜æˆäº†ä¸€æ¡è¦†ç›–ï¼Œæ­¤æ—¶å¦‚æœ  æˆ‘ä»¬åº”æŠŠç­”æ¡ˆåŠ ä¸Š æœ‰ä¸€å¯¹çº¿æ®µä»ä¸€æ¡è¦†ç›–å˜æˆäº†ä¸¤æ¡è¦†ç›–ï¼Œè¿˜è®°å¾—æˆ‘ä»¬ä¸Šé¢è¯´çš„ç¬¬äºŒç§æƒ…å†µå—ï¼Ÿç”±äºå­é›†çš„æ–¹æ¡ˆæ•°å·²ç»åŠ åˆ°ç­”æ¡ˆé‡Œäº†ï¼Œæ­¤æ—¶å¦‚æœ  æˆ‘ä»¬åº”æŠŠç­”æ¡ˆåŠ ä¸Š æœ‰ä¸€å¯¹çº¿æ®µä»ä¸¤æ¡è¦†ç›–å˜æˆäº†ä¸€æ¡è¦†ç›–ï¼Œç­”æ¡ˆå·²ç»è®¡ç®—è¿‡äº†ï¼Œè·³è¿‡æœ‰ä¸€å¯¹çº¿æ®µä»ä¸€æ¡è¦†ç›–å˜æˆäº†é›¶æ¡è¦†ç›–ï¼Œä¸ç¬¦åˆè¢«æ‰€æœ‰çº¿æ®µè¦†ç›–çš„æ¡ä»¶ï¼Œè·³è¿‡#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n\n    constexpr int mod = 1e9 + 7;\n    vector<int> pw(n + 1);\n    pw[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        pw[i] = pw[i - 1] * 2 % mod;\n    }\n\n    vector<array<int, 3>> a;\n    for (int i = 0; i < n; i++) {\n        int l1, r1, l2, r2;\n        cin >> l1 >> r1 >> l2 >> r2;\n        a.push_back({l1, 1, i});\n        a.push_back({r1 + 1, -1, i});\n        a.push_back({l2, 1, i});\n        a.push_back({r2 + 1, -1, i});\n    }\n\n    sort(begin(a), end(a));\n\n    array<int, 3> num{n, 0, 0}; // é¢˜è§£é‡Œæåˆ°çš„\n    vector<int> cnt(n); // æ¯ä¸€å¯¹çº¿æ®µä¸­å½“å‰æœ‰å‡ æ¡è¦†ç›–\n    int ans = 0;\n\n    for (auto [x, f, i] : a) {\n        num[cnt[i]]--;\n        cnt[i] += f;\n        num[cnt[i]]++;\n\n        if (f == 1 && num[0] == 0) {\n            if (cnt[i] == 2) { // ä»ä¸€æ¡è¦†ç›–å˜æˆä¸¤æ¡è¦†ç›–\n                ans = (ans + pw[num[2] - 1]) % mod;\n            } else { // ä»é›¶æ¡è¦†ç›–å˜æˆä¸€æ¡è¦†ç›–\n                ans = (ans + pw[num[2]]) % mod;\n            }\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}"},{"id":"PBDS_basic_usage","title":"PB_DSçš„åŸºç¡€ç”¨æ³•","content":"Policy-Based Data Structure(PB_DS)çš„åŸºç¡€ç”¨æ³•å“ˆå¸Œè¡¨ç”¨æ³•#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ncc_hash_table<int, int> table;//collision-chaining hash table\ngp_hash_table<int, int> table;//probing hash tableå¯ä»¥åƒä¸€æ ·ç”¨ã€‚ç¨å¾®å¥½ä¸€ç‚¹çš„å“ˆå¸Œå‡½æ•°struct custom_hash {\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        x ^= FIXED_RANDOM;\n        return x ^ (x >> 16);\n    }\n};æ— æ•Œå“ˆå¸Œå‡½æ•°struct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};å¹³è¡¡æ ‘å£°æ˜å¤´æ–‡ä»¶#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;ç”¨ä½œtree<int, int, less<int>, rb_tree_tag, tree_order_statistics_node_update> t;ç”¨ä½œtree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> t;ç”¨ä½œtree<pair<int,int>, null_type, less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> t;ä¹Ÿå¯ä»¥ç”¨ï¼Œä½† å’Œ  å‡½æ•°ä¼šäº¤æ¢åŠŸèƒ½å¹¶ä¸”ä¼šå¤±æ•ˆï¼Œæ‰€ä»¥è°¨æ…ä½¿ç”¨ã€‚tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> t;æ¯”æ›´å¼ºçš„åŠŸèƒ½ï¼šæ’åå¿…é¡»åœ¨å£°æ˜é‡Œç”¨ä»¥è·å¾—ä¸æ’åç›¸å…³çš„åŠŸèƒ½:size_type order_of_key(key_const_reference);// è¿”å›æ¯”keyå°çš„å…ƒç´ çš„ä¸ªæ•°\niterator find_by_order(size_type order) // è¿”å›æ’åä¸ºorderçš„å…ƒç´ çš„è¿­ä»£å™¨ï¼Œæ’åä»0å¼€å§‹e.g. æ±‚é€†åºå¯¹#include <bits/extc++.h>\nusing namespace std;\nusing namespace __gnu_pbds;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    // æ³¨æ„æ­¤å¤„ç”¨äº†less_equalä»¥å…è®¸é‡å¤çš„å…ƒç´ \n    tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> st;\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto& x : a) cin >> x;\n    long long ans=0;\n    for (int i=n-1; i>=0; i--) {\n        ans += st.order_of_key(a[i]);\n        st.insert(a[i]);\n    }\n    cout << ans << '\\n';\n}ä½¿ç”¨  å’Œ  æ‰¾å‰é©±å’Œåç»§å‰é©±ï¼š*prev(t.lower_bound(x))//set\nprev(t.lower_bound({x,0}))->first//multi-setåç»§ï¼š*t.upper_bound(x);//set\n*t.lower_bound({x+1,0});ä¼˜å…ˆé˜Ÿåˆ—åŸå‹template<typename  Value_Type,\n\t  typename  Cmp_Fn = std::less<Value_Type>,\n\t  typename  Tag = pairing_heap_tag,\n\t  typename  Allocator = std::allocator<char > >\n\t  class priority_queue;ç”¨æ³•é»˜è®¤çš„æ¨¡æ¿å‚æ•°å°±æ˜¯æ€§èƒ½æœ€å¥½çš„ï¼Œæ³¨æ„å¿…é¡»è¦å¸¦ä¸Šå‘½åç©ºé—´ä»¥åŒºåˆ†ã€‚#include<ext/pb_ds/priority_queue.hpp>\n__gnu_pbds::priority_queue<int>;æ‰€æœ‰çš„5ç§tag:å’Œ çš„ä¸åŒä¹‹å¤„point_iterator push(const_reference r_val); //pushä¼šè¿”å›æŒ‡å‘æ’å…¥åå…ƒç´ çš„pointè¿­ä»£å™¨ï¼ˆå’Œéå†è¿­ä»£å™¨ä¸ä¸€æ ·ï¼‰\nvoid PB_DS_CLASS_C_DEC:: join(PB_DS_CLASS_C_DEC& other) //åˆå¹¶ä¸¤ä¸ªå †åŒæ—¶æ¸…ç©ºother\nvoid split(Pred prd,priority_queue &other) // æ ¹æ®prdå‡½æ•°çš„è¿”å›å€¼ï¼ˆtrueæˆ–falseï¼‰åˆ†è£‚ä¸¤ä¸ªå †\nvoid modify(point_iterator it,const key) // æŸäº›å †æ”¯æŒå¿«é€Ÿä¿®æ”¹å †ä¸­çš„å…ƒç´ ï¼Œæ¯”å¦‚ç”¨åœ¨dijkstraä¸­\nbegin();\nend();//begin å’Œ end è¿­ä»£å™¨å‚è€ƒèµ„æ–™Policy-Based Data StructureBlowing up unordered_map, and how to stop getting hacked on itpb_dsåº“çš„ä¸€äº›å¸¸ç”¨æ–¹æ³•ç”¨ pbds è¿‡ luogu P3369ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘"},{"id":"PBreconstruction","title":"12.42 PB å¤ç›˜","content":"è§£æ³•åŠ¨ç”»æ‰“ä¹±L2 R2 U L2 B2 F2 U R2 D' U' F' R F2 D B2 D2 B' F' L Bè§£æ³•y' //inspectionF' D' F2 U R B' //FBr' U' r' U2 r U M r' U' r M' U' R U R' U' R U R' //SBU' R U R' U' R' F R F' //CMLLM' U M2' U' M U2 M' U M U2 M' U2 //LSE46 ETM, 3.7 TPS"},{"id":"SWERC2017E","title":"SWERC2017 E - Ingredients é¢˜è§£","content":"ç«Ÿç„¶ä¸€æ¬¡å°±è¿‡äº†Linkms(cost,INF);\nqueue<int> q;\nfor1(i,id.size()){\n\tif(deg[i]==0){\n\t\tq.push(i);\n\t\tcost[i]=0;\n\t}\n}\nwhile(!empty(q)){\n\tint now=q.front();\n\tq.pop();\n\tfor(auto [dish,cost,prestige]:G[now]){\n\t\tif(cost[now]+cost<cost[dish]){//choose the smallest cost\n\t\t\tcost[dish]=cost[now]+cost;\n\t\t\tpre[\n\t\t}else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige\n\t\t\tpre[dish]=max(pre[dish],pre[now]+prestige);\n\t\t}\n\t\tdeg[dish]--;\n\t\tif(deg[dish]==0) q.push(dish);\n\t}\n}The nest part is more familiar: using 0/1 knapsack algorithm to find the answer.é¢˜è§£è¿™ä¸ªé¢˜ç»“åˆäº†æœ€çŸ­è·¯å’Œ0/1èƒŒåŒ…ç®—æ³•ã€‚ç¬¬ä¸€æ­¥æ˜¯æ‰¾åˆ°æ‰€æœ‰èœå“çš„æœ€å°èŠ±è´¹ï¼Œä¹Ÿå°±æ˜¯DAGä¸Šçš„æœ€çŸ­è·¯ã€‚è¿™ä¸ªå¯ä»¥ç”¨æ‹“æ‰‘æ’åºåœ¨çš„æ—¶é—´å†…è§£å†³ï¼Œå…·ä½“å®ç°çœ‹ä¸Šé¢çš„ä»£ç è§£é‡Šã€‚ç¬¬äºŒæ­¥å°±æ˜¯éå¸¸æ ‡å‡†çš„0/1èƒŒåŒ…äº†ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\n\nconst int N=1e4+5;\nvector<tuple<int,int,int>> G[N];\nint cost[N],pre[N],deg[N],dp[N];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n,b;\n\tcin>>b>>n;\n\tunordered_map<string,int> id;\n\tauto getid=[&](string& st){\n\t\tif(id[st]) return id[st];\n\t\telse return id[st]=size(id);\n\t};\n\tforn(i,n){\n\t\tstring s,t,tmp;\n\t\tint x,y;\n\t\tcin>>s>>t>>tmp>>x>>y;\n\t\tint ids=getid(s),idt=getid(t);\n\t\tG[idt].eb(ids,x,y);\n\t\tdeg[ids]++;\n\t}\n    //topo sort\n\tms(cost,INF);\n\tqueue<int> q;\n\tfor1(i,id.size()){\n\t\tif(deg[i]==0){\n\t\t\tq.push(i);\n\t\t\tcost[i]=0;\n\t\t}\n\t}\n\twhile(!empty(q)){\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(auto [to0,to1,to2]:G[now]){\n\t\t\tif(cost[now]+to1<cost[to0]){\n\t\t\t\tcost[to0]=cost[now]+to1;\n\t\t\t\tpre[to0]=pre[now]+to2;\n\t\t\t}else if(cost[now]+to1==cost[to0]){\n\t\t\t\tpre[to0]=max(pre[to0],pre[now]+to2);\n\t\t\t}\n\t\t\tdeg[to0]--;\n\t\t\tif(deg[to0]==0) q.push(to0);\n\t\t}\n\t}\n    //knapsack\n\tfor1(i,size(id)){\n\t\tfor(int j=b;j>=cost[i];j--){\n\t\t\tdp[j]=max(dp[j],dp[j-cost[i]]+pre[i]);\n\t\t}\n\t}\n\tint ans1=0,ans2=0;\n\tfor(int i=0;i<=b;i++){\n\t\tif(dp[i]>ans1){\n\t\t\tans1=dp[i];\n\t\t\tans2=i;\n\t\t}\n\t}\n\tcout<<ans1<<endl<<ans2;\n\treturn 0;\n}"},{"id":"abc207e","title":"AtCoder Beginner Contest(ABC) 207E - Mod ié¢˜è§£","content":"æ–¹æ³•ä¸€ä¸€ç§ç®€å•çš„dpæ˜¯ä»¤ä¸ºå°†å‰ä¸ªæ•°åˆ†æˆä¸ªå­æ•°ç»„çš„åˆ†æ³•çš„ä¸ªæ•°ã€‚æ¬¡è½¬ç§»è¦éå†å‰çš„æ¯ä¸ªä½ç½®ç„¶åå‰ç¼€å‰ç¼€å’Œåˆ¤æ–­æ˜¯å¦æ˜¯çš„å€æ•°ï¼Œå¦‚æœæ˜¯çš„è¯å°±åŠ ä¸Šï¼Œæ‰€ä»¥è½¬ç§»æ˜¯ çš„ï¼Œæ€»çš„å¤æ‚åº¦æ˜¯ï¼Œä¼šTLEï¼Œäºæ˜¯æˆ‘ä»¬æƒ³å¦‚ä½•ä¼˜åŒ–ã€‚è€ƒè™‘åˆ° ä¹Ÿè®¸æˆ‘ä»¬ä¸ç”¨éå†æ‰€æœ‰çš„ï¼Œåªè¦è®°å½•å¯¹äºæ¯ä¸ªä½ç½®, çš„çš„å’Œå°±è¡Œäº†ã€‚äºæ˜¯æˆ‘ä»¬çš„çŠ¶æ€çš„å®šä¹‰å°±å˜æˆäº†åœ¨kä½ç½®ç»“æŸçš„å­æ•°ç»„,åˆ†æˆä¸ªå­æ•°ç»„å¹¶ä¸”çš„åˆ†æ³•çš„ä¸ªæ•°ã€‚ï¼ˆè¯´å®è¯ä¸æ˜¯å¾ˆå¥½ç†è§£ï¼‰#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <int MOD> struct ModInt {\n    int val;\n    // constructor\n    ModInt(ll v = 0) : val(int(v % MOD)) {\n        if (val < 0) val += MOD;\n    };\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n    // arithmetic\n    ModInt operator+(const ModInt &x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt &x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt &x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt &x) const { return ModInt(*this) /= x; }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    // compound assignment\n    ModInt &operator+=(const ModInt &x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &x) {\n        val = int(ll(val) * x.val % MOD);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &x) { return *this *= x.inv(); }\n    // compare\n    bool operator==(const ModInt &b) const { return val == b.val; }\n    bool operator!=(const ModInt &b) const { return val != b.val; }\n    // I/O\n    friend std::istream &operator>>(std::istream &is, ModInt &x) noexcept { return is >> x.val; }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<int(1e9 + 7)>;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<ll> a(n), sum(n + 1);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        sum[i + 1] = sum[i] + a[i];\n    }\n    vector dp(n + 2, vector<mint>(n + 2));\n    dp[1][0] += 1;\n    mint ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = n; j >= 1; j--) {\n            dp[j + 1][sum[i + 1] % (j + 1)] += dp[j][sum[i + 1] % j];\n            if (i == n - 1) ans += dp[j][sum[n] % j];\n        }\n    }\n    cout << ans << '\\n';\n}æ–¹æ³•äºŒè¿™ç§æ–¹æ³•å’Œæ–¹æ³•ä¸€çš„å‡ºå‘ç‚¹ä¸€æ ·ï¼Œä½†è½¬ç§»çš„æ—¶å€™æˆ‘ä»¬åªè€ƒè™‘æœ€å¤§çš„k,è¿™æ˜¯å› ä¸ºä¸¤ä¸ªå’Œä¸ºçš„çš„å€æ•°çš„å­æ•°ç»„æ‹¼èµ·æ¥å’Œä¾ç„¶æ˜¯çš„å€æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¿æŒä¸€å¼€å§‹çš„dpçŠ¶æ€å®šä¹‰ï¼Œç„¶åç”¨çš„æ—¶é—´é¢„å¤„ç†å‡ºï¼Œå³å¯¹äºæ¯ä¸ªä½ç½®ï¼Œå…¶å·¦è¾¹ç¬¬ä¸€ä¸ªä½ç½®ä½¿å¾—ï¼Œè½¬ç§»æ—¶è€ƒè™‘ä¸¤ç§æƒ…å†µï¼špreçš„ä½ç½®è¢«åˆ†æˆäº†æˆ–ä¸ªå­æ•°ç»„ã€‚#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate <int MOD> struct ModInt {\n    int val;\n    // constructor\n    ModInt(ll v = 0) : val(int(v % MOD)) {\n        if (val < 0) val += MOD;\n    };\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n    // arithmetic\n    ModInt operator+(const ModInt &x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt &x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt &x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt &x) const { return ModInt(*this) /= x; }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    // compound assignment\n    ModInt &operator+=(const ModInt &x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &x) {\n        val = int(ll(val) * x.val % MOD);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &x) { return *this *= x.inv(); }\n    // compare\n    bool operator==(const ModInt &b) const { return val == b.val; }\n    bool operator!=(const ModInt &b) const { return val != b.val; }\n    // I/O\n    friend std::istream &operator>>(std::istream &is, ModInt &x) noexcept { return is >> x.val; }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<int(1e9 + 7)>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    for (auto &x : a)\n        cin >> x;\n    vector pre(n, vector(n + 1, -1));\n    vector last(n + 1, vector(n, -1));\n    ll sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += a[i];\n        for (int j = 1; j <= n; j++) {\n            pre[i][j] = last[j][sum % j];\n            last[j][sum % j] = i;\n        }\n    }\n    vector dp(n, vector<mint>(n + 1));\n    dp[0][1] = 1;\n    for (int i = 1; i < n; i++) {\n        for (int j = 1; j <= n; j++) {\n            int p = pre[i][j];\n            if (p != -1) { dp[i][j] = dp[p][j] + dp[p][j - 1]; }\n        }\n    }\n    cout << accumulate(dp[n - 1].begin(), dp[n - 1].end(), mint()) << '\\n';\n}"},{"id":"abc274g","title":"AtCoder Beginner Contest 274 G - Security Camera 3","content":"ä¸éš¾å‘ç°å¯¹äºä¸€è¡Œæˆ–ä¸€åˆ—ä¸­è¿ç»­çš„æ–¹å—ï¼Œæˆ‘ä»¬åªéœ€è¦æœ€å¤šä¸€ä¸ªæ‘„åƒå¤´ï¼Œä¸å¦¨è®©æ‘„åƒå¤´æ”¾ç½®åœ¨ä¸€è¡Œçš„æœ€å·¦è¾¹æˆ–è€…ä¸€åˆ—çš„æœ€ä¸Šé¢ã€‚å¯¹äºæ¯ä¸€ä¸ªæ–¹å—ï¼Œå®ƒè¦è¢«ä»¥ä¸‹è‡³å°‘ä¸€ä¸ªä½ç½®çš„æ‘„åƒå¤´ç›‘æ§åˆ°ï¼šè¿™ä¸ªæ–¹å—ä¸Šé¢æœ€åä¸€ä¸ªééšœç¢çš„æ–¹å—è¿™ä¸ªæ–¹å—å·¦è¾¹æœ€åä¸€ä¸ªééšœç¢çš„æ–¹å—å¦‚æœæˆ‘ä»¬æŠŠå¯èƒ½çš„æ‘„åƒå¤´çš„ä½ç½®çœ‹æˆç‚¹ï¼ˆæ¯ä¸€ä¸ªæ–¹å—è¢«çœ‹æˆä¸¤ä¸ªç‚¹ï¼Œå‘å³çœ‹çš„æ‘„åƒå¤´å’Œå‘ä¸‹çœ‹çš„æ‘„åƒå¤´ï¼‰ï¼Œæ¯ä¸€ä¸ªæ–¹å—çœ‹æˆä¸€æ¡è¾¹ï¼ˆè¿æ¥ä¸Šé¢æåˆ°çš„ä¸¤ä¸ªä½ç½®çš„æ‘„åƒå¤´ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªé—®é¢˜å°±å˜æˆäº†äºŒåˆ†å›¾çš„æœ€å°ç‚¹è¦†ç›–é—®é¢˜ï¼Œä¹Ÿå°±ç­‰ä»·äºæœ€å¤§åŒ¹é…é—®é¢˜ã€‚ä»£ç ï¼š#include <bits/stdc++.h>\nstruct aug_path {\n    std::vector<std::vector<int>> g;\n    std::vector<int> L, R, vis;\n    aug_path(int n, int m) : g(n), L(n, -1), R(m, -1), vis(n) {}\n    void add_edge(int a, int b) { g[a].push_back(b); }\n    bool match(int u) {\n        if (vis[u]) return false;\n        vis[u] = true;\n        for (auto v : g[u]) {\n            if (R[v] == -1) {\n                L[u] = v;\n                R[v] = u;\n                return true;\n            }\n        }\n        for (auto vec : g[u]) {\n            if (match(R[vec])) {\n                L[u] = vec;\n                R[vec] = u;\n                return true;\n            }\n        }\n        return false;\n    }\n    template<bool to_shuffle = false>\n    int solve() {\n        std::vector<int> order;\n        if constexpr (to_shuffle) {\n            std::mt19937 rng(1);\n            for (auto& v : g)\n                shuffle(v.begin(), v.end(), rng);\n            order.resize(L.size());\n            iota(order.begin(), order.end(), 0);\n            shuffle(order.begin(), order.end(), rng);\n        }\n        bool ok = true;\n        while (ok) {\n            ok = false;\n            fill(vis.begin(), vis.end(), 0);\n            if constexpr (to_shuffle) {\n                for (auto i : order) {\n                    if (L[i] == -1) ok |= match(i);\n                }\n            } else {\n                for (int i = 0; i < (int)L.size(); ++i) {\n                    if (L[i] == -1) ok |= match(i);\n                }\n            }\n        }\n        int ret = 0;\n        for (size_t i = 0; i < L.size(); ++i)\n            ret += (L[i] != -1);\n        return ret;\n    }\n};\nusing namespace std;\nusing ll = long long;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<string> a(n);\n    for (auto& s : a) {\n        cin >> s;\n    }\n    vector top(n, vector(m, 0));\n    auto left(top);\n    aug_path g(n * m, n * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (a[i][j] == '#') continue;\n            if (i == 0 || a[i - 1][j] == '#') {\n                top[i][j] = i;\n            } else {\n                top[i][j] = top[i - 1][j];\n            }\n            if (j == 0 || a[i][j - 1] == '#') {\n                left[i][j] = j;\n            } else {\n                left[i][j] = left[i][j - 1];\n            }\n            g.add_edge(top[i][j] * m + j, i * m + left[i][j]);\n        }\n    }\n    cout << g.solve() << '\\n';\n    return 0;\n}"},{"id":"add-arithmetic-progression","title":"åŒºé—´åŠ ç­‰å·®æ•°åˆ—","content":"é¡¾åæ€ä¹‰ï¼Œå°±æ˜¯åœ¨åŒºé—´ä¸ŠåŠ ä¸Šé¦–é¡¹ä¸ºï¼Œå…¬å·®ä¸ºçš„ç­‰å·®æ•°åˆ—ã€‚åˆ†ä¸ºä»¥ä¸‹è¿™ä¹ˆä¸‰ç±»æƒ…å†µï¼šå…ˆåŠ åè¯¢é—®å³å…ˆåŠ ï¼Œæœ€åå†è¾“å‡ºæ•´ä¸ªæ•°ç»„ï¼Œæˆ–è€…è¯¢é—®çš„ä½ç½®å’Œä¿®æ”¹çš„å·¦ç«¯ç‚¹æ˜¯æœ‰åºçš„ã€‚è¿™ç§æƒ…å†µæˆ‘ä»¬ä¸éœ€è¦å€ŸåŠ©å…¶ä»–æ•°æ®ç»“æ„ï¼Œæœ‰ä»¥ä¸‹ä¸¤ç§æ€è·¯ï¼šé æ€ç»´æˆ‘ä»¬å…ˆå›é¡¾ä¸€ä¸‹åŒºé—´åŠ åŒæ ·çš„æ•°æ˜¯æ€ä¹ˆåšçš„ï¼Œæˆ‘ä»¬ç»´æŠ¤å½“å‰åŠ åœ¨åŸæ•°ç»„ä¸Šçš„å€¼ï¼Œå¹¶ç”¨ä¸€ä¸ªæ•°ç»„æ ‡è®°ç»´æŠ¤çš„å€¼åœ¨ä½ç½®è¯¥å¦‚ä½•å˜åŒ–ï¼Œæ¯”å¦‚è¯´ç»™åŠ ä¸Šï¼Œæˆ‘ä»¬ä»¤ï¼Œè¿™æ ·ä¸­çš„æ•°éƒ½ä¼šåŠ ï¼Œç„¶åä½ç½®è¿˜åŸã€‚åŠ ç­‰å·®æ•°åˆ—å°±æ˜¯ä¸Šè¿°æ€è·¯çš„æ‰©å±•ï¼Œæˆ‘ä»¬ä¸ä»…ç»´æŠ¤å½“å‰åŠ åœ¨åŸæ•°ç»„ä¸Šçš„å€¼ï¼Œè¿˜ç»´æŠ¤å½“å‰çš„å…¬å·®ï¼Œä»¥åŠç”¨ä¸¤ä¸ªæ•°ç»„å’Œæ ‡è®°ä¸¤ä¸ªç»´æŠ¤çš„å€¼çš„å˜åŒ–ã€‚å½“åŠ ä¸€ä¸ªç­‰å·®æ•°åˆ—æ—¶ï¼Œæˆ‘ä»¬åœ¨å¤„æ ‡è®°ä»£è¡¨ä»å¤„å¼€å§‹å…¬å·®åŠ ï¼Œåœ¨å¤„æ ‡è®°ä»¥å¤åŸå…¬å·®ã€‚ä¹Ÿéœ€è¦ç±»ä¼¼çš„æ ‡è®°ï¼šåœ¨å¤„æ ‡è®°ï¼Œåœ¨å¤„æ ‡è®°ã€‚æ€»ç»“ä¸€ä¸‹ï¼šauto add = [&](int l, int r, int k, int d) {  \n    cur_add[l] += k;\n    cur_add[r+1] -= k + (r - l + 1) * d;\n\n    inc_add[l] += d;\n    inc_add[r+1] -= d;\n}\n\nauto update_current_position = [&](int i) {\n    cur += cur_add[i];\n    inc += inc_add[i];\n    cur += inc;\n}é æ•°å­¦åˆ†æä¸€ä¸‹å·®åˆ†æ•°ç»„ä¸‹æ ‡åŸæ•°ç»„$ä¸€é˜¶å·®åˆ†$äºŒé˜¶å·®åˆ†$ä¸éš¾çœ‹å‡ºäºŒé˜¶å·®åˆ†æ•°ç»„ä¸Šäº§ç”Ÿäº†å››æ¬¡å•ç‚¹ä¿®æ”¹ã€‚æ‰€ä»¥æˆ‘ä»¬å…ˆåœ¨äºŒé˜¶å·®åˆ†æ•°ç»„ä¸Šä¿®æ”¹æœ€åå†è·‘ä¸¤æ¬¡å‰ç¼€å’Œå³å¯å¾—åˆ°æœ€åçš„æ•°ç»„ã€‚æ”¾ä¸ªä¾‹é¢˜CF1661D#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    vector<ll> a(n);\n    vector<ll> inc_add(n), sum_add(n);\n    for (auto &x : a)\n        cin >> x;\n\n    ll cur = 0, inc = 0, ans = 0;\n\n    for (int i = n - 1; i >= 0; i--) {\n        inc += inc_add[i];\n        cur += sum_add[i];\n        cur += inc;\n        auto x = a[i] + cur;\n        if (x > 0) {\n            int len = min(k, i + 1);\n            auto need = (x + len - 1) / len;\n            ans += need;\n            cur -= need * len;\n            inc += need;\n            if (i - len >= 0) {\n                inc_add[i-len] -= need;\n                sum_add[i-len] += need;\n            }\n        }\n    }\n    cout << ans << endl;\n}åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢æ­¤æ—¶æˆ‘ä»¬å°±éœ€è¦æ•°æ®ç»“æ„ç»´æŠ¤å·®åˆ†æ•°ç»„äº†ç»´æŠ¤ä¸€é˜¶å·®åˆ†æ•°ç»„è§‚å¯Ÿä¸Šé¢ä¸€é˜¶å·®åˆ†å¯ä»¥å‘ç°æœ‰ä¸¤ä¸ªå•ç‚¹ä¿®æ”¹ä¸€ä¸ªåŒºé—´ä¿®æ”¹ï¼Œæ˜¯ä¸€é˜¶å·®åˆ†çš„å‰ç¼€å’Œï¼Œæ‰€ä»¥ç”¨åŒºé—´ä¿®æ”¹åŒºé—´æŸ¥è¯¢çš„æ•°æ®ç»“æ„å³å¯ï¼ˆçº¿æ®µæ ‘ï¼Œæ ‘çŠ¶æ•°ç»„ï¼‰ç»´æŠ¤äºŒé˜¶å·®åˆ†æ•°ç»„æˆ‘ä»¬éœ€è¦å•ç‚¹ä¿®æ”¹ç„¶åäºŒé˜¶å‰ç¼€å’Œï¼ŒäºŒé˜¶å‰ç¼€å’Œå¯ä»¥æ‹†æˆä¸¤ä¸ªå‰ç¼€å’Œï¼šç»´æŠ¤å’Œçš„å‰ç¼€å’Œå³å¯ã€‚ä¾‹é¢˜ï¼šæ´›è°·P1438 æ— èŠçš„æ•°åˆ—#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (auto& x : a) cin >> x;\n\n    vector<int64_t> t1(n + 1), t2(n + 1); \n    auto add = [&](int idx, int x) {\n        for (int i = idx; i <= n; i += i&-i) {\n            t1[i] += x;\n            t2[i] += (int64_t)idx * x;\n        }\n    };\n    auto sum = [&](int idx) {\n        int64_t res = 0;\n        for (int i = idx; i > 0; i -= i&-i) {\n            res += (idx + 1) * t1[i] - t2[i];\n        }\n        return res;\n    };\n\n    while (m--) {\n        int op;\n        cin >> op;\n        if (op == 1) {\n            int l, r, k, d;\n            cin >> l >> r >> k >> d;\n            int len = r - l + 1;\n            add(l, k);\n            add(l + 1, d - k);\n            add(r + 1, -(k + len * d));\n            add(r + 2, k + (len-1)*d);\n        } else {\n            int i;\n            cin >> i;\n            cout << sum(i) + a[i-1] << '\\n';\n        }\n    }\n}åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢è¦æ˜¯æä¸‰é˜¶å‰ç¼€å’Œé‚£å¯èƒ½ç•¥æ˜¾éº»çƒ¦äº†ï¼Œæˆ‘ä»¬ä¸å¦¨è½¬å˜æ€è·¯ç”¨çº¿æ®µæ ‘ï¼Œå…¶å®ä¸æ­£å¸¸çš„åŒºé—´åŠ ç±»ä¼¼ï¼Œæ‡’æƒ°æ ‡è®°å˜æˆäº†è¿™ä¸ªåŒºé—´åŠ çš„ç­‰å·®æ•°åˆ—çš„é¦–é¡¹å’Œå…¬å·®ã€‚"},{"id":"arc076d","title":"AtCoder Regular Contest (ARC) 076F - Exhausted? é¢˜è§£","content":"å‰ç½®çŸ¥è¯†ï¼šéœå°”å®šç†ï¼ˆHall's Theorem)ä¹Ÿå«éœå°”ç»“å©šå®šç†(Hall's marriage theorem)ã€‚åœ¨äºŒåˆ†å›¾ä¸­ï¼Œä»¤ä¸¤éƒ¨åˆ†ç‚¹é›†åˆ†åˆ«ä¸º, åˆ™å­˜åœ¨å®Œç¾åŒ¹é…ï¼ˆä¸­çš„ç‚¹é›†å…¨éƒ¨è¢«åŒ¹é…ï¼‰çš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯:å¯¹äºçš„ä»»æ„å­é›†,ï¼Œå…¶ä¸­ä¸ºä¸ç›´æ¥ç›¸è¿çš„ç‚¹çš„é›†åˆã€‚é¢˜è§£æœ¬é¢˜æ˜¯è®©æˆ‘ä»¬æ±‚æœ€å¤§åŒ¹é…æ•°ï¼Œä½†ç›´æ¥è·‘åŒ¹é…ç®—æ³•è‚¯å®šä¸åˆé€‚ï¼Œæ­¤æ—¶æˆ‘ä»¬è€ƒè™‘éœå°”å®šç†ï¼šå‡è®¾æ‰€æœ‰äººçš„é›†åˆä¸º,æˆ‘ä»¬è‡³å°‘è¿˜éœ€è¦ã€‚ä½†æ˜¯çš„å­é›†çš„ä¸ªæ•°æ˜¯æŒ‡æ•°çº§çš„æ‰€ä»¥ä¸èƒ½ç›´æ¥è€ƒè™‘å­é›†ã€‚ä½†æ˜¯æˆ‘ä»¬å‘ç°æ€»æ˜¯æ‰€æœ‰æ¤…å­çš„ä¸€ä¸ªå‰ç¼€åŠ ä¸€ä¸ªåç¼€ï¼Œä¹Ÿå°±æ˜¯ã€‚äºæ˜¯æˆ‘ä»¬å¯ä»¥è€ƒè™‘æšä¸¾ï¼Œé‚£ä¹ˆæ¤…å­çš„é›†åˆæ‰€å¯¹åº”çš„äººçš„é›†åˆä¸º,æ­¤æ—¶ã€‚ä½†å¾ˆæ˜¾ç„¶çš„ä¸ªæ•°æ˜¯çš„ï¼Œè¿˜æ˜¯å¤ªæ…¢ï¼Œä¸è¿‡è¿™å·²ç»æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„è¿›æ­¥äº†ã€‚æˆ‘ä»¬å†æƒ³è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Œä»å°åˆ°å¤§æšä¸¾ï¼Œé€šè¿‡æŸäº›æ•°æ®ç»“æ„ç›´æ¥æ±‚å¾—æ‰€æœ‰ä¸­çš„æœ€å¤§å€¼ï¼šæˆ‘ä»¬å¯ä»¥ç”¨çº¿æ®µæ ‘ç»´æŠ¤å¯¹äºæ¯ä¸€ä¸ª,çš„æœ€å¤§å€¼ã€‚å¯¹äºæ¯ä¸€ä¸ªäººçš„é™åˆ¶æ¡ä»¶ï¼Œå½“æˆ‘ä»¬æšä¸¾åˆ°æ—¶ï¼Œå¦‚æœé€‰æ‹©çš„çš„è¯ï¼Œé‚£ä¹ˆå¯¹åº”çš„äººçš„é›†åˆå°±ä¼šåŒ…å«ï¼Œåæ˜ åˆ°ç»´æŠ¤çš„å€¼ä¸Šå»çš„è¯å°±æ˜¯æŠŠåŒºé—´é‡Œçš„å€¼+1ã€‚ç„¶åç”¨ä¸­çš„æœ€å¤§å€¼å‡å½“å‰çš„æ¥æ›´æ–°ç­”æ¡ˆã€‚æ³¨æ„å‡ ç‚¹ï¼šæŒ‰lä»å°åˆ°å¤§çš„é¡ºåºå¯ä»¥ä¿è¯å‰é¢çš„éƒ½æ˜¯ç¬¦åˆæ¡ä»¶çš„ï¼Œåªè¦è€ƒè™‘çš„å–å€¼å³å¯ã€‚ç»´æŠ¤çš„å€¼æ˜¯æŠŠé™¤å»çš„ï¼Œå› ä¸ºæˆ‘ä»¬åªè€ƒè™‘ çš„å–å€¼ã€‚æ¯ä¸ªä½ç½®çš„éƒ½æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥å»ºæ ‘çš„æ—¶å€™å°±å¯ä»¥åŠ è¿›å»ã€‚ç‰¹æ®Šæƒ…å†µå½“ä¸ºæ•´ä¸ªæ¤…å­çš„é›†åˆæ—¶ï¼Œä»£ç #include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> struct SegTree {\n    int n, M;\n    vector<T> t;\n    SegTree(int n_, int _m) : n(n_), M(_m), t(4 * n) {\n        build(1, 0, n - 1);\n    }\n    void pull(int node) { t[node] = t[node * 2] + t[node * 2 + 1]; }\n    void build(int node, int l, int r) {\n        if (l == r) { return t[node].apply(l, r, -M + r - 1); }\n        int mid = (l + r) / 2;\n        build(node * 2, l, mid);\n        build(node * 2 + 1, mid + 1, r);\n        pull(node);\n    }\n    void push(int p, int l, int r) {\n        if (t[p].lazy) {\n            int m = (l + r) / 2;\n            t[p * 2].apply(l, m, t[p].lazy);\n            t[p * 2 + 1].apply(m + 1, r, t[p].lazy);\n            t[p].lazy = 0;\n        }\n    }\n    void add(int node, int ql, int qr, int l, int r, int x) {\n        if (r < ql || l > qr) return;\n        if (ql <= l && qr >= r) return t[node].apply(l, r, x);\n        push(node, l, r);\n        int mid = (l + r) / 2;\n        add(node * 2, ql, qr, l, mid, x);\n        add(node * 2 + 1, ql, qr, mid + 1, r, x);\n        pull(node);\n    }\n    T get(int node, int ql, int qr, int l, int r) {\n        if (ql <= l && qr >= r) return t[node];\n        push(node, l, r);\n        int mid = (l + r) / 2;\n        if (qr <= mid) return get(node << 1, ql, qr, l, mid);\n        if (ql > mid) return get(node << 1 | 1, ql, qr, mid + 1, r);\n        return get(node << 1, ql, qr, l, mid) +\n               get(node << 1 | 1, ql, qr, mid + 1, r);\n    }\n    // wrapper\n    void add(int l, int r, int x) {\n        assert(l >= 0 && l <= r && r < n);\n        add(1, l, r, 0, n - 1, x);\n    }\n    T get(int l, int r) {\n        assert(l >= 0 && l <= r && r < n);\n        return get(1, l, r, 0, n - 1);\n    }\n};\nstruct node {\n    int v = 0; // don't forget to set default value (used for leaves),\n               // not necessarily zero element\n    int lazy = 0;\n    void apply(int l, int r, int x) {\n        lazy += x;\n        v += x;\n    }\n    node operator+(const node &b) const {\n        node res;\n        res.v = max(v, b.v);\n        return res;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    const int M = 200000;\n    vector<vector<int>> rs(M + 1);\n    for (int i = 0; i < n; i++) {\n        int l, r;\n        cin >> l >> r;\n        rs[l].push_back(r);\n    }\n    SegTree<node> tr(m + 2, m);\n    int ans = n - m;\n    for (int l = 0; l <= M && l <= m - 1; l++) {\n        for (auto r : rs[l]) {\n            tr.add(l + 1, r, 1);\n        }\n        ans = max(ans, tr.get(l + 1, m + 1).v - l);\n    }\n    cout << ans << '\\n';\n}"},{"id":"binomial-inversion","title":"äºŒé¡¹å¼åæ¼”","content":"æ„Ÿè§‰è¿™ç¯‡è®²å¾—ä¸é”™ã€‚ç›®å‰å°±å…ˆè®°å½•å…¬å¼ï¼Œä»¥åæœ‰æ›´æ·±çš„ç†è§£å†è¡¥ã€‚å½¢å¼é›¶å½¢å¼ä¸€å½¢å¼äºŒæœ€å¸¸ç”¨çš„å½¢å¼"},{"id":"bsearch_implementations","title":"äºŒåˆ†æœç´¢çš„ä¸¤ç§å†™æ³•","content":"èƒŒæ™¯ï¼šä»Šå¤©åšäº†ä¸ªé¢˜ï¼Œç”¨è‡ªå·±å¹³å¸¸çš„äºŒåˆ†å†™æ³•å¾ˆä¸æ–¹ä¾¿ï¼Œç¬¬ä¸€æ¬¡ç¢°åˆ°è¿™ç§æƒ…å†µï¼Œä¸ºäº†é˜²æ­¢åé¢å†ç¢°åˆ°ç±»ä¼¼çš„æƒ…å†µï¼Œå†³å®šè®°å½•ä¸€ä¸‹äºŒåˆ†çš„ä¸¤ç§å¸¸è§å†™æ³•ã€‚æ ¹æ®æœç´¢çš„æ¡ä»¶ï¼Œæ•´ä¸ªæœç´¢åŒºé—´å¯ä»¥è¢«åˆ’åˆ†ä¸ºä¸¤ä¸ªåŒºé—´ï¼Œå…¶ä¸­ä¸€ä¸ªä¸ºç¬¦åˆæ¡ä»¶çš„åŒºé—´ï¼Œæˆ‘ä»¬æƒ³è¦çš„å€¼å°±æ˜¯æœ€æ¥è¿‘åˆ†ç•Œçº¿çš„é‚£ä¸ªæ•°ï¼šå¦‚æœå‰åŠéƒ¨åˆ†ç¬¦åˆæ¡ä»¶ï¼Œé‚£æˆ‘ä»¬è¦æ‰¾çš„æ˜¯å…¶ä¸­æœ€å¤§çš„é‚£ä¸ªå€¼ï¼Œåä¹‹åˆ™æ˜¯ååŠéƒ¨åˆ†ä¸­æœ€å°çš„é‚£ä¸ªå€¼ã€‚è¿™ä¸¤ç§ä¸åŒçš„æƒ…å†µä¼šåœ¨å†™æ³•æœ‰æ‰€ä¸åŒã€‚å†™æ³•ä¸€ï¼šå¾ªç¯æ¡ä»¶ä¸ºï¼Œä¼˜ç‚¹æ˜¯ä¸è®ºå“ªéƒ¨åˆ†ç¬¦åˆæ¡ä»¶ï¼Œè¾¹ç•Œå˜åŒ–éƒ½æ˜¯æˆ–ï¼Œç»ˆæ­¢æ—¶ï¼Œï¼Œä¹Ÿå°±æ˜¯ræ˜¯å‰åŠéƒ¨åˆ†çš„æœ€å¤§å€¼ï¼Œlå’ŒååŠéƒ¨åˆ†çš„æœ€å°å€¼ï¼Œæ ¹æ®æƒ…å†µå–æˆ–è€…ã€‚æ¬¡æ–¹æ³•ç¼ºç‚¹æ˜¯ä¸èƒ½åŒæ—¶è¿›è¡Œä¸¤ä¸ªäºŒåˆ†æœç´¢ï¼Œä¸é€‚åˆåœ¨æŸäº›äºŒåˆ†çš„äº¤äº’é¢˜é‡Œä½¿ç”¨ã€‚å†™æ³•äºŒï¼šå¾ªç¯ç»ˆæ­¢æ¡ä»¶ä¸ºä½†ä¸­ç‚¹çš„å–æ³•å’Œè¾¹ç•Œçš„å˜åŒ–ä¸¤ç§æƒ…å†µä¸ä¸€æ ·ï¼šå¦‚æœå‰åŠéƒ¨åˆ†ç¬¦åˆæ¡ä»¶ï¼šæœç´¢åŒºé—´ä¸ºwhile (l < r) {\n    int mid = (l + r + 1) / 2;\n    if (ok(mid)) l = mid;\n    else r = mid - 1;\n}å¦‚æœååŠéƒ¨åˆ†ç¬¦åˆæ¡ä»¶ï¼šæœç´¢åŒºé—´ä¸ºwhile (l < r) {\n    int mid = (l + r) / 2;\n    if (ok(mid)) r = mid;\n    else l = mid + 1;\n}æ€»ç»“ä¸‹æ¥å°±æ˜¯ï¼šä¸­ç‚¹åå‘åˆ†ç•Œçº¿ç¬¦åˆæ¡ä»¶çš„è¯ï¼Œè¾¹ç•Œç§»åŠ¨åˆ°ä¸­ç‚¹ï¼Œå¦åˆ™è¦+1æˆ–è€…-1åŠå¼€åŠé—­åŒºé—´æ˜¯ä¸ºäº†è€ƒè™‘åˆ°æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„æ•°çš„æƒ…å†µï¼Œæ­¤æ—¶è¾¹ç•Œä¼šç§»åŠ¨åˆ°å¼€åŒºé—´é‚£å¤´ï¼Œç±»ä¼¼äºæ‰¾ä¸åˆ°çš„è¯ä¼šè¿”å›ã€‚ä¼˜ç‚¹æ˜¯å¯ä»¥åŒæ—¶è¿›è¡Œä¸¤ä¸ªäºŒåˆ†ï¼Œå½“å…¶ä¸­ä¸€ä¸ªåŒºé—´æ”¶æ•›ä¹‹åå°±ä¸ä¼šå†å˜åŒ–äº†ã€‚è€Œä¸”è¿™ç§å†™æ³•æ¯”è¾ƒç¬¦åˆç›´è§‰ï¼Œæœ‰äº›äºŒåˆ†äº¤äº’é¢˜ä¸­æˆ‘å°±ä¼šä¸ç”±è‡ªä¸»çš„æ¢æˆè¿™ç§å†™æ³•ï¼ˆè™½ç„¶ä»¥å‰å¹¶æ²¡æœ‰ä»”ç»†ç ”ç©¶è¿‡ï¼‰ã€‚ç¼ºç‚¹å°±æ˜¯ç»†èŠ‚ç¨å¤šï¼Œä¸€æ˜¯å–ä¸­ç‚¹çš„å†™æ³•ï¼ŒäºŒæ˜¯æ³¨æ„å¼€åŒºé—´ã€‚"},{"id":"bundle-cpp-code","title":"ç”¨Clangæ‰“åŒ…C++ä»£ç ","content":"ä½œä¸ºä¸€åç®—æ³•ç«èµ›é€‰æ‰‹ï¼Œæˆ‘ä¸€ç›´åœ¨å¯»æ‰¾é¿å…å¤åˆ¶ç²˜è´´æ¿å­çš„æ–¹æ³•ï¼Œè¿™æ ·æˆ‘å°±çš„æ¿å­åº“å°±èƒ½æ›´åŠ å¤æ‚ã€‚å—Egorçš„rust bundlerå¯å‘ï¼Œæˆ‘ä¸ç¦æƒ³C++ä¹Ÿæœ‰æ²¡æœ‰ç›¸ä¼¼çš„ä¸œè¥¿? äºæ˜¯æƒ³èµ·æ¥å¾ˆä¹…ä¹‹å‰çœ‹è¿‡è¿™ä¸ªåšå®¢ç„¶åæˆ‘å°±è¯äº†ç‚¹æ—¶é—´åˆæ‰¾åˆ°äº†é‚£ç¯‡åšæ–‡ï¼Œä½†å¹¶ä¸æ˜¯bundlerè€Œä¸”çœ‹èµ·æ¥å¾ˆå¤æ‚ã€‚è¯„è®ºåŒºé‡Œæœ‰äººæåˆ°ç”¨è¿™ä¸ªé¢„å¤„ç†å‘½ä»¤ã€‚ä¹Ÿè®¸ä½ çŸ¥é“ï¼ŒåŸºæœ¬å°±æ˜¯å¤åˆ¶ç²˜è´´æ‰€ä»¥çœ‹èµ·æ¥å¥½åƒæœ‰æˆï¼Œä½†é—®é¢˜æ˜¯é¢„å¤„ç†ä¹Ÿä¼šå¤åˆ¶ç²˜è´´æ ‡å‡†åº“ï¼Œå¤§æ¦‚æœ‰20å¤šä¸‡è¡Œã€‚æ‰€ä»¥æˆ‘ç»§ç»­æœå¯»èƒ½ä¸èƒ½è·³è¿‡ç³»ç»Ÿå¤´æ–‡ä»¶ï¼Œç„¶åå°±æ‰¾åˆ°äº†è¿™ä¸ªï¼Œä½†åªæœ‰clangæ‰èƒ½ç”¨ï¼Œå› ä¸ºæˆ‘è‡ªå·±ä¹Ÿç”¨clangæ‰€ä»¥å°±æ²¡å†æ‰¾gccçš„è§£å†³åŠæ³•ã€‚å‘½ä»¤å¦‚ä¸‹clang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc main.cppè§£é‡Šï¼š åªè¿›è¡Œé¢„å¤„ç† å…³é—­åœ¨é¢„å¤„ç†ä¸­ç”Ÿæˆè¡Œæ ‡è®° å…³é—­C++æ ‡å‡†åº“ å…³é—­å†…ç½®çš„#includeç›®å½•ï¼ˆä¸å¤ªçŸ¥é“ä»€ä¹ˆæ„æ€ï¼Œå¯èƒ½æ²¡ç”¨ï¼‰å› ä¸ºç³»ç»Ÿå¤´æ–‡ä»¶ä¸ä¼šè¢«ä¿ç•™ï¼Œæ‰€ä»¥éœ€è¦å¦ä¸€æ¡å‘½ä»¤æŠŠä½“ç»Ÿå¤´æ–‡ä»¶åŠ ä¸Šï¼Œç„¶åæˆ‘å°±å†™äº†ä¸€ä¸ªshellå‡½æ•°ä¸€èµ·åšè¿™ä¸¤ä»¶äº‹ï¼šexpand_cpp () {\n    clang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc $1 | gsed \"1s/^/#include <bits\\/stdc++.h>\\n/\" | pbcopy\n}å…¶ä¸­æ˜¯macOSä¸Šå¤åˆ¶åˆ°å‰ªåˆ‡æ¿çš„å‘½ä»¤ï¼Œå…¶ä»–å¹³å°ç”¨ç›¸åº”çš„å‘½ä»¤ä»£æ›¿å³å¯ã€‚"},{"id":"clangd-backgound-indexing","title":"ä»¥ç®—æ³•ç«èµ›å†™é¢˜ä¸ºä¾‹çš„ clangd åå°ç´¢å¼•(backgound indexing)ä½¿ç”¨æŒ‡å—","content":"æˆ‘ä¹Ÿä¸çŸ¥é“æ ‡é¢˜åœ¨è¯´ä»€ä¹ˆé—®é¢˜è™½ç„¶ç›®å‰æˆ‘çš„æ¿å­å¤§éƒ¨åˆ†éƒ½è¿›è¡Œäº†å°è£…ï¼Œincludeå°±èƒ½ç›´æ¥ç”¨ï¼Œä½†ä¾ç„¶æœ‰ä¸¤ä¸ªç—›ç‚¹ï¼šéœ€è¦æ‰‹åŠ¨ includeï¼Œæ¯æ¬¡è¦è·³åˆ°æœ€ä¸Šé¢includeä¹‹åå†å›æ¥ä¸å…æœ‰äº›éº»çƒ¦ç”±äºç›®å‰æ˜¯é  compile_flags.txt é…ç½®çš„ clangdï¼Œæ‰€ä»¥å¹¶ä¸ä¼šæœ‰åå°ç´¢å¼•ï¼Œä¹Ÿå°±æ˜¯è¯´includeä¹‹åå¹¶ä¸èƒ½è·å¾—è¯¥æ–‡ä»¶çš„è¡¥å…¨ä¿¡æ¯ï¼Œè€Œæˆ‘ç»å¸¸è®°ä¸å¾—ç±»æˆ–è€…å‡½æ•°çš„åå­—æ‰€ä»¥ä¸å¾—ä¸è·³è½¬è¿‡å»çœ‹ä¸€çœ¼ï¼Œè€Œå¯¹äºæœ‰äº›éå¸¸é•¿çš„åå­—ï¼Œä¹Ÿè¿˜æ˜¯è¦è·³è½¬æ‰“å¼€æ–‡ä»¶ä¸€æ¬¡è¿™æ ·clangdæ‰èƒ½ç´¢å¼•è¯¥æ–‡ä»¶ã€‚å¦‚æœæœ‰åå°ç´¢å¼•çš„è¯è¿™ä¸¤ä¸ªé—®é¢˜éƒ½èƒ½å®Œç¾è§£å†³ï¼æ­¥éª¤é¦–å…ˆåœ¨æ”¾ä»£ç çš„ç›®å½•é‡Œå†™ä¸€ä¸ªéå¸¸ç®€å•çš„ :cmake_minimum_required(VERSION 3.1...3.26)\n\nproject(\n    competitive programming\n  VERSION 1.0\n  LANGUAGES CXX)\n\nset (CMAKE_CXX_STANDARD 20)\n\nadd_executable(include-all include-all.cpp)\n\ninclude_directories(æ¿å­çš„ç›®å½•)æˆ‘ä»¬è¿˜è¦æ–°å»ºä¸€ä¸ª include-all.cpp å¹¶åœ¨é‡Œé¢ include æˆ‘ä»¬æ‰€æœ‰çš„æ¿å­æ–‡ä»¶ï¼ˆåé¢ä¼šæåˆ°ä»–çš„æ‰€ç”¨ï¼‰ã€‚ç„¶åæ‰§è¡Œ  è¿™æ ·å°±èƒ½å¾—åˆ°  æ–‡ä»¶ï¼Œclangdå°±æ˜¯æ ¹æ®è¿™ä¸ªæ–‡ä»¶æ¥è¿›è¡Œç´¢å¼•çš„ã€‚\nç„¶è€Œä½ å‘ç°  é‡Œé¢å…¶å®å¹¶æ²¡æœ‰å¤´æ–‡ä»¶çš„ä¿¡æ¯ã€‚è¿™æ˜¯å› ä¸ºå¤´æ–‡ä»¶å¹¶ä¸æ˜¯ä¸€ä¸ª translation unit æ‰€ä»¥ cmake å°±ä¸ä¼šä¸ºå…¶ç”Ÿæˆç¼–è¯‘ä¿¡æ¯ã€‚é‚£æ€ä¹ˆåŠå‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥å€ŸåŠ© compdb è¿™ä¸ªå·¥å…·ä¸ºæˆ‘ä»¬åŠ å…¥å¤´æ–‡ä»¶çš„ä¿¡æ¯ï¼Œè¿™å°±æ˜¯ CMakeLists.txt é‡Œ include-all.cpp çš„ä½œç”¨ã€‚ç„¶åæˆ‘ä»¬æ‰§è¡Œ:compdb -p . list > new.json # è¿™é‡Œä¸èƒ½ç›´æ¥é‡å®šå‘åˆ°compile_commands.jsonï¼Œå¥½å¥‡çš„è¯å¯ä»¥è‡ªå·±è¯•ä¸€ä¸‹\nmv new.json compile_commands.json # æŠŠåŸæ¥çš„è¦†ç›–æ‰å½“ä½ ä»¥ä¸ºå¤§åŠŸå‘Šæˆçš„æ—¶å€™ä½ ä¼šå‘ç°å¥½åƒè¿˜æ˜¯ä¸è¡Œï¼Œè¿™æ˜¯å› ä¸º clangd é»˜è®¤ä¸ä¼šç´¢å¼•å½“å‰ç›®å½•ä¹‹å¤–çš„ä¸œè¥¿ï¼ˆå¤§æ¦‚æ˜¯è¿™ä¹ˆä¸ªæ„æ€ï¼‰ï¼Œè¦ç»™ clangd åŠ ä¸Š  å‚æ•°ã€‚æœ€åçš„æœ€åï¼Œè¦ä¿è¯ä½ çš„æ¿å­ç¬¬ä¸€è¡Œè¦æœ‰ ï¼Œä¸ç„¶ä¸èƒ½è‡ªåŠ¨ includeã€‚ä»¥ä¸Šä¾¿æ˜¯æˆ‘ä»ä¸‹åˆä¸‰ç‚¹åˆ°æ™šä¸Šåç‚¹çš„ç ”ç©¶æˆæœï¼ˆä¸ºä»€ä¹ˆæˆ‘æ€»æ˜¯èŠ±å¤§æŠŠæ—¶é—´ç ”ç©¶ä¸€äº›æ²¡ä»€ä¹ˆç”¨çš„åŠŸèƒ½ï¼‰"},{"id":"cover_edges_with_path_of_length_two","title":"ç”¨é•¿ä¸º2çš„è·¯å¾„è¦†ç›–æ‰€æœ‰è¾¹","content":"è²Œä¼¼è¿˜æŒºç»å…¸çš„ä¸€ä¸ªé—®é¢˜æ˜¾ç„¶æˆ‘ä»¬è¦å•ç‹¬è€ƒè™‘æ¯ä¸ªè¿é€šå—ï¼Œç»“è®ºæ˜¯ç­”æ¡ˆä¸ºï¼Œå…¶ä¸­mä¸ºè¾¹æ•°ã€‚å¯»æ‰¾ç­”æ¡ˆçš„ç®—æ³•å¦‚ä¸‹ï¼šè·‘ä¸€édfså¾—åˆ°dfsç”Ÿæˆæ ‘ï¼Œç„¶åä»ä¸‹å¾€ä¸Šå¤„ç†è¾¹ï¼šå°†ä¸å½“å‰èŠ‚ç‚¹ç›¸è¿çš„è¾¹ä¸¤ä¸¤é…å¯¹ï¼Œå¦‚æœè¾¹æ•°æ˜¯å¥‡æ•°å°±ç•™ä¸‹ä¸çˆ¶äº²èŠ‚ç‚¹ç›¸è¿çš„é‚£æ¡è¾¹ç»™çˆ¶äº²èŠ‚ç‚¹ã€‚è¿™æ ·å°±å¯ä»¥ä¿è¯æ‰€æœ‰è¾¹éƒ½è¢«è¦†ç›–äº†ã€‚ä»£ç ï¼š#include <bits/stdc++.h>\n\nusing namespace std;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin>>n>>m;\n    vector<vector<int>> g(n);\n    for (int i=0; i<m; i++) {\n        int u, v;\n        cin>>u>>v;\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> vis(n);\n    vector<tuple<int, int, int>> res;\n    auto dfs=[&](auto& dfs, int u, int p) -> bool {\n        vis[u]=1;\n        vector<int> w;\n        if (p!=-1) w.push_back(p);\n        for (auto v : g[u]) {\n            if (v==p) continue;\n            if (!vis[v]) {\n                if (dfs(dfs, v, u)) w.push_back(v);\n            } else if (vis[v]==1) w.push_back(v);\n        }\n\n        while (w.size() >= 2) {\n            res.emplace_back(*(w.rbegin()+1), u, w.back());\n            w.pop_back();\n            w.pop_back();\n        }\n        vis[u]=2;\n        return !w.empty();\n    };\n    for (int i=0; i<n; i++) {\n        if (!vis[i]) dfs(dfs, i, -1);\n    }\n    cout<<res.size()<<'\\n';\n    for (auto& [x, y, z] : res) cout<<x+1<<' '<<y+1<<' '<<z+1<<'\\n';\n    return 0;\n}ç»ƒä¹ é¢˜ï¼šCF1159E - Off by Onegym102001K - BoomerangsCF858E - Wizard's Tour"},{"id":"cp-bot-dev-log-1","title":"å…¨æ–°çš„å¼€å§‹ - ç®—æ³•ç«èµ›æœºå™¨äººå¼€å‘æ—¥å¿—1","content":"æˆ‘çš„æœºå™¨äººï¼Œæ˜æ˜åªæœ‰ä¸¤ä¸ªåŠŸèƒ½ï¼Œå´å·²é‡å†™äº†ä¸¤æ¬¡äº†ï¼Œç¬¬ä¸€æ¬¡ä»C++æ¬åˆ°Pythonï¼Œç°åœ¨åˆä»Pythonæ¬åˆ°Nonebotæ¡†æ¶ä¸Šï¼ˆè™½è¯´è¿˜æ˜¯Python)ï¼Œä»¥ååº”è¯¥ä¸ä¼šå†åŠ¨äº†ã€‚è¿™æ¬¡æ¬è¿èµ·æºäºå‘¨å…­åœ¨ç»™ä¸Šä¸€ç‰ˆæœ¬å†™readmeï¼Œå‡†å¤‡å‘å¸ƒåˆ°GitHubä¸Šï¼Œå½“æ—¶æˆ‘åœ¨ç‰¹ç‚¹é‡Œå†™ä¸‹äº†ä¸ä½¿ç”¨æ¡†æ¶ï¼ˆå¯èƒ½æ˜¯ä¸ªé”™è¯¯çš„å†³å®šï¼‰ç„¶åæˆ‘å°±ä¸ç¦æ€è€ƒè¿™åˆ°åº•æ˜¯ä¸æ˜¯ä¸ªé”™è¯¯çš„å†³å®šï¼šå½“åˆä¸ç”¨æ¡†æ¶çš„åŸå› ä¹Ÿå¾ˆç®€å•ï¼Œå°±æ˜¯ä¸æƒ³å­¦æ¡†æ¶çš„é‚£ä¸€å¥—ï¼Œç„¶ååˆè§‰å¾—è‡ªå·±é€ ç‚¹è½®å­ä¹ŸæŒºå¥½ç©çš„ï¼Œä½†åæ¥å‘ç°è‡ªå·±éœ€è¦é€ çš„è½®å­è¶Šæ¥è¶Šå¤§æ—¶å°±ä¸é‚£ä¹ˆå¥½ç©äº†ï¼Œç›®å‰æœ‰å‡ ä¸ªå¤§è½®å­è¦é€ ï¼šå‘½ä»¤ä¸å‚æ•°ç³»ç»Ÿï¼Œå¦‚æœå°†æ¥å‘½ä»¤å¢å¤šçš„è¯ä¸€å †if elseåŠ å­—ç¬¦ä¸²åŒ¹é…åˆéº»çƒ¦åˆä¸‘å®šæ—¶å‘½ä»¤ï¼Œæ¯”èµ›æé†’æ˜¯æˆ‘æ¥ä¸‹æ¥æƒ³åšçš„ä¸€å¤§ç‰¹æ€§ï¼Œå› ä¸ºæˆ‘è€æ˜¯å¿˜AtCoderçš„æ¯”èµ›é…ç½®ç³»ç»Ÿï¼Œè¦æ˜¯å°†æ¥åˆ«äººè¦ç”¨çš„è¯ä¸€å®šè¦åšå¥½é…ç½®ç³»ç»Ÿäºæ˜¯æˆ‘åˆçœ‹äº†çœ‹Nonebotçš„æ–‡æ¡£ï¼Œå‘ç°å¥½åƒä¹Ÿæ²¡é‚£ä¹ˆéº»çƒ¦ï¼Œè€Œä¸”è‡ªå¸¦å‘½ä»¤ä¸å®šæ—¶ç³»ç»Ÿï¼Œåˆæƒ³åˆ°æ¡†æ¶éš¾é“ä¸å°±æ˜¯ä¸ºäº†è®©å¼€å‘è€…ä¸“æ³¨äºç¼–å†™ä¸šåŠ¡é€»è¾‘å—ï¼Ÿäºæ˜¯å°±æƒ³å…ˆè¯•è¯•çœ‹ï¼Œç„¶åç¬¬äºŒå¤©æ—©ä¸ŠåŠ ä¸­åˆåƒå®Œé¥­ä¸€ç‚¹æ—¶é—´å°±åŸºæœ¬æ¬è¿‡å»äº†ï¼Œåˆçœ‹åˆ°éå¸¸fancyçš„logç•Œé¢å°±å†³å®šå®Œå…¨è½¬åˆ°Nonebotä¸Šäº†ã€‚é‚£åˆä¸ºä»€ä¹ˆè¦å†™å¼€å‘æ—¥å¿—æï¼Ÿå› ä¸ºæœºå™¨äººå…¶å®å¥½ä¹…æ²¡å†ç»§ç»­å¼€å‘äº†ï¼Œè‡ªä»å‰ä¸¤å‘¨å‘ç°äº†APSchedulerä¹‹åå°±å¼€å§‹ç ”ç©¶åŠ ç¼“å­˜ä¸æ¯”èµ›æé†’çš„åŠŸèƒ½ï¼Œç„¶åå°±èŒç”Ÿäº†å†™æ—¥å¿—çš„æƒ³æ³•ï¼Œè¿™æ¬¡æ¬è¿åˆå·®ä¸å¤šç®—æ˜¯â€œä»å¤´å¼€å§‹â€æ‰€ä»¥å°±æ¯å‘¨å†™ä¸€ç¯‡å¼€å‘æ—¥å¿—è®°å½•æœ¬å‘¨å·¥ä½œä»¥åŠæ¥ä¸‹æ¥è¦åšçš„ä»»åŠ¡ï¼Œé¡ºä¾¿èµ·åˆ°ç£ä¿ƒè‡ªå·±çš„ä½œç”¨ã€‚ç¬¬ä¸€ç¯‡ï¼ˆè¿™ç¯‡ï¼‰æœ¬æ¥åº”è¯¥å‘¨æ—¥å†™çš„æ¥ç€ï¼Œç»“æœå‘¨æ—¥å‡ºå»ç©ç”±äºçªå‘æƒ…å†µå›æ¥çš„å¾ˆæ™šï¼ŒåŸºæœ¬ä¸Šæ¥ç€å°±ä¸ŠåºŠç¡è§‰äº†ã€‚ä»¥åæ—¥å¿—äº‰å–åœ¨å‘¨æœ«å†™ï¼Œè¿™æ¬¡ç”±äºèƒŒæ™¯ä»‹ç»æ‰€ä»¥ç¨é•¿ï¼Œä»¥ååº”è¯¥å°±ç®€å•è®°å½•ä¸€ä¸‹ã€‚ä¸Šå‘¨å·¥ä½œï¼šåŸºæœ¬å®Œæˆæ¬è¿ï¼Œä¸¤ä¸ªå‘½ä»¤å·²å¯ç”¨ï¼Œä½†ç¼“å­˜è¿˜æ²¡æå®šä¸€äº›é‡æ„ï¼šé‡å‘½åï¼Œæ·»åŠ type hintå˜æˆåŒ…ä¹‹åimportè¯­å¥è¦å˜æˆç±»ä¼¼ï¼ŒæŠŠæ‰€æœ‰importéƒ½ä¿®äº†ï¼ˆè¿˜æŒºå¤šçš„ï¼‰TODOï¼šå‚æ•°ç³»ç»Ÿï¼ŒæŸ¥æ¯”èµ›å‘½ä»¤æŒºéœ€è¦çš„ç”»å›¾åŠŸèƒ½ä¹Ÿå¾ˆéœ€è¦çœ‹çœ‹å†…ç½®çš„schedulerèƒ½ä¸èƒ½ç”¨æ•°æ®åº“çš„job storeï¼Œå¦‚æœèƒ½çš„è¯ï¼šå°½å¿«èƒ½æŠŠç¼“å­˜å¼„å¥½æ¯”èµ›æé†’æ ¹æ®é…ç½®å¼€å…³æŸäº›åŠŸèƒ½ï¼Œæ¯”å¦‚æ˜¯å¦ä½¿ç”¨ç¼“å­˜é‡æ„ä¸€äº›æŠ„çš„TLEçš„ä»£ç ï¼Œæ„Ÿè§‰ä¸æ˜¯å¾ˆå–œæ¬¢TLEçš„ä¸€äº›è®¾è®¡æ¬ä¸€äº›TLEå…¶ä»–çš„æœ‰è¶£çš„åŠŸèƒ½"},{"id":"cp-bot-dev-log-2","title":"ç®—æ³•ç«èµ›æœºå™¨äººå¼€å‘æ—¥å¿—2","content":"è¿™å‘¨æ²¡åšä»€ä¹ˆå¤§åŠŸèƒ½ï¼Œåšäº†ä¸‹å‡ ä»¶å°äº‹ï¼šå‚æ•°åŸæ¥  å°±æ˜¯ä¸“é—¨è´Ÿè´£è¿™ä¸ªçš„ï¼Œå¯ä»¥ä¼ å…¥ä¸€ä¸ª argument parserï¼Œé‚£è¿™æ ·å°±å¾ˆç®€å•äº†ï¼Œäºæ˜¯ç»™æŸ¥æ¯”èµ›åŠ äº†  å’Œ  ä»¥æ˜¾ç¤ºå‰ x æ¡æˆ–è€…å…¨éƒ¨æ¯”èµ›ã€‚æ•°æ®åº“ç›¸å…³æœ€è¿‘äº†è§£åˆ° ORMï¼ˆæˆ‘çœŸæ˜¯å­¤é™‹å¯¡é—»ç°åœ¨æ‰çŸ¥é“è¿™ä¸ªä¸œè¥¿ï¼‰ï¼Œäºæ˜¯å†³å®šæ”¾å¼ƒ MongoDB è¿˜æ˜¯ç”¨å…³ç³»å‹æ•°æ®åº“ï¼Œä½† APScheduler çš„  å¥½åƒæ²¡å®Œå…¨æ”¯æŒ SQLAlchemy 2æ‰€ä»¥æ¯”èµ›æé†’æš‚æ—¶å°±æ²¡æ³•åšå¯æŒä¹…åŒ–äº†ï¼Œä½†ä¸€æƒ³å¯æŒä¹…åŒ–ä¹Ÿæ²¡æœ‰å¤ªå¤§çš„ç”¨ï¼Œæ¯æ¬¡æ›´æ–°ç¼“å­˜çš„æ—¶å€™é‡æ–°æ·»åŠ ä¸€éæé†’åº”è¯¥å°±å¤Ÿäº†ã€‚ã€‚ã€‚ç¼“å­˜çš„è¯åˆ°æ˜¯å¼„å®Œäº†ä½†æ˜¯æ²¡æ³•æµ‹è¯•ï¼Œå› ä¸ºä»Šå¤©cfçš„APIä¸€ç›´éƒ½æ˜¯æŒ‚äº†çš„ã€‚è¯´åˆ°ORMå°±ä¸å¾—ä¸æé‡æ„çš„äº‹ï¼šé‡æ„ç°åœ¨  ç±»ä¸å†ç”¨  äº†ï¼Œå› ä¸ºå¯ä»¥å’ŒORMï¼ˆç”¨çš„SQLModelï¼‰çš„Modelå…±ç”¨ä¸€ä¸ªç±»ï¼Œè€Œä¸”SQLModelçš„modelä¹Ÿæ˜¯Pydantic modelæ‰€ä»¥å¯ä»¥ç›´æ¥ç”¨ï¼Œæ¯”ä¹‹å‰ä¼˜é›…å¤šäº†ã€‚ä¸å¾—ä¸è¯´SQLModelçš„ç†å¿µçœŸçš„å¾ˆæœ‰æƒ³æ³•ã€‚LaTexæ’ä»¶å—ç¾¤å‹çš„æç¤ºå†™äº†ä¸ªæ¸²æŸ“LaTexçš„æ’ä»¶ï¼Œè¯•äº†Matplotlibå’ŒSymPyçš„latexåŠŸèƒ½éƒ½ä¸å¤ªæ»¡æ„ï¼Œæœ€ååŸºäºSymPyçš„å‡½æ•°è‡ªå·±å†™äº†ä¸ªæ’ä»¶ã€‚TODOç¼“å­˜å’Œæé†’ç»§ç»­ç ”ç©¶TLEçš„ä»£ç çœ‹çœ‹æœ‰æ²¡æœ‰å¥½ç©çš„åŠŸèƒ½æŠŠä»£ç æ•´ç†å¥½å¼€æºåˆ°githubä¸Š"},{"id":"cugb-21-training-4-sol","title":"CUGBACM21çº§ç»„é˜Ÿè®­ç»ƒï¼ˆå››ï¼‰é¢˜è§£","content":"å‡ºé¢˜æ€è·¯æ²¡æœ‰å¾ˆæ°´çš„ç­¾åˆ°ï¼Œä¸­æ¡£é¢˜ä¸ºä¸»æ€ç»´é¢˜ä¸ºä¸»ï¼Œç©¿æ’ä¸€äº›ç®—æ³•çŸ¥è¯†/æ€ç»´ä¸¤ä¸ªç å†œé¢˜ç»ƒä¸€ä¸‹ç åŠ›A. åº§ä½å®‰æ’æŠŠæ¯å¯¹æœ‹å‹çš„è¦æ±‚çœ‹æˆä¸€æ¡è¾¹ï¼Œé‚£ä¹ˆæ¯ä¸ªç‚¹çš„åº¦æ•°æœ€å¤šä¸º2ï¼Œè¯´æ˜æ¯ä¸ªè¿é€šåˆ†é‡è¦ä¹ˆæ˜¯ç¯è¦ä¹ˆæ˜¯é“¾ã€‚æ˜¯é“¾çš„è¯æ¯ä¸ªè¦æ±‚éƒ½èƒ½æ»¡è¶³ï¼Œæ˜¯ç¯çš„è¯é™¤éæ•´ä¸ªå›¾æ˜¯ä¸€ä¸ªå¤§ç¯ï¼Œå¦åˆ™å¿…ç„¶æœ‰ä¸€æ¡è¾¹ä¸èƒ½æ»¡è¶³ï¼Œé‚£ä¹ˆèˆå¼ƒæ‰é’±æœ€å°‘çš„æ¡ä»¶ã€‚#include <bits/stdc++.h>\n\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<array<int, 2>>> g(n);\n    ll sum = 0;\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        u--, v--;\n        sum += w;\n        g[u].push_back({v, w});\n        g[v].push_back({u, w});\n    }\n\n    vector<int> vis(n);\n    // mn: å½“å‰è¿é€šåˆ†é‡ä¸­çš„æœ€å°è¾¹ï¼Œsz: å½“å‰è¿é€šåˆ†é‡çš„å¤§å°\n    auto dfs = [&](auto& slf, int u, int p, int mn, int sz) -> void {\n        vis[u] = 1;\n        for (auto [v, w] : g[u]) {\n            if (v == p) continue;\n            if (vis[v] == 1) { // æˆç¯äº†\n                if (sz != n) {\n                    sum -= min(mn, w);\n                }\n            } else if (vis[v] == 0) {\n                slf(slf, v, u, min(mn, w), sz + 1);\n            }\n        }\n        vis[u] = 2;\n    };\n\n    for (int i = 0; i < n; i++) {\n        if (!vis[i]) {\n            dfs(dfs, i, i, 1e9, 1);\n        }\n    }\n\n    cout << sum << endl;\n    return 0;\n}B. å·¦æ’‡å­ä¸å³æ’‡å­éå¸¸ç®€å•çš„ dpï¼Œä»¤  ä¸ºè€ƒè™‘äº†å‰  ä¸ªé—®é¢˜ï¼Œä¸”å·¦æ’‡å­ä¸å³æ’‡å­æ•°é‡ä¹‹å·®ä¸º  æ—¶æ‰€éœ€è¦é‡‡è®¿çš„æœ€å°‘çš„è€å¸ˆä¸ªæ•°ã€‚æˆ‘ä»¬éå†æ¯ä¸ªé—®é¢˜ï¼Œå¯¹äºæ¯ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬è¦ä¹ˆåªé‡‡è®¿å·¦æ’‡å­ï¼Œè¦ä¹ˆåªé‡‡è®¿å³æ’‡å­ï¼Œè¦ä¹ˆå·¦æ’‡å­å³æ’‡å­å„é‡‡è®¿ä¸€ä¸ªã€‚å…·ä½“çŠ¶æ€è½¬ç§»å¯ä»¥çœ‹ä»£ç ~#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t, n;\n    cin >> t >> n;\n\n    vector<int> cnt1(t), cnt2(t);\n    for (int i = 0; i < n; i++) {\n        int x;\n        char c;\n        cin >> x >> c;\n        x--;\n        if (c == 'L') cnt1[x]++;\n        else cnt2[x]++;\n    }\n\n    const int INF = 1e9;\n    vector<int> dp(2 * n + 1, INF);\n    dp[n] = 0;\n\n    for (int i = 0; i < t; i++) {\n        vector<int> ndp(2 * n + 1, INF);\n\n        for (int j = 0; j <= 2 * n; j++) {\n            // åªé‡‡è®¿å·¦æ’‡å­\n            for (int k = 1; k <= cnt1[i]; k++) {\n                if (j - k >= 0)\n                    ndp[j - k] = min(ndp[j - k], dp[j] + k);\n            }\n            // åªé‡‡è®¿å³æ’‡å­\n            for (int k = 1; k <= cnt2[i]; k++) {\n                if (j + k <= 2 * n)\n                    ndp[j + k] = min(ndp[j + k], dp[j] + k);\n            }\n\n            // å„é‡‡è®¿ä¸€ä¸ª\n            if (cnt1[i] && cnt2[i]) {\n                ndp[j] = min(ndp[j], dp[j] + 2);\n            }\n        }\n        swap(dp, ndp);\n    }\n\n    cout << (dp[n] == INF ? -1 : dp[n]) << endl;\n    return 0;\n}C. æ‰“æ‰«é“è·¯ä¸€ç§æ¯”è¾ƒç®€å•çš„åˆ¤æ–­ä¸€æ¡è¾¹  æ˜¯å¦åœ¨  åˆ°  çš„æœ€çŸ­è·¯ä¸Šçš„æ–¹æ³•æ˜¯æ£€æŸ¥  åˆ°  çš„æœ€çŸ­è·ç¦»åŠ   åˆ°  çš„æœ€çŸ­è·ç¦»ï¼ˆä¹Ÿå¯èƒ½åè¿‡æ¥ï¼‰åŠ   è¾¹çš„é•¿åº¦æ˜¯å¦æ˜¯  åˆ°  çš„æœ€çŸ­è·ç¦»ï¼Œä¹Ÿå°±æ˜¯æ£€æŸ¥ï¼š#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvector<int> dijkstra(const vector<vector<array<int, 2>>>& g, int start) {\n    constexpr int INF = 1e9;\n    int n = (int)g.size();\n\n    vector dis(n, INF);\n\n    using node = std::pair<int, int>;\n    std::priority_queue<node, std::vector<node>, std::greater<>> q;\n\n    dis[start] = 0;\n    q.emplace(0, start);\n\n    while (!q.empty()) {\n        auto [d, u] = q.top();\n        q.pop();\n\n        if (d != dis[u]) continue;\n\n        for (auto [v, cost] : g[u]) {\n            if (dis[v] > d + cost) {\n                dis[v] = d + cost;\n                q.emplace(dis[v], v);\n            }\n        }\n    }\n    return dis;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, a, b;\n    cin >> n >> m >> a >> b;\n    a--, b--;\n\n    vector<vector<array<int, 2>>> g(n);\n    vector<array<int, 3>> edges(m);\n\n    for (auto& [u, v, w] : edges) {\n        cin >> u >> v >> w;\n        u--, v--;\n        g[u].push_back({v, w});\n        g[v].push_back({u, w});\n    }\n\n    auto disa = dijkstra(g, a);\n    auto disb = dijkstra(g, b);\n\n    int ans = 0;\n    int mndis = disa[b];\n    for (auto [u, v, w] : edges) {\n        int mn = min(disa[u] + disb[v], disa[v] + disb[u]) + w;\n        if (mn == mndis) {\n            ans += w;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}è¿˜æœ‰ä¸€ç§åšæ³•æ˜¯åˆ©ç”¨ä»  å¼€å§‹çš„æœ€çŸ­è·¯ DAGï¼ˆK é¢˜é¢˜è§£ä¸­æœ‰ä»‹ç»ï¼‰ï¼Œå°†å…¶ä¸­çš„è¾¹åè½¬ååä»  å‡ºå‘ï¼Œæ‰€æœ‰ç»è¿‡çš„è¾¹å°±æ˜¯åœ¨  åˆ°  çš„æœ€çŸ­è·¯ä¸Šçš„è¾¹ã€‚#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvector<int> dijkstra(const vector<vector<array<int, 2>>>& g, int start) {\n    constexpr int INF = 1e9;\n    int n = (int)g.size();\n\n    vector dis(n, INF);\n\n    using node = std::pair<int, int>;\n    std::priority_queue<node, std::vector<node>, std::greater<>> q;\n\n    dis[start] = 0;\n    q.emplace(0, start);\n\n    while (!q.empty()) {\n        auto [d, u] = q.top();\n        q.pop();\n\n        if (d != dis[u]) continue;\n\n        for (auto [v, cost] : g[u]) {\n            if (dis[v] > d + cost) {\n                dis[v] = d + cost;\n                q.emplace(dis[v], v);\n            }\n        }\n    }\n    return dis;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, a, b;\n    cin >> n >> m >> a >> b;\n    a--, b--;\n\n    vector<vector<array<int, 2>>> g(n);\n    vector<array<int, 3>> edges(m);\n\n    for (auto& [u, v, w] : edges) {\n        cin >> u >> v >> w;\n        u--, v--;\n        g[u].push_back({v, w});\n        g[v].push_back({u, w});\n    }\n\n    auto dis = dijkstra(g, a);\n\n    vector<int> vis(n);\n    int ans = 0;\n    auto dfs = [&](auto& slf, int u) -> void {\n        vis[u] = 1;\n        for (auto [v, cost] : g[u]) {\n            if (dis[v] + cost == dis[u]) {\n                ans += cost;\n                if (vis[v]) continue;\n                slf(slf, v);\n            }\n        }\n    };\n    dfs(dfs, b);\n\n    cout << ans << endl;\n\n    return 0;\n}D. å•æ‰€ç®¡ç†å‘˜é¦–å…ˆæŠŠæ‰€æœ‰äººæŒ‰ deadline å½’ç±»ï¼Œç„¶åä»å°åˆ°å¤§éå† deadlineï¼Œæˆ‘ä»¬ç»´æŠ¤åˆ°å½“å‰æ—¶é—´ç‚¹ï¼Œä¸¤ç§å‘ä½èƒ½è®©å¤šå°‘äººä¸Šå®Œå•æ‰€ï¼Œå‡è®¾å½“å‰çš„ deadline ä¸º ï¼Œä¸Šä¸€ä¸ª deadline ä¸º ï¼Œé‚£ä¹ˆæˆ‘ä»¬èƒ½å¤šè®©  çš„ä¸éœ€è¦å•çº¸çš„äººä¸Šå®Œå•æ‰€ï¼Œèƒ½å¤šè®©  éœ€è¦å•çº¸çš„äººä¸Šå®Œå•æ‰€ã€‚å¯¹äºå½“å‰ deadlineï¼Œæˆ‘ä»¬å…ˆè®©ä¸éœ€è¦å•çº¸çš„äººå°½é‡å»æ²¡æœ‰å•çº¸çš„å‘ä½ï¼Œå¦‚æœå‰©ä¸‹çš„ä¸éœ€è¦å•çº¸çš„äººï¼ˆå¦‚æœæœ‰ï¼‰åŠ ä¸Šéœ€è¦å•çº¸çš„äººå¤§äºæœ‰å•çº¸çš„å‘ä½èƒ½è®©äººä¸Šå®Œå•æ‰€æ˜¯æ•°é‡ï¼Œç­”æ¡ˆå°±æ˜¯ Noï¼Œå¦åˆ™æˆ‘ä»¬ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ª deadlineã€‚#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int s, n;\n    cin >> s >> n;\n\n    map<int, array<int, 2>> cnt;\n    for (int i = 0; i < n; i++) {\n        int deadline;\n        char c;\n        cin >> deadline >> c;\n        cnt[deadline][c == 'y']++;\n    }\n\n    ll have[2] {}; // åˆ°å½“å‰æ—¶é—´ç‚¹ï¼Œä¸¤ç§å‘ä½èƒ½è®©å¤šå°‘äººä¸Šå®Œå•æ‰€\n    int prev = 0;\n\n    for (const auto [deadline, v] : cnt) {\n        have[1] += deadline - prev;\n        have[0] += ll(deadline - prev) * (s - 1);\n        prev = deadline;\n\n        auto [dont_need, need] = v;\n\n        ll no_paper = min((ll)dont_need, have[0]); // å»æ²¡æœ‰å•çº¸çš„å‘ä½çš„äººæ•°\n        dont_need -= no_paper;\n        have[0] -= no_paper;\n\n        if (dont_need + need > have[1]) { // å‰©ä¸‹çš„äººåªèƒ½å»æœ‰å•çº¸çš„å‘ä½ï¼Œå¦‚æœè¶…å‡ºäº†å°±æ˜¯no\n            cout << \"No\\n\";\n            return 0;\n        }\n        have[1] -= dont_need + need;\n    }\n    cout << \"Yes\\n\";\n    return 0;\n}E. è¿™ä¸€æ ·å—ï¼Ÿæ¨¡æ‹Ÿé¢˜ï¼Œæ²¡ä»€ä¹ˆæ€ç»´éš¾åº¦ã€‚ä¸€ç§æ¯”è¾ƒå¥½æƒ³çš„åšæ³•å¯èƒ½æ˜¯å…ˆé¢„å¤„ç†å‡ºé…å¯¹çš„æ‹¬å·ï¼Œæ¯ä¸€å¯¹æ‹¬å·å°±æ˜¯ä¸€ä¸ªå­æ ‘ï¼Œç„¶åè·‘ä¸€é dfsã€‚ä¸‹é¢ç»™å‡ºä¸€ä¸ªåªéå†ä¸€æ¬¡çš„å®ç°ã€‚ä¸€ä¸ªæ¯”è¾ƒå®¹æ˜“é”™çš„è¾“å…¥æ˜¯ä¸¤æ£µæ ‘éƒ½åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸”ç¼–å·ä¸ä¸€æ ·ï¼Œå¦‚æœä½ ç»™  æ¯ä¸ªèŠ‚ç‚¹éƒ½å¼€äº†ä¸€ä¸ªé‚»æ¥è¡¨ï¼Œé‚£ä¹ˆä½ å°†åˆ¤æ–­ä¸å‡ºæ¥ Noã€‚ä¸€ç§è§£å†³æ–¹æ³•æ˜¯æŠŠæ ¹èŠ‚ç‚¹è¿åˆ°èŠ‚ç‚¹ 0 ä¸Šã€‚#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    string s, t;\n    getline(cin, s);\n    getline(cin, t);\n    s = \"0(\" + s + \")\";\n    t = \"0(\" + t + \")\";\n\n    auto build = [&](const string& s) {\n        const int N = 1e6;\n        vector<vector<int>> g(N + 1);\n\n        string current_num;\n        vector<int> stack;\n\n        for (auto c : s) {\n            if (c == ' ') continue;\n\n            if (c == '(') {\n                if (!current_num.empty()) {\n                    int num = stoi(current_num);\n                    current_num.clear();\n                    if (!stack.empty()) {\n                        g[stack.back()].push_back(num);\n                    }\n                    stack.push_back(num);\n                }\n            } else if (c == ')') {\n                if (!current_num.empty()) {\n                    int num = stoi(current_num);\n                    current_num.clear();\n                    if (!stack.empty()) {\n                        g[stack.back()].push_back(num);\n                    }\n                    stack.push_back(num);\n                }\n                stack.pop_back();\n            } else {\n                current_num += c;\n            }\n        }\n\n        for (int i = 0; i <= N; i++) {\n            sort(begin(g[i]), end(g[i]));\n        }\n\n        return g;\n    };\n\n    auto gs = build(s), gt = build(t);\n    cout << (gs == gt ? \"Yes\\n\" : \"No\\n\");\n    return 0;\n}F. ç”µå½±ä¹‹å¤œå¦‚æœæˆ‘ä»¬æŠŠä¾èµ–å…³ç³»ï¼ˆï¼‰çœ‹æˆæ˜¯å›¾çš„è¯ï¼Œè¿™ç§æ¯ä¸ªç‚¹å‡ºåº¦ä¸º 1 çš„å›¾è¢«ç§°ä¸ºå‡½æ•°å›¾ï¼ˆfunctional graphï¼‰ã€‚å›¾çš„ç»“æ„ç”±ä¸€ä¸ªç¯ä»¥åŠä¸€äº›æŒ‚åœ¨ç¯ä¸Šçš„æ ‘æ„æˆã€‚å¯¹äºç¯ä¸Šçš„äººï¼Œä»–ä»¬è¦ä¹ˆéƒ½å»è¦ä¹ˆéƒ½ä¸å»ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠä»–ä»¬çœ‹æˆä¸€ä¸ªç‚¹ï¼Œè¿™æ ·å›¾å°±å˜æˆäº†ä¸€ä¸ªæœ‰å‘çš„æ ‘ã€‚æˆ‘ä»¬åœ¨æ ‘ä¸Š dpï¼Œå®šä¹‰  ä¸ºï¼šé‚€è¯·  ä¸”åŒæ—¶è®©  çš„å­æ ‘é‡Œçš„äººçš„è¦æ±‚éƒ½æ»¡è¶³çš„é‚€è¯·æ–¹å¼çš„æ•°é‡ï¼Œé‚£ä¹ˆçŠ¶æ€è½¬ç§»ä¸ºï¼šå¦‚æœæ€• dfs æ‰¾ç¯å†™é”™çš„è¯ä¹Ÿå¯ä»¥åˆ©ç”¨å¼ºè¿é€šåˆ†é‡æ¥ç¼©ç‚¹ã€‚#include <bits/stdc++.h>\n\n\nusing namespace std;\nusing ll = long long;\n\ninline auto scc(const std::vector<std::vector<int>>& g) -> std::pair<int, std::vector<int>> {\n    int n = (int)size(g);\n    int pos = 0;\n    std::vector<bool> on_stk(n);\n    std::vector<int> low(n), ord(n, -1), color(n), stk;\n    int cnt = 0;\n\n    auto dfs = [&](auto& slf, int u) -> void {\n        low[u] = ord[u] = pos++;\n        stk.push_back(u);\n        on_stk[u] = true;\n        for (auto v : g[u]) {\n            if (ord[v] == -1) slf(slf, v);\n            if (on_stk[v]) low[u] = std::min(low[u], low[v]);\n        }\n        if (low[u] == ord[u]) {\n            while (true) {\n                int v = stk.back();\n                stk.pop_back();\n                on_stk[v] = false;\n                color[v] = cnt;\n                if (u == v) break;\n            }\n            cnt++;\n        }\n    };\n\n    for (int i = 0; i < n; i++) {\n        if (ord[i] == -1) {\n            dfs(dfs, i);\n        }\n    }\n\n    return {cnt, color};\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        a[i]--;\n        g[i].push_back(a[i]);\n    }\n\n    auto [cnt, color] = scc(g);\n\n    const int mod = 1e9+7;\n    int ans = 1;\n    vector<vector<int>> g2(cnt); // ç¼©ç‚¹ä¹‹åçš„å›¾\n    vector<int> deg(cnt);\n    for (int i = 0; i < n; i++) {\n        if (color[a[i]] != color[i]) {\n            g2[color[a[i]]].push_back(color[i]);\n            deg[color[i]]++;\n        }\n    }\n\n    vector<int> dp(cnt, 1);\n    for (int i = cnt - 1; i >= 0; i--) {\n        for (auto v : g2[i]) {\n            dp[i] = (ll)dp[i] * (dp[v] + 1) % mod;\n        }\n    }\n\n    for (int i = 0; i < cnt; i++) {\n        if (deg[i] == 0) { // ä¸åŒåˆ†é‡ä¹‹é—´äº’ç›¸ç‹¬ç«‹\n            ans = (ll)ans * (dp[i] + 1) % mod;\n        }\n    }\n    cout << (ans - 1 + mod) % mod << endl;\n    return 0;\n}G. é€ç¤¼ç‰©ä¸å¦¨è€ƒè™‘æŒ‰  çš„å¤§å°éå†ç¤¼ç‰©ï¼Œå‡è®¾é€ç»™å°æ˜ç¤¼ç‰© ï¼Œé‚£ä¹ˆé€ç»™å°çº¢ä»»æ„  ä¹‹å‰çš„ç¤¼ç‰©éƒ½ä¸ä¼šä½¿å°æ˜å«‰å¦’ã€‚åŒæ—¶æˆ‘ä»¬è¿˜è¦ä¸èƒ½ä½¿å°çº¢å«‰å¦’ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦çŸ¥é“åœ¨å‰  ä¸ªç¤¼ç‰©ä¸­æœ‰å¤šå°‘ä¸ª  ä½¿å¾— ï¼Œæˆ‘ä»¬å¯ä»¥å°†  ç¦»æ•£åŒ–ä¹‹åç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤ã€‚æ›´æœ¬è´¨åœ°è¯´ï¼Œè¿™ä¸ªé¢˜æ˜¯äºŒç»´ååºé—®é¢˜ï¼ŒäºŒç»´ååºé—®é¢˜é€šå¸¸å…ˆæŒ‰å…¶ä¸­ä¸€ä¸ªç»´åº¦æ’åºç„¶åç”¨æ ‘çŠ¶æ•°ç»„è§£å†³ã€‚æ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥è‡ªè¡Œäº†è§£ã€‚#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T> struct Fenwick {\n    int n;\n    std::vector<T> t;\n\n    Fenwick(int n_) : n(n_), t(n + 1) {}\n    Fenwick(const std::vector<T> &v) : Fenwick((int)v.size()) {\n        for (int i = 1; i <= n; i++) {\n            t[i] += v[i - 1];\n            int j = i + (i & -i);\n            if (j <= n) t[j] += t[i];\n        }\n    }\n\n    void add(int i, const T& x) {\n        assert(i >= 0 && i < n);\n        for (i++; i <= n; i += i & -i) {\n            t[i] += x;\n        }\n    }\n\n    // Returns `data[0] + ... + data[i - 1]`.\n    template <typename U = T> U get(int i) {\n        assert(i >= 0 && i <= n);\n        U res{};\n        for (; i > 0; i -= i & -i)\n            res += t[i];\n        return res;\n    }\n\n    // Returns `data[l] + ... + data[r - 1]`.\n    template <typename U = T> U get(int l, int r) {\n        assert(l >= 0);\n        assert(l <= r);\n        assert(r <= n);\n        return get<U>(r) - get<U>(l);\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<int> a(n), b(n);\n    for (auto& x : a) {\n        cin >> x;\n    }\n    for (auto& x : b) {\n        cin >> x;\n    }\n\n    auto compress = b;\n    sort(begin(compress), end(compress));\n    compress.erase(unique(begin(compress), end(compress)), end(compress));\n    for (auto& x : b) {\n        x = lower_bound(begin(compress), end(compress), x) - begin(compress);\n    }\n\n    vector<int> order(n);\n    iota(begin(order), end(order), 0);\n    sort(begin(order), end(order), [&](int i, int j) { return a[i] < a[j]; });\n\n    Fenwick<int> tr(n);\n    ll ans = 0;\n    for (int i = 0, j = 0; i < n; ) {\n        while (j < n && a[order[i]] == a[order[j]]) {\n            tr.add(b[order[j]], 1);\n            j++;\n        }\n\n        while (i < j) {\n            ans += tr.get(b[order[i]], n);\n            i++;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}H. å¾ªç¯æ’åºå¦‚æœ  ä¸­æœ‰é‡å¤çš„å…ƒç´ çš„è¯ï¼Œä¸å¤±ä¸€èˆ¬æ€§åœ°ï¼Œå‡è®¾æœ‰ä¸¤ä¸ª 1ï¼Œé¦–å…ˆæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ä¸€æ¬¡æ“ä½œå°†ä¸¤ä¸ª 1 æ”¾åˆ° 1 å’Œ 2 çš„ä½ç½®ã€‚ç„¶åæˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸¤ä¸ª 1 æ¥äº¤æ¢ä»»æ„ä¸¤ä¸ªä½ç½®ï¼šå‡è®¾æˆ‘ä»¬è¦äº¤æ¢  ()ï¼Œæˆ‘ä»¬åªéœ€è¦åº”ç”¨æ“ä½œ  å’Œ  å³å¯äº¤æ¢ ã€‚å¦‚æœ  ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ï¼Œè¯´æ˜  æ˜¯ä¸€ä¸ªé•¿ä¸º  çš„æ’åˆ—ã€‚æˆ‘ä»¬ä¸å¦¨ä»é€†å…ƒçš„è§’åº¦å…¥æ‰‹ï¼Œé¢˜ç›®ä¸­çš„æ“ä½œæœ¬è´¨ä¸Šå°±æ˜¯å…ˆäº¤æ¢ ï¼Œå†äº¤æ¢ ï¼Œç”±äºä¸€æ¬¡äº¤æ¢æ“ä½œä¼šä½¿æ•´ä¸ªåºåˆ—çš„é€†å…ƒä¸ªæ•°çš„å¥‡å¶æ€§æ”¹å˜ï¼ˆæƒ³æƒ³ä¸ºä»€ä¹ˆï¼‰ï¼Œæ‰€ä»¥å¾ªç¯æ“ä½œä¸ä¼šä½¿æ•´ä¸ªåºåˆ—çš„é€†å…ƒä¸ªæ•°çš„å¥‡å¶æ€§æ”¹å˜ï¼Œæ‰€ä»¥ä¸å¦¨å¤§èƒ†çŒœæƒ³å½“ä¸”ä»…å½“æ•´ä¸ªåºåˆ—çš„é€†å…ƒçš„ä¸ªæ•°ä¸ºå¶æ•°ä¸ªæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¾ªç¯æ“ä½œæ’åºã€‚ä¸‹é¢ç»™å‡ºå½“é€†å…ƒä¸ªæ•°ä¸ºå¶æ•°ä¸ªæ—¶å¯ä»¥é€šè¿‡å¾ªç¯æ“ä½œæ’åºçš„è¯æ˜ï¼šè€ƒè™‘å°†  ä¾æ¬¡æ”¾åˆ°ç¬¬  ä¸ªä½ç½®ï¼Œå¯¹äºæ¯ä¸€ä¸ª  æˆ‘ä»¬å¯ä»¥ç”¨ä¸€æ¬¡å¾ªç¯æ“ä½œåœ¨ä¸ç ´åä¹‹å‰æ’å¥½åºçš„å…ƒç´ çš„æƒ…å†µä¸‹æŠŠ  æ”¾åˆ°ä½ç½® ã€‚åœ¨æ’å¥½å‰  ä¸ªå…ƒç´ ä¹‹åï¼Œç”±äºæˆ‘ä»¬æ²¡æœ‰æ”¹å˜é€†åºå¯¹çš„å¥‡å¶æ€§ï¼Œæ‰€ä»¥æœ€åå‰©ä¸‹çš„ä¸¤ä¸ªå…ƒç´ ä¹Ÿä¸€å®šæ˜¯æœ‰åºçš„ã€‚æ›´æœ¬è´¨çš„ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä»æ’åˆ—ï¼ˆpermutationï¼‰çš„è§’åº¦æ¥çœ‹è¿™ä¸ªé—®é¢˜ï¼Œå®šä¹‰ä¸€ä¸ªæ’åˆ—çš„å¥‡å¶æ€§ä¸ºå®ƒçš„é€†åºå¯¹æ•°é‡çš„å¥‡å¶æ€§ã€‚ä¸‰å¾ªç¯å¯ä»¥ç”¨æ’åˆ—æ¥è¡¨ç¤ºï¼Œæ‰€æœ‰å¶æ’åˆ—éƒ½å¯ä»¥è¡¨ç¤ºä¸ºä¸‰å¾ªç¯æ’åˆ—çš„å¤åˆã€‚æƒ³æ·±å…¥äº†è§£çš„è¯å¯ä»¥çœ‹è¿™ç¯‡è‹±æ–‡åšå®¢ï¼ˆä¸ç”¨å…¨çœ‹ï¼ŒæŒ‘è‡ªå·±æ„Ÿå…´è¶£çš„å³å¯ï¼‰ã€‚#include <bits/stdc++.h>\n\n// å½’å¹¶æ’åºæ±‚é€†åºå¯¹ä¸ªæ•°\ntemplate<typename T>\nint64_t count_inversion(const std::vector<T>& v) {\n    auto a(v);\n    std::vector<T> tmp(v.size());\n    int64_t cnt{};\n    auto merge = [&](auto& slf, int l, int r) {\n        if (r - l <= 1) {\n            return;\n        }\n        int mid = l + (r - l) / 2;\n        slf(slf, l, mid);\n        slf(slf, mid, r);\n        for (int i = l, j = mid, k = l; k < r; k++) {\n            if (j == r || (i < mid && a[i] <= a[j])) {\n                tmp[k] = a[i++];\n            } else {\n                tmp[k] = a[j++];\n                cnt += mid - i;\n            }\n        }\n        std::copy(tmp.begin() + l, tmp.begin() + r, a.begin() + l);\n    };\n    merge(merge, 0, (int)v.size());\n    return cnt;\n}\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n    for (auto& x : a) {\n        cin >> x;\n        x--;\n    }\n\n    if (set(begin(a), end(a)).size() != n) {\n        cout << \"Yes\\n\";\n        return 0;\n    }\n\n    cout << (count_inversion(a) % 2 ? \"No\\n\" : \"Yes\\n\");\n    return 0;\n}I. é€ç¤¼ç‰©2æœ¬é¢˜åšæ³•ä¸å”¯ä¸€ï¼Œä¸‹é¢ä»‹ç» dp åšæ³•ï¼šä¸éš¾æƒ³åˆ°ä¸€ç§ dp çŠ¶æ€ ï¼Œä»£è¡¨å‰  ä¸ªæ•°ä¸­ï¼Œæ˜¯å¦å­˜åœ¨å’Œä¸º  ä¸”å¤§å°ä¸º  çš„å­é›†ã€‚æœ¬æ¥æƒ³å¡æ‰è¿™ä¸ªåšæ³•çš„ï¼Œå’Œæ˜“è€å¸ˆä»¥åŠä¼è€å¸ˆè®¨è®ºä¹‹åè¿˜æ˜¯æ”¾å¼ƒäº†ï¼Œä¸‹é¢æ˜¯ä¼˜åŒ–åçš„åšæ³•ï¼šè®¾  ä¸ºå‰  ä¸ªæ•°ä¸­ï¼Œå’Œä¸º  çš„å­é›†çš„å¤§å°çš„é›†åˆã€‚ä¾‹å¦‚ï¼Œå‡è®¾ï¼Œå› ä¸º ï¼Œé‚£ä¹ˆ ã€‚é‚£ä¹ˆçŠ¶æ€è½¬ç§»æ˜¯æ˜¾ç„¶çš„ï¼šå¦‚æœæˆ‘ä»¬ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºé›†åˆçš„è¯ï¼Œè¿™ä¸ªçŠ¶æ€è½¬ç§»å¯ä»¥è¢«éå¸¸å®¹æ˜“çš„å†™æˆdp[i][sum + a[i]] |= dp[i - 1][sum] << 1;è¿™ä¸ªä¼˜åŒ–æŠ€å·§åœ¨æ‰¾å“ˆå¯†é¡¿è·¯å¾„ç®—æ³•ä¸­ä¹Ÿæœ‰åº”ç”¨ã€‚#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n    for (auto &x : a) {\n        cin >> x;\n    }\n\n    int sum = accumulate(begin(a), end(a), 0);\n\n    vector dp(sum + 1, 0);\n    dp[0] = 1;\n\n    for (auto x : a) {\n        for (int i = sum - x; i >= 0; i--) {\n            dp[i + x] |= dp[i] << 1;\n        }\n    }\n\n    for (int j = 0; j <= sum; j++) {\n        for (int i = 1; i < n; i++) {\n            if ((dp[j] >> i & 1) && i * (sum - j) == j * (n - i)) {\n                cout << \"Yes\\n\";\n                return 0;\n            }\n        }\n    }\n    cout << \"No\\n\";\n    return 0;\n}J. å¯»å®ä¸éš¾çœ‹å‡ºè¿™ä¸ªæ˜¯ bfsï¼ˆåªæ˜¯çŠ¶æ€æœ‰ç‚¹å¤æ‚ï¼‰ï¼Œç”±äºæ•°æ®èŒƒå›´æ¯”è¾ƒå°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥è®°å½•å½“å‰åœ¨ç¬¬å‡ ä¸ªå•è¯çš„ç¬¬å‡ ä¸ªä½ç½®ã€‚ç”±äºä¸èƒ½ç»è¿‡åŒä¸€ä¸ªä½ç½®ä¸¤æ¬¡ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨ä¸€è¡Œé‡Œåªèƒ½å‘å·¦æˆ–è€…å‘å³ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜è¦è®°å½•å½“å‰çš„æ–¹å‘ã€‚æ‰€ä»¥æˆ‘ä»¬ bfs çš„çŠ¶æ€å°±æ˜¯ ï¼Œä»£è¡¨åˆ°è¾¾  è¿™ä¸ªä½ç½®ï¼Œå½“å‰å­—æ¯æ˜¯ç¬¬  ä¸ªå•è¯çš„ç¬¬  ä½ç½®ï¼Œä¸”å½“å‰æ–¹å‘æ˜¯  çš„æœ€çŸ­è·¯å¾„ã€‚å…·ä½“å®ç°ç»†èŠ‚è¯·çœ‹ä»£ç ã€‚#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconstexpr int N = 50;\nint dis[N][N][N][N][3];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector a(n, vector<char>(m));\n    vector<string> words(k);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> a[i][j];\n        }\n    }\n    for (auto &s : words) {\n        cin >> s;\n    }\n\n    queue<array<int, 5>> q;\n    memset(dis, -1, sizeof(dis));\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < k; j++) {\n            if (a[0][i] == words[j][0]) {\n                dis[0][i][j][0][0] = 0;\n                q.push({0, i, j, 0, 0});\n            }\n        }\n    }\n\n    const vector<pair<int, int>> dir{{1, 0}, {0, 1}, {0, -1}};\n    auto update_dis = [](int &x, const int y) {\n        if (x == -1) {\n            x = y + 1;\n            return true;\n        }\n        return false;\n    };\n    while (!q.empty()) {\n        auto [i, j, word_idx, char_idx, d] = q.front();\n        q.pop();\n\n        for (int dir_idx = 0; dir_idx < 3; dir_idx++) {\n            auto [di, dj] = dir[dir_idx];\n            if (d != 0 && dir_idx != 0 && dir_idx != d) {\n                continue;\n            }\n            int next_i = i + di, next_j = j + dj;\n            if (next_i < n && next_j >= 0 && next_j < m) {\n                if (char_idx == words[word_idx].size() - 1) { // å½“å‰æ˜¯ä¸€ä¸ªå•è¯çš„ç»“å°¾\n                    for (int next_word = 0; next_word < k; next_word++) { // æ£€æŸ¥æ˜¯å¦åŒ¹é…ä»»æ„å•è¯çš„ç¬¬ä¸€ä¸ªå­—ç¬¦\n                        if (a[next_i][next_j] == words[next_word][0]) {\n                            if (update_dis(dis[next_i][next_j][next_word][0][dir_idx],\n                                           dis[i][j][word_idx][char_idx][d])) {\n                                q.push({next_i, next_j, next_word, 0, dir_idx});\n                            }\n                        }\n                    }\n                } else {\n                    if (a[next_i][next_j] == words[word_idx][char_idx + 1]) { // æ£€æŸ¥æ˜¯å¦åŒ¹é…ä¸‹ä¸€ä¸ªå­—ç¬¦\n                        if (update_dis(\n                                dis[next_i][next_j][word_idx][char_idx + 1][dir_idx],\n                                dis[i][j][word_idx][char_idx][d])) {\n                            q.push({next_i, next_j, word_idx, char_idx + 1, dir_idx});\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 1e9;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < k; j++) {\n            for (int d = 0; d < 3; d++) {\n                auto x = dis[n - 1][i][j][words[j].size() - 1][d];\n                if (x != -1) {\n                    ans = min(ans, x);\n                }\n            }\n        }\n    }\n    if (ans == 1e9) {\n        cout << \"impossible\\n\";\n    } else {\n        cout << ans + 1 << '\\n';\n    }\n    return 0;\n}K. æ—…è¡Œè®°å½•é¦–å…ˆæˆ‘ä»¬è·‘ä¸€éæœ€çŸ­è·¯ï¼Œå¯¹äºæ¯ä¸ªç‚¹ï¼Œå¦‚æœåˆ°è¿™ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»åœ¨é‡Œç¨‹è®°å½•é‡Œå‡ºç°è¿‡ï¼Œæˆ‘ä»¬å°±æ ‡è®°è¿™ä¸ªç‚¹ã€‚æˆ‘ä»¬è¦æ‰¾çš„å°±æ˜¯ä¸€æ¡ç»è¿‡  ä¸ªæ ‡è®°è¿‡çš„ç‚¹åˆ°è¾¾ç‚¹  çš„è·¯å¾„ï¼Œå¹¶ä¸”è·¯å¾„æ˜¯æœ€çŸ­è·¯ã€‚è€ƒè™‘ä»ç‚¹ 1 èµ·å§‹çš„æ‰€æœ‰æœ€çŸ­è·¯ä¸Šçš„æ‰€æœ‰è¾¹æ‰€æ„æˆçš„å­å›¾ï¼Œå¦‚æœæˆ‘ä»¬å°†è¿™äº›è¾¹å®šå‘ï¼ˆä»ç¦»ç‚¹ 1 è¿‘çš„ç‚¹æŒ‡å‘ç¦»ç‚¹ 1 è¿œçš„ç‚¹ï¼‰ï¼Œæˆ‘ä»¬å°†ä¼šå¾—åˆ°ä¸€ä¸ª DAGã€‚è¿™ä¸ªDAGä¸Šä»ç‚¹ 1 åˆ°ç‚¹  çš„ä»»æ„è·¯å¾„éƒ½æ˜¯ä¸€æ¡æœ€çŸ­è·¯ã€‚ç”±äºæ˜¯ DAGï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰æ‹“æ‰‘åº dpï¼Œä»¤  ä¸ºåˆ°è¾¾  æ—¶ç»è¿‡çš„æœ€å¤šæ ‡è®°çš„ç‚¹çš„æ•°é‡ï¼Œä»¤  æ˜¯å¦æœ‰å¤šæ¡è¿™æ ·çš„è·¯å¾„ã€‚çŠ¶æ€è½¬ç§»çš„ä»£ç ï¼šfor (int v : g[u]) { // g æ˜¯ä¸Šé¢æåˆ°çš„DAG\n    if (dp[u] + marked[v] > dp[v]) {\n        dp[v] = dp[u] + seen[v];\n        multi[v] = multi[u];\n        prev[v] = u;\n    } else if (dp[u] + seen[v] == dp[v]) {\n        multi[v] = 1;\n    }\n}#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m, d;\n    cin >> n >> m >> d;\n    vector<vector<array<int, 2>>> g(n);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        u--, v--;\n        g[u].push_back({v, w});\n    }\n\n    set<ll> log;\n    for (int i = 0; i < d; i++) {\n        ll t;\n        cin >> t;\n        log.insert(t);\n    }\n\n    constexpr long long INF = 1e18;\n    vector dis(n, INF);\n\n    using node = std::pair<long long, int>;\n    priority_queue<node, vector<node>, greater<>> q;\n    dis[0] = 0;\n    q.emplace(0, 0);\n    while (!q.empty()) {\n        auto [d, u] = q.top();\n        q.pop();\n        if (d != dis[u]) continue;\n        for (auto [v, cost] : g[u]) {\n            if (dis[v] > d + cost) {\n                dis[v] = d + cost;\n                q.emplace(dis[v], v);\n            }\n        }\n    }\n\n    vector<int> seen(n);\n    for (int i = 0; i < n; i++) {\n        if (log.count(dis[i])) {\n            seen[i] = 1;\n        }\n    }\n\n    vector<int> order(n);\n    iota(begin(order), end(order), 0);\n    // æŒ‰è·ç¦»æ’åºæ˜¯ä¸€ç§åˆæ³•çš„æ‹“æ‰‘åº\n    sort(begin(order), end(order), [&](int i, int j) { return dis[i] < dis[j]; });\n\n    vector<int> dp(n, -1), multi(n), prev(n);\n    dp[0] = seen[0];\n    for (auto u : order) {\n        for (auto [v, w] : g[u]) {\n            if (dis[u] + w == dis[v]) { // è¿™æ˜¯ä¸€æ¡æœ€çŸ­è·¯ä¸Šçš„è¾¹\n                if (dp[u] + seen[v] > dp[v]) {\n                    dp[v] = dp[u] + seen[v];\n                    multi[v] = multi[u];\n                    prev[v] = u;\n                } else if (dp[u] + seen[v] == dp[v]) {\n                    multi[v] = 1;\n                }\n            }\n        }\n    }\n\n    if (dp[n - 1] != d) {\n        cout << \"0\\n\";\n    } else if (multi[n - 1]) {\n        cout << \"1\\n\";\n    } else {\n        vector<int> path;\n        int u = n - 1;\n        while (u != 0) {\n            path.push_back(u);\n            u = prev[u];\n        }\n        path.push_back(0);\n        reverse(begin(path), end(path));\n        cout << size(path) << '\\n';\n        for (auto x : path) {\n            cout << x + 1 << '\\n';\n        }\n    }\n    return 0;\n}L. å½©ç¥¨æšä¸¾è¢«æ¶‚é»‘ä¸¤æ¬¡çš„æ ¼å­çš„ä¸ªæ•°ï¼Œå‡è®¾æœ‰  ä¸ªæ ¼å­è¢«æ¶‚é»‘äº†ä¸¤æ¬¡ã€‚é¦–å…ˆæˆ‘ä»¬å…ˆé€‰æ‹©ç¬¬  ä¸ªçƒçš„ç¼–å·ï¼Œå®ƒå¯ä»¥æ˜¯æˆ‘ä»¬å¡«çš„  ä¸ªæ•°ä¸­çš„ä»»æ„ä¸€ä¸ªã€‚å‰  ä¸ªçƒä¸­ï¼Œæœ‰  ä¸ªæ•°æ˜¯æˆ‘ä»¬å¡«çš„ï¼Œæˆ‘ä»¬å…ˆé€‰è¢«æ¶‚é»‘ä¸¤æ¬¡çš„æ ¼å­ï¼Œæœ‰  ç§é€‰æ³•ï¼Œåœ¨å‰©ä¸‹æ¯ä¸ªåªæ¶‚é»‘ä¸€æ¬¡çš„æ ¼å­ä¸­æˆ‘ä»¬é€‰ä¸€ä¸ªæ•°ï¼Œæœ‰  ä¸­é€‰æ³•ã€‚å‰  ä¸ªçƒä¸­æ²¡å‡ºç°åœ¨çº¸ä¸Šçš„æœ‰ ã€‚æœ€åå‰  ä¸ªçƒæœ‰  ç§é¡ºåºï¼Œç¬¬  ä¸ªçƒåé¢çš„  ä¸ªçƒæœ‰ ç§é¡ºåºã€‚æ‰€ä»¥ç­”æ¡ˆä¸ºï¼š#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    ModInt(ll v = 0) : val(v % MOD) { if (val < 0) val += MOD; };\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const {\n        auto a = val, m = MOD, u = 0, v = 1;\n        while (a != 0) { auto t = m / a; m -= t * a; swap(a, m); u -= t * v; swap(u, v); }\n        assert(m == 1);\n        return u;\n    }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    friend ModInt operator+ (ModInt lhs, const ModInt& rhs) { return lhs += rhs; }\n    friend ModInt operator- (ModInt lhs, const ModInt& rhs) { return lhs -= rhs; }\n    friend ModInt operator* (ModInt lhs, const ModInt& rhs) { return lhs *= rhs; }\n    friend ModInt operator/ (ModInt lhs, const ModInt& rhs) { return lhs /= rhs; }\n    ModInt& operator+=(const ModInt& x) { if ((val += x.val) >= MOD) val -= MOD; return *this; }\n    ModInt& operator-=(const ModInt& x) { if ((val -= x.val) < 0) val += MOD; return *this; }\n    ModInt& operator*=(const ModInt& x) { val = int64_t(val) * x.val % MOD; return *this; }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<1'000'000'007>;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m, p;\n    cin >> m >> n >> p;\n    if (n == 0 && p == 0) {\n        cout << 1 << endl;\n        return 0;\n    }\n\n    if (p < n || p == m) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    vector<mint> fac(m + 1), pow(m + 1), invfac(m + 1);\n    fac[0] = pow[0] = 1;\n    for (int i = 1; i <= m; i++) {\n        fac[i] = fac[i - 1] * i;\n        pow[i] = pow[i - 1] * 2;\n    }\n\n    invfac[m] = fac[m].inv();\n    for (int i = m - 1; i >= 0; i--) {\n        invfac[i] = invfac[i + 1] * (i + 1);\n    }\n\n    auto C = [&](int n, int k) -> mint {\n        if (k > n || k < 0) return 0;\n        return fac[n] * invfac[k] * invfac[n - k];\n    };\n\n    mint tot = fac[m];\n    mint win = 0;\n\n    for (int i = 0; i < n; i++) { // æšä¸¾è¢«æ¶‚äº†ä¸¤æ¬¡çš„æ ¼å­çš„ä¸ªæ•°\n        win += C(n - 1, i) * pow[n - 1 - i] * C(m - 2 * n, p - 1 - (n - 1 + i)) * 2 * n * fac[p - 1] * fac[m - p];\n    }\n\n    cout << win / tot << endl;\n    return 0;\n}M. è¿é€šåˆ†é‡è®¡æ•°è€ƒè™‘æ ‘å½¢ dpï¼Œè®¾  ä¸ºé€‰æ‹©  çš„å­æ ‘ä¸­çš„èŠ‚ç‚¹çš„æ–¹å¼ï¼Œä½¿å¾—å¯¼å‡ºå­å›¾ä¸­æœ‰  ä¸ªè¿é€šåˆ†é‡ï¼Œ ä»£è¡¨èŠ‚ç‚¹  æ˜¯å¦è¢«é€‰æ‹©ã€‚è½¬ç§»æ¯”è¾ƒæš´åŠ›ï¼Œæˆ‘ä»¬ç›´æ¥çœ‹ dfs çš„ä»£ç ï¼šauto dfs(int u, int p) -> vector<vector<mint>> {\n    vector dp(2, vector<mint>(2));\n    dp[0][0] = 1;\n    dp[1][1] = 1;\n\n    for (auto v : g[u]) {\n        if (v == p) continue;\n\n        auto res = dfs(v, u);\n\n        // æ¯æ¬¡å°† v å­æ ‘çš„ç»“æœåŠ å…¥å½“å‰ç»“æœä¸­ï¼Œæ‰€ä»¥æ–°çš„ç»“æœæœ€å¤šæœ‰dp.size() + res.size() \n        // ä¸ªè¿é€šåˆ†é‡\n        vector ndp(dp.size() + res.size() - 1, vector<mint>(2, 0));\n        for (int i = 0; i < (int)dp.size(); i++) {\n            for (int j = 0; j < (int)res.size(); j++) {\n                // ä¸é€‰ u çš„æ—¶å€™ï¼Œå­æ ‘ä¸­çš„è¿é€šåˆ†é‡äº’ä¸å¹²æ‰°ï¼Œ\n                // æ‰€ä»¥è¿é€šåˆ†é‡çš„ä¸ªæ•°ä¸º i + j\n                ndp[i + j][0] += dp[i][0] * (res[j][0] + res[j][1]);\n                // é€‰ u çš„æ—¶å€™ï¼Œå¦‚æœ v ä¸é€‰ï¼Œè¿é€šåˆ†é‡çš„ä¸ªæ•°ä¹Ÿæ˜¯ç›´æ¥ç›¸åŠ \n                ndp[i + j][1] += dp[i][1] * res[j][0];\n                // å¦‚æœé€‰ u å¹¶ä¸”é€‰ v çš„è¯ï¼Œä¼šæœ‰ä¸¤ä¸ªè¿é€šåˆ†é‡ç›¸è¿ï¼Œ\n                // æ‰€ä»¥æ€»çš„è¿é€šåˆ†é‡ä¸ªæ•°ä¸º i + j - 1\n                if (i + j > 0) {\n                    ndp[i + j - 1][1] += dp[i][1] * res[j][1];\n                }\n            }\n        }\n        swap(dp, ndp);\n    }\n\n    return dp;\n};æ•´ä¸ª dfs ä¹ä¸€çœ‹æ˜¯  çš„ï¼Œå¦‚æœæˆ‘ä»¬åƒä¸Šé¢é‚£æ ·åªè½¬ç§»åˆ°å½“å‰å¤„ç†è¿‡å­æ ‘çš„å¤§å°ä¹‹å’Œï¼Œæ•´ä¸ªè¿‡ç¨‹å…¶å®æ˜¯  çš„ï¼ˆè¯æ˜ç•¥ï¼Œæˆ‘ä¹Ÿä¸ä¼šï¼‰ã€‚#include <bits/stdc++.h>\ntemplate <typename T, T MOD>\nstruct ModInt {\n    using prod_type = std::conditional_t<std::is_same_v<T, int>, long long, __int128>;\n    T val;\n    ModInt(const prod_type v = 0) : val(v % MOD) { if (val < 0) val += MOD; };\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const {\n        auto a = val, m = MOD, u = 0, v = 1;\n        while (a != 0) {\n            auto t = m / a;\n            m -= t * a;\n            std::swap(a, m);\n            u -= t * v;\n            std::swap(u, v);\n        }\n        assert(m == 1);\n        return u;\n    }\n    ModInt pow(prod_type n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1)\n                x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    friend ModInt operator+(ModInt lhs, const ModInt &rhs) { return lhs += rhs; }\n    friend ModInt operator-(ModInt lhs, const ModInt &rhs) { return lhs -= rhs; }\n    friend ModInt operator*(ModInt lhs, const ModInt &rhs) { return lhs *= rhs; }\n    friend ModInt operator/(ModInt lhs, const ModInt &rhs) { return lhs /= rhs; }\n    ModInt &operator+=(const ModInt &x) {\n        if ((val += x.val) >= MOD)\n            val -= MOD;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &x) {\n        if ((val -= x.val) < 0)\n            val += MOD;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &x) {\n        val = prod_type(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &x) { return *this *= x.inv(); }\n    bool operator==(const ModInt &b) const { return val == b.val; }\n    bool operator!=(const ModInt &b) const { return val != b.val; }\n    friend std::istream &operator>>(std::istream &is, ModInt &x) noexcept {\n        return is >> x.val;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) noexcept {\n        return os << x.val;\n    }\n};\nusing ModInt1000000007 = ModInt<int, 1'000'000'007>;\nusing ModInt998244353 = ModInt<int, 998244353>;\nusing namespace std;\nusing ll = long long;\nusing mint = ModInt998244353;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<vector<int>> g(n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    auto dfs = [&](auto& slf, int u, int p) -> vector<vector<mint>> {\n        vector dp(2, vector<mint>(2));\n        dp[0][0] = 1;\n        dp[1][1] = 1;\n\n        for (auto v : g[u]) {\n            if (v == p) continue;\n\n            auto res = slf(slf, v, u);\n\n            vector ndp(dp.size() + res.size() - 1, vector<mint>(2, 0));\n            for (int i = 0; i < (int)dp.size(); i++) {\n                for (int j = 0; j < (int)res.size(); j++) {\n                    ndp[i + j][0] += dp[i][0] * (res[j][0] + res[j][1]);\n                    ndp[i + j][1] += dp[i][1] * res[j][0];\n                    if (i + j > 0) {\n                        ndp[i + j - 1][1] += dp[i][1] * res[j][1];\n                    }\n                }\n            }\n            swap(dp, ndp);\n        }\n\n        return dp;\n    };\n\n    auto res = dfs(dfs, 0, 0);\n    for (int i = 1; i <= n; i++) {\n        cout << res[i][0] + res[i][1] << '\\n';\n    }\n\n    return 0;\n}"},{"id":"cugb4tutr","title":"CUGBACM18çº§è®­ç»ƒ#4 é¢˜è§£","content":"B - Godfather Gym - 101649Gé¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªæœ‰nä¸ªç‚¹çš„æ ‘ï¼Œé—®å»æ‰å“ªä¸ªç‚¹åå‰©ä¸‹çš„æ ‘ä¸­æœ€å¤§çš„èŠ‚ç‚¹æ•°æœ€å°ï¼ˆå¦‚æœæœ‰å¤šä¸ªæŒ‰ä»å°åˆ°å¤§çš„é¡ºåºè¾“å‡ºï¼‰ã€‚æ€è·¯ï¼š ä¸€å¼€å§‹æ²¡çœ‹è§â€œä¿è¯æ˜¯ä¸€æ£µæ ‘â€æƒ³å¤æ‚äº†ï¼Œå…ˆè·‘ä¸€édfsåºï¼Œè¿™æ ·å°±èƒ½çŸ¥é“æ¯ä¸ªç‚¹é™¤äº†çˆ¶èŠ‚ç‚¹ä¹‹å¤–æ‰€æœ‰çš„å­æ ‘çš„å¤§å°äº†ï¼Œçˆ¶èŠ‚ç‚¹å¯¹åº”çš„â€œå­æ ‘â€çš„å¤§å°å°±æ˜¯nå‡å»æ‰€æœ‰å­æ ‘çš„å¤§å°ä¹‹å’Œã€‚éå†æ‰€æœ‰ç‚¹ï¼Œæ‰¾å‡ºæ‰€æœ‰â€œå­æ ‘â€ä¸­æœ€å¤§çš„é‚£ä¸ªï¼Œå°†å…¶å¤§å°å’Œç¼–å·ä½œä¸ºæ•°å¯¹åŠ å…¥æ•°ç»„ä¸­ï¼Œç„¶åå¯¹æ‰€æœ‰ç‚¹æ’åºï¼Œè¾“å‡ºæœ€å°çš„é‚£å‡ ä¸ªå°±è¡Œäº†ã€‚E - Wow! Such Doge! HDU - 4847é¢˜æ„ï¼š ç»™å‡ºä¸€ç¯‡æ–‡ç« ï¼Œé—®å…¶ä¸­å‡ºç°è¿‡å¤šå°‘ä¸ª\"doge\"ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰ã€‚æ€è·¯ï¼š å…ˆéå†æ–‡ç« ï¼Œå°†æ‰€æœ‰å¤§å†™ä¹‹æ¯è½¬ä¸ºå°å†™ï¼Œç„¶åå†ç”¨findæˆ–è€…æš´åŠ›æŸ¥æ‰¾\"doge\"å³å¯ã€‚G - Theme Section HDU - 4763é¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªå­—ç¬¦ä¸²næ‰¾å‡ºä¸€ä¸ªæœ€é•¿çš„å­ä¸²ï¼ˆthemeï¼‰ï¼Œä½¿å…¶å‡ºç°åœ¨å¼€å¤´ä¸­é—´å’Œç»“å°¾ï¼ˆä¸å…è®¸é‡å ï¼‰æ€è·¯ï¼š ä¸€å¼€å§‹è¢«æ ·ä¾‹è¯¯å¯¼äº†ï¼Œä»¥ä¸ºthemeé‡Œé¢åªèƒ½æœ‰ä¸€ç§å­—ç¬¦ï¼Œwaäº†å‡ å‘æ„Ÿè§‰ä¸å¯¹ï¼Œæ‰€ä»¥åº”è¯¥å…ˆè·‘å‰ç¼€å‡½æ•°ï¼Œç„¶åä»ä»ç¬¬äºŒä½éå†åˆ°å€’æ•°ç¬¬äºŒä½ï¼Œå¦‚æœæŸä¸€ä½å‰ç¼€å‡½æ•°å¤§äºå…¶åˆ°ç¬¬ä¸€ä½è·ç¦»çš„ä¸€åŠï¼Œåˆ™å–ä¸€åŠï¼Œæ‰¾å‡ºå…¶ä¸­çš„æœ€å¤§å€¼ï¼Œè¿™æ ·å°±å¾—åˆ°äº†å‡ºç°åœ¨ä¸­é—´çš„themeçš„æœ€å¤§é•¿åº¦ã€‚ç„¶åå†åˆ¤æ–­æœ€åä¸€ä½çš„å‰ç¼€é•¿åº¦æ˜¯å¦å¤§äºæ•´ä¸ªå­—ç¬¦ä¸²é•¿åº¦çš„ä¸‰åˆ†ä¹‹ä¸€ï¼Œå¦‚æœå¤§äºåˆ™å–ä¸‰åˆ†ä¹‹ä¸€ï¼Œè¿™æ ·å°±æ˜¯å‡ºç°åœ¨åé¢çš„themeçš„é•¿åº¦ï¼Œè¾“å‡ºä¸­é—´å’Œåé¢ä¸­æ¯”è¾ƒå°çš„ä¸€ä¸ªå³å¯ã€‚I - Path HDU - 6582ä¸ä¼šç½‘ç»œæµï¼Œæœ‰ç©ºå†è¡¥ã€‚"},{"id":"cugb6","title":"CUGBACM18çº§è®­ç»ƒ#6 é¢˜è§£","content":"A - Keywords Search HDU - 2222é¢˜æ„ï¼š ç»™å‡ºå•è¯å’Œæ–‡ç« ï¼Œé—®å¤šå°‘ä¸ªå•è¯åœ¨æ–‡ç« ä¸­å‡ºç°è¿‡ã€‚æ€è·¯ï¼š ACè‡ªåŠ¨æœºæ¿å­é¢˜ï¼Œä¹‹å‰ä¹Ÿè¯´è¿‡ï¼Œä¸å†èµ˜è¿°ã€‚B - ç—…æ¯’ä¾µè¢­ HDU - 2896é¢˜æ„ï¼š ç»™å‡ºnä¸ªå•è¯ï¼ˆç—…æ¯’ï¼‰å’Œmä¸ªé•¿ä¸²ï¼ˆæºç ï¼‰é—®æ¯ä¸ªé•¿ä¸²ä¸­æœ‰å“ªäº›å•è¯å‡ºç°è¿‡ä»¥åŠæœ‰å¤šå°‘ä¸ªæºç ä¸­æœ‰ç—…æ¯’ã€‚æ€è·¯ï¼š å’Œä¸Šä¸ªé¢˜ç±»ä¼¼ï¼Œå­—ç¬¦é›†ä¸åªæ˜¯26ä¸ªå­—æ¯äº†â€¦â€¦æ˜¯æ‰€æœ‰ASCIIå¯è§å­—ç¬¦ï¼Œä¸è¿‡å¼€åˆ°130å°±è¡Œï¼Œä¸ç”¨ç»Ÿè®¡å‡ºç°æ¬¡æ•°ï¼Œæ–°åŠ ä¸€ä¸ªæ•°ç»„è®°å½•ç—…æ¯’ç¼–å·åœ¨å­—å…¸æ ‘ä¸Šçš„ä½ç½®ï¼ŒæŸ¥è¯¢çš„æ—¶å€™å¦‚æœæŸä¸ªèŠ‚ç‚¹å¯¹åº”çš„ç—…æ¯’ç¼–å·ä¸ä¸º0å°±åŠ å…¥ç­”æ¡ˆæ•°ç»„ï¼Œæ’åºä¹‹åè¾“å‡ºï¼Œå¦‚æœç­”æ¡ˆæ•°ç»„çš„å¤§å°ä¸ä¸º0ï¼Œæ€»ä¸ªæ•°åŠ 1ï¼Œæœ€åè¾“å‡ºæ€»ä¸ªæ•°ã€‚C - Sliding Window POJ - 2823é¢˜æ„ï¼š æ•°ç»„é•¿åº¦ä¸º,é•¿åº¦ä¸ºçš„çª—æˆ·åœ¨æ•°ç»„ä¸Šæ»‘åŠ¨ï¼Œé—®æ¯æ¬¡æ»‘åŠ¨åçš„çª—æˆ·ä¸­çš„æœ€å¤§å’Œæœ€å°å€¼ã€‚æ€è·¯ï¼š ç”¨çº¿æ®µæ ‘æˆ–è€…stè¡¨å¤æ‚åº¦éƒ½æ˜¯ï¼Œå•è°ƒé˜Ÿåˆ—å¯ä»¥åšåˆ°ï¼Œå¦‚æœæ±‚æœ€å¤§å€¼å°±ç»´æŠ¤å•è°ƒé€’å¢åºåˆ—ï¼Œæ–¹æ³•å¦‚ä¸‹ï¼šä¸æ–­ä»é˜Ÿå°¾å‡ºåˆ—ï¼Œç›´åˆ°é˜Ÿå°¾å…ƒç´ å¤§äºå¾…å…¥é˜Ÿçš„æ•°ï¼Œå› ä¸ºåˆå°åˆé å‰é¢çš„æ•°è‡ªç„¶æ¯”ä¸ä¸Šåˆå¤§åˆé åçš„æ•°ã€‚ä¸æ–­ä»é˜Ÿé¦–å‡ºåˆ—ï¼Œç›´åˆ°é˜Ÿé¦–å…ƒç´ çš„ä¸‹æ ‡åœ¨çª—æˆ·çš„èŒƒå›´ä¹‹å†…ã€‚è¾“å‡ºé˜Ÿé¦–å…ƒç´ ï¼Œä¸ºå½“å‰çª—æˆ·çš„æœ€å¤§å€¼ã€‚æ±‚æœ€å°å€¼æ­¥éª¤ç±»ä¼¼ï¼Œå®é™…ç»´æŠ¤çš„æ—¶å€™ä¸ºäº†å®¹æ˜“å®ç°ç¬¬äºŒæ­¥ï¼Œé˜Ÿåˆ—ä¸­å­˜çš„æ˜¯ä¸‹æ ‡ã€‚D - Intersections Gym - 101853Cé¢˜æ„ï¼š ç»™å‡ºä¸¤è¡Œåºåˆ—ï¼Œè¿æ¥ç›¸åŒçš„æ•°ï¼Œé—®äº§ç”Ÿäº¤ç‚¹çš„ä¸ªæ•°ã€‚æ€è·¯ï¼š å¦‚æœä¸¤ä¸ªæ•°åœ¨ä¸Šä¸‹ä¸¤è¡Œä¸­çš„ç›¸å¯¹ä½ç½®å‘ç”Ÿäº†å˜åŒ–ï¼Œè¿çº¿çš„æ—¶å€™å°±ä¼šäº§ç”Ÿä¸€ä¸ªäº¤ç‚¹ã€‚åœ¨è¯»å…¥ç¬¬ä¸€è¡Œçš„æ—¶å€™è®°å½•æ¯ä¸ªæ•°åœ¨æ•°ç»„ä¸­çš„ä½ç½®ã€‚åœ¨è¯»å…¥ç¬¬äºŒè¡Œçš„æ—¶å€™å°†å…¶æ›¿æ¢ä¸ºè¯¥æ•°åœ¨ç¬¬ä¸€è¡Œçš„å‡ºç°ä½ç½®ï¼Œé‚£ä¹ˆé—®é¢˜å°±å˜æˆäº†æ±‚é€†åºå¯¹ï¼ˆï¼‰ä¸ªæ•°çš„é—®é¢˜ã€‚æœ‰ä¸¤ç§æ±‚æ³•ï¼šå½’å¹¶æ’åºå’Œæ ‘çŠ¶æ•°ç»„ã€‚è¿™é‡Œä»‹ç»æ ‘çŠ¶æ•°ç»„çš„åšæ³•ï¼šå°†æ‰€æœ‰çš„æ•°çš„åœ¨ç¬¬ä¸€è¡Œå‡ºç°çš„ä½ç½®å’Œåœ¨ç¬¬äºŒè¡Œå‡ºç°çš„ä½ç½®ä½œä¸ºæ•°å¯¹ä¿å­˜åœ¨æ•°ç»„ä¸­ï¼ŒæŒ‰ç…§ç¬¬ä¸€è¡Œå‡ºç°çš„ä½ç½®ä»å¤§åˆ°å°æ’åºï¼Œè¿™æ ·æ¯æ¬¡æ’å…¥ä¸€ä¸ªæ•°çš„æ—¶å€™å‰é¢æ•°å­—çš„ä¸ªæ•°å°±æ˜¯æ’å…¥è¿™ä¸ªæ•°äº§ç”Ÿæ–°çš„é€†åºå¯¹çš„ä¸ªæ•°ï¼Œå› ä¸ºæ•°ç»„æ˜¯ä»å¤§åˆ°å°æ’åºï¼Œæ­¤æ—¶å·²ç»æ’å…¥çš„æ•°éƒ½æ˜¯æ¯”å½“å‰æ•°å¤§çš„æ•°ï¼Œè€Œä½ç½®åœ¨å‰é¢çš„æ•°å°±æ˜¯ç¬¦åˆé€†åºå¯¹å®šä¹‰çš„æ•°ã€‚è€Œè¿™å°±å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„å®ç°ï¼Œè®¡ç®—å‰é¢æ•°çš„ä¸ªæ•°å°±æ˜¯ç®—å‰ç¼€å’Œï¼Œæ’å…¥å°±æ˜¯åœ¨ç¬¬äºŒæ¬¡å‡ºç°çš„ä½ç½®+1ã€‚E - ç»´æŠ¤åºåˆ— Gym - 237040Gé¢˜æ„ï¼š ç»´æŠ¤ä¸€ä¸ªåºåˆ—ï¼Œæ”¯æŒä»¥ä¸‹æ“ä½œï¼šæŠŠæ•°åˆ—ä¸­çš„ä¸€æ®µæ•°å…¨éƒ¨ä¹˜ä¸€ä¸ªå€¼ï¼›æŠŠæ•°åˆ—ä¸­çš„ä¸€æ®µæ•°å…¨éƒ¨åŠ ä¸€ä¸ªå€¼ï¼›è¯¢é—®æ•°åˆ—ä¸­çš„ä¸€æ®µæ•°çš„å’Œæ¨¡  çš„å€¼ã€‚æ€è·¯ï¼š çº¿æ®µæ ‘æ”¹æ¿å­é¢˜ï¼Œéœ€è¦åŠ¨ç‚¹è„‘å­ï¼Œä¹˜çš„æ—¶å€™åŠ å’Œä¹˜çš„lazy tagéƒ½è¦æ›´æ–°ã€‚å› ä¸º å…¶ä»–è²Œä¼¼å°±å¿˜ æ²¡ çš„  ä»€ å·® ä¹ˆ ä¸ å¥½ å¤š è¯´ äº† çš„äº†ã€‚F - Little Elephant and Array CodeForces - 220Bè§æˆ‘çš„å¦ä¸€ç¯‡æ–‡ç« G - Tourists Gym - 101002Ié¢˜æ„ï¼š ç»™å‡ºä¸€æ£µæ ‘ï¼Œè®¡ç®—æ‰€æœ‰ä¸¤ç«¯å…¶ä¸­ä¸€ä¸ªæ˜¯å¦ä¸€ä¸ªå€æ•°çš„è·¯å¾„é•¿åº¦å’Œã€‚æ€è·¯ï¼š è®¡ç®—æ ‘ä¸Šè·¯å¾„è‡ªç„¶è¦ç”¨åˆ°LCAï¼Œå°±æ˜¯ä¸ªå€å¢æ³•æ¿å­é¢˜ã€‚I - äºŒç»´æ ‘çŠ¶æ•°ç»„ ï¼šå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ Gym - 237040Eé¢˜æ„ï¼š è§é¢˜ç›®ã€‚æ€è·¯ï¼š è§é¢˜ç›®ã€‚K - Jzzhu and Cities CodeForces - 449Bé¢˜æ„ï¼š ä¸€ä¸ªå›¾ä¸­æœ‰æ¡é“è·¯å’Œæ¡é€šå¾€é¦–éƒ½ï¼ˆæ ‡å·ä¸º1çš„ç‚¹ï¼‰çš„é“è·¯ã€‚é—®æœ€å¤šå¯ä»¥å»æ‰å¤šå°‘é“è·¯ä½¿å¾—æ‰€æœ‰åŸå¸‚åˆ°é¦–éƒ½çš„æœ€çŸ­è·ç¦»ä¸å˜ã€‚æ€è·¯ï¼š æŠŠæ‰€æœ‰é“è·¯å’Œé“è·¯éƒ½æ”¾åˆ°å›¾é‡Œï¼Œdijkstraæ˜¯å¯ä»¥è®°å½•æœ€çŸ­è·¯è·¯å¾„æ¡æ•°çš„ï¼ï¼ˆå¥½åƒè€ƒè¯•è€ƒè¿‡ï¼Ÿï¼‰ï¼ŒåŸç†å°±æ˜¯å½“æ›´æ–°è·ç¦»çš„æ—¶å€™å¦‚æœå’Œå½“å‰æœ€çŸ­è·¯å¾„ä¸€æ ·é•¿å°±è·¯å¾„æ¡æ•°+1ï¼Œå¦‚æœæ›´çŸ­æ¡æ•°å°±ç½®ä¸º1ã€‚æœ€åéå†æ‰€æœ‰é“è·¯ï¼Œå¦‚æœå½“å‰é“è·¯æ¯”æœ€çŸ­è·¯é•¿é‚£ä¹ˆå°±å¯ä»¥å»æ‰ï¼Œå¦‚æœå’Œæœ€çŸ­è·¯ä¸€æ ·çš„è¯å°±è¦çœ‹æœ€çŸ­è·¯è¿˜å‰©å‡ æ¡ï¼Œå¦‚æœå¤§äº1çš„è¯å°±å¯ä»¥å»æ‰å¹¶ä¸”æŠŠæœ€çŸ­è·¯çš„æ¡æ•°-1ã€‚L - Alyona and the Tree CodeForces - 682Cé¢˜æ„ï¼š ç»™å‡ºä¸€æ£µè¾¹æƒç‚¹æƒæ ‘ï¼Œé—®æœ€å°‘å»æ‰å‡ ä¸ªç‚¹ä½¿å¾—ä¸å­˜åœ¨è¿™æ ·çš„ç‚¹ï¼šå…¶å­æ ‘ä¸Šå­˜åœ¨æŸç‚¹ï¼Œå…¶ç‚¹æƒå¤§äºåˆ°çš„è·ç¦»ã€‚æ€è·¯ï¼š è®¡ç®—æ ‘ä¸Šæ‰€æœ‰çš„è·ç¦»è‚¯å®šè¶…æ—¶ï¼Œä½†æ˜¯æœ‰è¿™æ ·ä¸€æ¡æ€§è´¨ï¼Œå¦‚æœè¾¹æƒéƒ½æ˜¯æ­£æ•°çš„è¯ï¼Œå¦‚æœé‚£ä¹ˆï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥åªè®¡ç®—åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»å°±è¡Œäº†ï¼Œä½†æ˜¯è¾¹æƒå¦‚æœæœ‰è´Ÿæ•°ä¸Šè¿°æ€§è´¨å°±ä¸æˆç«‹äº†ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ç¨åŠ æ”¹åŠ¨ï¼šå½“æˆ‘ä»¬dfsçš„æ—¶å€™ï¼Œå¦‚æœå½“å‰ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»å°äº0ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±åº”è¯¥å°†è·ç¦»ç½®ä¸º0ï¼Œç„¶åæ¥ç€dfs,è¿™æ ·å°±é¿å…äº†å‰é¢çš„è´Ÿæƒè·¯å¾„äº§ç”Ÿçš„å¹²æ‰°ã€‚"},{"id":"cugbacm3tutr","title":"CUGBACM18çº§è®­ç»ƒ#3 é¢˜è§£","content":"1.HDU1686é¢˜æ„ï¼š ç»™å‡ºä¸¤ä¸ªä¸² ï¼Œé—®åœ¨ä¸­å‡ºç°çš„æ¬¡æ•°ã€‚æ€è·¯ï¼š kmpæ¿å­é¢˜ï¼Œæ³¨æ„è¦ç”¨scanfã€‚2.HDU2594é¢˜æ„ï¼š ç»™å‡ºä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚æœ€é•¿çš„æ—¢æ˜¯å‰ç¼€åˆæ˜¯åç¼€çš„å­—ç¬¦ä¸²ã€‚æ€è·¯ï¼š å¾ˆæ˜æ˜¾å°±æ˜¯æŠŠä¸¤ä¸ªä¸²æ‹¼èµ·æ¥ç„¶åæ±‚å‰ç¼€å‡½æ•°ï¼Œä¸è¿‡è¦æ³¨æ„çš„æ˜¯æ‹¼èµ·æ¥çš„ä¸²çš„å‰ç¼€å‡½æ•°æœ‰å¯èƒ½è¶…è¿‡ç»™å‡ºçš„ä¸²çš„é•¿åº¦ï¼Œè§£å†³åŠæ³•å°±æ˜¯åœ¨ä¸¤ä¸ªä¸²ä¸­é—´åŠ ä¸€ä¸ªç¬¦å·ã€‚3.HDU6629é¢˜æ„ï¼š ç»™å‡ºå­—ç¬¦ä¸²é—®ç”¨æš´åŠ›ç®—æ³•æ±‚çš„Zå‡½æ•°ï¼ˆä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°ç»„ï¼Œå…¶ä¸­ç¬¬iä¸ªå…ƒç´ ä¸ºæ»¡è¶³ä»ä½ç½®iå¼€å§‹ä¸”ä¸ºså‰ç¼€çš„å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦ã€‚ï¼‰éœ€è¦çš„æ¯”è¾ƒæ¬¡æ•°ã€‚æ€è·¯ï¼š æ±‚æ¯ä¸€ä¸ªä½ç½®çš„æ¯”è¾ƒæ¬¡æ•°éƒ½ç­‰äºè¿™ä¸ªä½ç½®çš„zå‡½æ•°+1ï¼Œå› ä¸ºè¦å¾€åé¢å¤šæ¯”è¾ƒä¸€æ¬¡å‘ç°ä¸åŒ¹é…äº†æ‰ä¼šç»ˆæ­¢ï¼ˆå¦‚æœæ¯”è¾ƒåˆ°å­—ç¬¦ä¸²æœ«å°¾äº†å³i+z[i]>=nå°±ä¸ç”¨åŠ 1ï¼‰ï¼Œæ±‚å’Œå°±æ˜¯ç­”æ¡ˆã€‚4.Codeforces 1200Eé¢˜æ„ï¼š ç»™äº†ä½ nä¸ªå­—ç¬¦ä¸²ï¼Œç„¶åæŒ‰ç…§å¦‚ä¸‹æ–¹å¼åˆå¹¶å¾—åˆ°æ–°ä¸²:å¦‚æœä¸ºç©ºä¸²ï¼Œåˆ™ç›´æ¥åŠ å…¥ã€‚å¦åˆ™ï¼Œæ¯æ¬¡æ¯”è¾ƒçš„åç¼€ä¸å‰ç¼€ï¼Œå–å¤±é…ä½ç½®ä¹‹åçš„åç¼€åŠ å…¥ä¸­æ±‚sâ€²æ€è·¯ï¼š è®¾ç­”æ¡ˆä¸²çš„é•¿åº¦ä¸º,éœ€è¦åˆå¹¶çš„æ–°ä¸²çš„é•¿åº¦ä¸º,å°†â€œæ–°ä¸²+#+ç­”æ¡ˆä¸²åé¢é•¿çš„å­ä¸²â€ä½œä¸ºæ•´ä½“è·‘å‰ç¼€å‡½æ•°ï¼Œè®¾æ•´ä¸ªä¸²çš„æœ€é•¿å…¬å…±å‰åç¼€çš„é•¿åº¦ä¸º,å°†æ–°ä¸²ä¸‹æ ‡ä¸ºçš„å­ä¸²åŠ åˆ°ç­”æ¡ˆä¸²ä¹‹åã€‚5.HDU3613é¢˜æ„ï¼š ç»™å‡ºä¸€å­—ç¬¦ä¸²ï¼Œå…¶ä¸­æ¯ä¸€ç§å­—ç¬¦å¯¹åº”ä¸€ä¸ªä»·å€¼ï¼Œå°†å­—ç¬¦ä¸²åˆ‡æˆä¸¤æ®µï¼Œè®¡ç®—ä¸¤æ®µçš„ä»·å€¼å’Œï¼Œæ–¹æ³•å¦‚ä¸‹ï¼šå¦‚æœè¿™ä¸€æ®µæ˜¯å›æ–‡ä¸²ï¼Œä»·å€¼å°±æ˜¯æ¯ä¸€ä¸ªå­—ç¬¦å¯¹åº”çš„ä»·å€¼çš„å’Œï¼Œå¦åˆ™è¯¥ä¸²ä»·å€¼ä¸º0ã€‚æ±‚ä¸¤æ®µä»·å€¼ä¹‹å’Œçš„æœ€å¤§å€¼ã€‚æ€è·¯ï¼š å…ˆè·‘ä¸€éå¤§å¯é©¬æ‹‰è½¦ç®—æ³•ï¼Œç„¶åéå†æ±‚å‡ºä¸²çš„ä»·å€¼å‰ç¼€å’Œï¼Œç„¶åæšä¸¾åˆ†å‰²ç‚¹ï¼Œæ‰¾åˆ°ä¸¤ä¸ªä¸²çš„ä¸­å¿ƒï¼Œåˆ¤æ–­ä¸­å¿ƒçš„å›æ–‡ä¸²æ˜¯ä¸æ˜¯æ•´ä¸ªä¸²ï¼Œå¦‚æœæ˜¯å°±åˆ©ç”¨ä¹‹å‰ç®—çš„å‰ç¼€å’ŒåŠ é‚£ä¸ªä¸²çš„ä»·å€¼ï¼Œåœ¨æšä¸¾ä¸­ä¸æ–­æ›´æ–°ç­”æ¡ˆå³å¯ã€‚6. HDU2222é¢˜æ„ï¼šç»™å‡ºnä¸ªå•è¯å’Œä¸€ä¸ªé•¿ä¸²ï¼Œé—®æœ‰å‡ ä¸ªå•è¯åœ¨é•¿ä¸²ä¸­å‡ºç°è¿‡ã€‚æ€è·¯ï¼šACè‡ªåŠ¨æœºæ¿å­é¢˜ï¼Œå¥½åƒæ²¡ä»€ä¹ˆå¥½è¯´çš„â€¦â€¦7.HDU2896é¢˜æ„ï¼š ç»™å‡ºnä¸ªå•è¯ï¼ˆç—…æ¯’ï¼‰å’Œmä¸ªé•¿ä¸²ï¼ˆæºç ï¼‰é—®æ¯ä¸ªé•¿ä¸²ä¸­æœ‰å“ªäº›å•è¯å‡ºç°è¿‡ä»¥åŠæœ‰å¤šå°‘ä¸ªæºç ä¸­æœ‰ç—…æ¯’ã€‚æ€è·¯ï¼š å’Œä¸Šä¸ªé¢˜ç±»ä¼¼ï¼Œå­—ç¬¦é›†ä¸åªæ˜¯26ä¸ªå­—æ¯äº†â€¦â€¦æ˜¯æ‰€æœ‰ASCIIå¯è§å­—ç¬¦ï¼Œä¸è¿‡å¼€åˆ°130å°±è¡Œï¼Œä¸ç”¨ç»Ÿè®¡å‡ºç°æ¬¡æ•°ï¼Œæ–°åŠ ä¸€ä¸ªæ•°ç»„è®°å½•ç—…æ¯’ç¼–å·åœ¨å­—å…¸æ ‘ä¸Šçš„ä½ç½®ï¼ŒæŸ¥è¯¢çš„æ—¶å€™å¦‚æœæŸä¸ªèŠ‚ç‚¹å¯¹åº”çš„ç—…æ¯’ç¼–å·ä¸ä¸º0å°±åŠ å…¥ç­”æ¡ˆæ•°ç»„ï¼Œæ’åºä¹‹åè¾“å‡ºï¼Œå¦‚æœç­”æ¡ˆæ•°ç»„çš„å¤§å°ä¸ä¸º0ï¼Œæ€»ä¸ªæ•°åŠ 1ï¼Œæœ€åè¾“å‡ºæ€»ä¸ªæ•°ã€‚"},{"id":"debugConfig","title":"VSCode C++ debug é…ç½®","content":"task.json{\r\n  \"version\": \"2.0.0\",\r\n  \"tasks\": [\r\n    {\r\n      \"label\": \"task\",\r\n      \"type\": \"shell\",\r\n      \"command\": \"g++\",\r\n      \"args\": [\r\n        \"-g\",\r\n        \"${file}\",\r\n        \"-o\",\r\n        \"${fileDirname}/${fileBasenameNoExtension}.exe\"\r\n      ],\r\n      \"group\": {\r\n        \"kind\": \"build\",\r\n        \"isDefault\": true\r\n      }\r\n    }\r\n  ]\r\n}launch.json{\r\n  \"version\": \"0.2.0\",\r\n  \"configurations\": [\r\n    {\r\n      \"name\": \"C++ Launch\",\r\n      \"type\": \"cppdbg\",\r\n      \"request\": \"launch\",\r\n      \"program\": \"${workspaceRoot}/${fileBasenameNoExtension}.exe\",\r\n      \"stopAtEntry\": false,\r\n      \"externalConsole\": true,\r\n      \"cwd\": \"${workspaceFolder}\",\r\n      \"preLaunchTask\": \"task\",\r\n      \"windows\": {\r\n        \"MIMode\": \"gdb\",\r\n        \"miDebuggerPath\": \"replace this with your gdb path\"\r\n      }\r\n    }\r\n  ]\r\n}"},{"id":"debug_output_header","title":"ä½¿ç”¨è‡ªå®šä¹‰å¤´æ–‡ä»¶åœ¨ç®—æ³•ç«èµ›ä¸­è¾…åŠ©æœ¬åœ°è°ƒè¯•","content":"ç®—æ³•ç«èµ›ä¸­ä¸»è¦æœ‰ä¸¤ç§è°ƒè¯•æ–¹å¼ï¼šè°ƒè¯•å™¨(debugger)å’Œç›´æ¥è¾“å‡ºã€‚è°ƒè¯•å™¨é€‚åˆæŸ¥çœ‹å°‘é‡æˆ–è€…ç‰¹å®šä½ç½®çš„ä¿¡æ¯ï¼Œä½†å¯èƒ½æ¯”è¾ƒè´¹æ—¶é—´å¹¶ä¸”å¦‚æœé”™è¿‡äº†æŸäº›ä¿¡æ¯å°±è¦é‡æ–°è¿è¡Œ,è€Œä¸”å¿…é¡»è¦åæ§½gdbè¾“å‡ºäºŒç»´æ•°ç»„å…¨æŒ¤åœ¨ä¸€è¡Œæ ¹æœ¬æ²¡æ³•çœ‹ï¼›è€Œç›´æ¥è¾“å‡ºé€‚åˆè·Ÿè¸ªå¤§é‡çš„ä¿¡æ¯ï¼Œå¹¶ä¸”å¯ä»¥æ–¹ä¾¿çš„æŸ¥çœ‹ä¹‹å‰çš„ä¿¡æ¯ï¼Œç¼ºç‚¹å°±æ˜¯éœ€è¦åœ¨ä»£ç ä¸­æ·»åŠ é¢å¤–çš„è¯­å¥ï¼ˆå¯èƒ½ä¼šå¾ˆå¤šï¼‰å¹¶ä¸”è¦åœ¨æäº¤ä¹‹å‰åˆ æ‰ï¼ˆå³ä¾¿æ˜¯è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯æµä¹Ÿä¼šå½±å“æ€§èƒ½ï¼‰ã€‚ä¸€ç§è§£å†³åŠæ³•å°±æ˜¯ä½¿ç”¨æå‰å†™å¥½çš„ä»£ç /å¤´æ–‡ä»¶ï¼Œå¹¶ç»“åˆå®å’Œå‘½ä»¤è¡Œdefineå‚æ•°å®ç°åŒºåˆ†æœ¬åœ°å’Œè¯„æµ‹ç¯å¢ƒï¼Œè®©è°ƒè¯•ä»£ç åœ¨ç¯å¢ƒä¸­å¤±æ•ˆã€‚è¾“å‡ºæˆ‘ç›´æ¥ç”¨çš„ç°æˆçš„pretty printerï¼Œç„¶ååœ¨ä»£ç ä¸­åŠ å…¥å¦‚ä¸‹è¯­å¥ï¼š#ifdef LOCAL\n#include<pprint.hpp> // https://github.com/p-ranav/pprint\npprint::PrettyPrinter _printer(std::cerr);\n#define de(...) _printer.compact(true).print('[', #__VA_ARGS__,\"] =\", __VA_ARGS__)\n#define de2(...) _printer.compact(false).print('[', #__VA_ARGS__,\"] =\", __VA_ARGS__)\n#else\n#define de(...)\n#define de2(...)\n#endifæ³¨æ„è¿™æ ·åšéœ€è¦æŠŠæ‰€åœ¨çš„ç›®å½•åŠ åˆ°ç¯å¢ƒå˜é‡é‡Œï¼Œæˆ–è€…ç¼–è¯‘æ—¶ä½¿ç”¨æ ‡è®°ï¼Œæˆ–è€…å°†æ”¾åˆ°ç³»ç»Ÿincludeç›®å½•é‡Œã€‚å¦‚æœä½ å«Œå¤ªé•¿çš„è¯ï¼Œå¯ä»¥å°†æ­¤éƒ¨åˆ†#ifdef LOCAL\n#include<pprint.hpp> // https://github.com/p-ranav/pprint\npprint::PrettyPrinter _printer(std::cerr);\n#define de(...) _printer.compact(true).print('[', #__VA_ARGS__,\"] =\", __VA_ARGS__)\n#define de2(...) _printer.compact(false).print('[', #__VA_ARGS__,\"] =\", __VA_ARGS__)\n#endifæ”¾å…¥é‡Œï¼Œåªåœ¨ä»£ç ä¸­ç•™ä¸‹#ifndef LOCAL\n#define de(...)\n#define de2(...)\n#endifç¼–è¯‘æ—¶åŠ ä¸Šæ ‡è®°ä»¥å®šä¹‰ï¼Œå¯ä»¥æ¢æˆå…¶ä»–çš„è¯ï¼Œåªè¦ä¿è¯ojé‡Œæ²¡æœ‰å®šä¹‰è¿™ä¸ªå°±è¡Œã€‚"},{"id":"dfs_ordering","title":"DFSåº/æ¬§æ‹‰åºçš„åº”ç”¨ï¼ˆæŒç»­æ›´æ–°ï¼‰","content":"å­æ ‘ç›¸å…³çš„åº”ç”¨ç”±äºå­æ ‘çš„dfsåºæ˜¯è¿ç»­çš„ï¼Œæ‰€ä»¥å¾ˆå®¹æ˜“å¾—åˆ°å­æ ‘çš„ä¿¡æ¯ã€‚æ ‘ä¸Šå¯å‘å¼åˆå¹¶ç”¨äºåˆ æ‰è½»å­æ ‘çš„ä¿¡æ¯vector<int> bch(n, -1);\nint cur_big=-1;\nauto get_big = [&](auto &dfs, int u, int p) -> int {\n    int sz = 1, mx = 0;\n    for (auto v : g[u]) {\n        if (v == p) continue;\n        int csz = dfs(dfs, v, u);\n        if (csz > mx) mx = csz, bch[u] = v;\n        sz += csz;\n    }\n    return sz;\n};\nauto add=[&](auto& slf, int u, int p, int x) -> void {\n    // update info of u here\n    for (auto v : g[u]) {\n        if (v==p || v==cur_big) continue;\n        slf(slf, v, u, x);\n    }\n};\nauto dfs = [&](auto &dfs, int u, int pa, bool keep) -> void {\n    int big = bch[u];\n    for (auto v : g[u])\n        if (v != pa && v != big)\n            dfs(dfs, v, u, 0);\n    if (big != -1) {\n        dfs(dfs, big, u, 1);\n        cur_big=big;\n    }\n    add(add, u, pa, 1);\n    // now you get all the info of subtree of u, answer queries about u here.\n    cur_big=-1;\n    if (!keep) add(add, u, pa, -1);\n};\nåˆ©ç”¨äºŒåˆ†æŸ¥è¯¢å­æ ‘ä¿¡æ¯å¦‚æœæŸ¥è¯¢çš„ä¿¡æ¯æ˜¯ç±»ä¼¼äºå­æ ‘ä¸­æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹æ»¡è¶³ä¸€å®šæ¡ä»¶ï¼Œæ¯”å¦‚ï¼šæœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹çš„é¢œè‰²ä¸ºxï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥ä¸ºæ¯ä¸ªé¢œè‰²å¼€ä¸€ä¸ªæ•°ç»„å­˜ï¼Œå¹¶ä¸”åœ¨dfsçš„æ—¶å€™å°†æ¯ä¸ªèŠ‚ç‚¹æ”¾å…¥å¯¹åº”æ•°ç»„ã€‚ç”±äºå­æ ‘çš„dfsåºæ˜¯è¿ç»­çš„ï¼Œåœ¨æ•°ç»„ä¸­çš„èŠ‚ç‚¹ä¹Ÿæ˜¯è¿ç»­çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡å­æ ‘çš„æ ¹èŠ‚ç‚¹çš„è¿›å‡ºæ—¶é—´æˆ³ï¼Œåˆ©ç”¨äºŒåˆ†å¾—åˆ°å­æ ‘åŒºé—´çš„é•¿åº¦ã€‚ç»ƒä¹ é¢˜ï¼šABC202 E//#pragma GCC target(\"avx,avx2,fma\")\n//#pragma GCC optimize(\"unroll-loops,Ofast\")\n#include <algorithm>\n#include <bits/stdc++.h>\n\n/*{{{*/\nusing namespace std;\n#ifdef LOCAL\n#include<pprint.hpp> // https://github.com/p-ranav/pprint\npprint::PrettyPrinter P(cerr);\n#define de(...) P.compact(true);P.print(__VA_ARGS__)\n#define de_nc(...) P.compact(false);P.print(__VA_ARGS__)\n#else\n#define de(...)\n#define de_nc(...)\n#endif\n#define all(x) (x).begin(),(x).end()\nusing ll = long long;\nusing pii = pair<int, int>;\n\ninline namespace Traits {\n    // is iterable\n    template<typename T, typename = void> struct is_iterable : false_type {};\n    template<typename T>\n    struct is_iterable<T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>> : true_type {};\n    template<typename T> constexpr bool is_iterable_v = is_iterable<T>::value;\n    // is readable\n    template<typename T, typename = void> struct is_readable : false_type {};\n    template<typename T>\n    struct is_readable<T, enable_if_t<is_same_v<decltype(cin >> declval<T&>()), istream&>>> : true_type {};\n    template<typename T> constexpr bool is_readable_v = is_readable<T>::value;\n    // is printable\n    template<typename T, typename = void> struct is_printable : false_type {};\n    template<typename T>\n    struct is_printable<T, enable_if_t<is_same_v<decltype(cout << declval<T>()), ostream&>>> : true_type {};\n    template<typename T> constexpr bool is_printable_v = is_printable<T>::value;\n}\ninline namespace Input {\n    template<typename T> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n    template<typename T, typename U> void re(pair<T, U>& p);\n    template<typename T> enable_if_t<is_readable_v<T>> re(T& x) { cin>>x; }\n    template<typename T> enable_if_t<needs_input_v<T>> re(T& v) { for (auto& x : v) re(x); }\n    template<typename... T> void re(T&... args) {(re(args), ...);}\n    template<typename T, typename U> void re(pair<T, U>& p) { re(p.first, p.second); };\n}\ninline namespace Output {\n    template<typename T> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n    template<int offset=0, typename... T> void wr(T... args);\n    template<int offset=0,typename T> enable_if_t<is_printable_v<T> && is_integral_v<T>> _W(const T& x) { cout<<x+offset; }\n    template<int offset=0,typename T> enable_if_t<is_printable_v<T> && !is_integral_v<T>> _W(const T& x) { cout<<x; }\n    template<int offset=0,typename T, typename U> void _W(const pair<T, U>& p) { wr<offset>(p.first, p.second); }\n    template<int offset=0,typename It> void _W(It f, const It& l) { for (;f!=l; ++f) { _W<offset>(*f); if (f!=l) cout<<' '; }}\n    template<int offset=0,typename T> enable_if_t<needs_output_v<T>> _W(const T& x) { _W<offset>(begin(x), end(x)); }\n    template<int offset, typename... T> void wr(T... args) { \n        int i=0; ((_W<offset>(args), ++i, cout<<(i==sizeof...(args) ? '\\n' : ' ')), ...);\n#ifdef LOCAL\n        cout.flush();\n#endif\n    }\n}\ntemplate<typename T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntemplate<typename T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }/*}}}*/\n\nvoid solve() {\n    int n;\n    re(n);\n    vector<vector<int>> g(n);\n    for (int i=1; i<n; i++) {\n        int p;\n        re(p);\n        g[p-1].push_back(i);\n    }\n    int timer=0;\n    vector<int> in(n), out(n), dep(n);\n    vector<vector<int>> pos(n);\n    auto dfs=[&](auto& dfs, int u) -> void {\n        in[u]=timer++;\n        pos[dep[u]].push_back(in[u]);\n        for (auto v : g[u]) {\n            dep[v]=dep[u]+1;\n            dfs(dfs, v);\n        }\n        out[u]=timer;\n    };\n    dfs(dfs, 0);\n    int q;\n    re(q);\n    while (q--) {\n        int u, d;\n        re(u, d);\n        u--;\n        auto& v=pos[d];\n        wr(lower_bound(all(v), out[u])-lower_bound(all(v), in[u]));\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt=1;\n    while (tt--) {\n        solve();\n    }\n    return 0;\n}è·¯å¾„ç›¸å…³åº”ç”¨å¦‚æœä¿¡æ¯æ˜¯å¯é€†çš„ï¼Œæ¯”å¦‚è¯´æ±‚å’Œï¼Œæˆ‘ä»¬å¯ä»¥ç»“åˆæ¬§æ‹‰åºï¼Œç¬¬ä¸€æ¬¡è®¿é—®èŠ‚ç‚¹çš„æ—¶å€™åœ¨åºåˆ—ä¸­æ”¾å…¥æ­£å€¼ï¼Œè®¿é—®ç»“æŸä¹‹åæ”¾å…¥è´Ÿå€¼ï¼Œè¿™æ ·ä¸åœ¨dfsæ ˆä¸­çš„èŠ‚ç‚¹å°±ä¼šè¢«æŠµæ¶ˆæ‰ã€‚æ€»çš„æ¥è¯´ï¼Œå‡è®¾è¦æ±‚çš„è·¯å¾„æ˜¯ä»uåˆ°vï¼ˆvæ˜¯uçš„ç¥–å…ˆï¼Œå¦‚æœä¸æ˜¯å°±æ‹†æˆå’Œä¸¤æ¡è·¯å¾„ï¼‰ï¼Œé‚£ä¹ˆè·¯å¾„å’Œå°±æ˜¯åºåˆ—ä¸­åˆ°çš„å’Œã€‚"},{"id":"dijkExtention","title":"Dijkstraçš„ä¸€äº›æ‰©å±•","content":"è·¯å¾„è®°å½•æˆ‘ä»¬å¼€ä¸€ä¸ªç”¨æ¥è®°å½•æŸä¸ªç‚¹çš„å‰ä¸€ä¸ªç‚¹ï¼Œåœ¨æ›´æ–°è·ç¦»çš„æ—¶å€™ï¼Œå¦‚æœå½“å‰è·ç¦»æ›´çŸ­å°±èˆå¼ƒæ‰ä¹‹å‰çš„è®°å½•ï¼Œå°†å½“å‰ç‚¹ä½œä¸ºè¢«æ›´æ–°ç‚¹çš„å‰ä¸€ä¸ªç‚¹ï¼›å¦‚æœå½“å‰è·ç¦»å’Œæœ€çŸ­è·ç¦»ç›¸ç­‰å°±åœ¨æ•°ç»„é‡ŒåŠ ä¸Šè¿™ä¸ªç‚¹ã€‚for(pii it:E[u]){\r\n    ll v=it.S,cost=it.F;\r\n    if(!vis[v]&&dis[v]>dis[u]+cost){\r\n        dis[v]=dis[u]+cost;\r\n        pre[v].clear();\r\n        pre[v].pb({cost,u});\r\n        q.push({dis[v],v});\r\n    }else if(dis[v]==dis[u]+cost)\r\n        pre[v].pb({cost,u});\r\n}æœ€çŸ­è·¯å¾„çš„æ•°é‡å’Œè·¯å¾„è®°å½•ç±»ä¼¼ï¼Œå¦‚æœæ›´çŸ­å°±è®©æ•°ç›®ç­‰äº1,å¦‚æœä¸€æ ·å°±åŠ 1ã€‚if(!vis[v]&&dis[u]+cost<dis[v]){\r\n    cnt[v]=1;\r\n    dis[v]=dis[u]+cost;\r\n}else if(dis[u]+cost==dis[v]){\r\n    cnt[v]++;\r\n}"},{"id":"dsu-on-tree","title":"æ ‘ä¸Šå¯å‘å¼åˆå¹¶ï¼ˆDSU on Treeï¼‰æ€»ç»“","content":"æ ‘ä¸Šå¯å‘å¼åˆå¹¶å¯ä»¥ç”¨  çš„æ—¶é—´ï¼ˆå‡è®¾æ·»åŠ å’Œåˆ é™¤èŠ‚ç‚¹éƒ½æ˜¯ ï¼‰è§£å†³å¯¹äºæ¯ä¸ªå­æ ‘çš„ç»Ÿè®¡é—®é¢˜ï¼ˆæ¯”å¦‚ç»Ÿè®¡å­æ ‘ä¸­æœ‰å¤šå°‘ç§é¢œè‰²çš„èŠ‚ç‚¹ï¼‰ã€‚ç®—æ³•æ¦‚è¿°å¯¹äºä¸€ä¸ªèŠ‚ç‚¹ ï¼Œæˆ‘ä»¬æŒ‰ä»¥ä¸‹çš„æ­¥éª¤è¿›è¡Œéå†ï¼šå…ˆéå†  çš„è½»ï¼ˆéé‡ï¼‰å„¿å­ï¼Œå¹¶è®¡ç®—ç­”æ¡ˆï¼Œä½†ä¸ä¿ç•™éå†åå®ƒå¯¹ç»Ÿè®¡çš„å½±å“éå†å®ƒçš„é‡å„¿å­ï¼Œä¿ç•™å®ƒå¯¹ç»Ÿè®¡çš„å½±å“å†æ¬¡éå†  çš„è½»å„¿å­çš„å­æ ‘ç»“ç‚¹ï¼ŒåŠ å…¥è¿™äº›ç»“ç‚¹çš„è´¡çŒ®ï¼Œä»¥å¾—åˆ°  çš„ç­”æ¡ˆæ¨¡æ¿vector<int> sz(n, 1), big(n, -1); // sz: å­æ ‘å¤§å°ï¼Œbigï¼šé‡å„¿å­\nauto cal_size = [&](auto& slf, int u, int p) -> void {\n    for (auto v : g[u]) {\n        if (v == p) continue;\n        slf(slf, v, u);\n        sz[u] += sz[v];\n        if (big[u] == -1 || sz[v] > sz[big[u]]) {\n            big[u] = v;\n        }\n    }\n};\ncal_size(cal_size, 0, 0);\n\nauto add = [&](auto& slf, int u, int p) -> void {\n    // åœ¨æ­¤å°† u æ·»åŠ è¿›ç»Ÿè®¡ç»“æœ\n    for (auto v : g[u]) {\n        if (v == p) continue;\n        slf(slf, v, u);\n    }\n};\n\nauto remove = [&](auto& slf, int u, int p) -> void {\n    // åœ¨æ­¤å°† u ä»ç»Ÿè®¡ç»“æœä¸­ç§»é™¤\n    for (auto v : g[u]) {\n        if (v == p) continue;\n        slf(slf, v, u);\n    }\n};\n\nauto dfs = [&](auto& slf, int u, int p) -> void {\n    for (auto v : g[u]) {\n        if (v == p || v == big[u]) continue;\n        slf(slf, v, u); // éå†è½»å„¿å­\n        remove(remove, v, u); // ç§»é™¤è½»å„¿å­\n    }\n    if (big[u] != -1) {\n        slf(slf, big[u], u); // éå†é‡å„¿å­\n    }\n\n    for (auto v : g[u]) {\n        if (v == p || v == big[u]) continue;\n        add(add, v, u); // å†æ¬¡æ·»åŠ è½»å„¿å­\n    }\n    // åœ¨æ­¤å°† u æ·»åŠ è¿›ç»Ÿè®¡ç»“æœ\n    // æ­¤å¤„çš„ç»Ÿè®¡ç»“æœå³ä¸º u å­æ ‘çš„ç­”æ¡ˆ\n};\ndfs(dfs, 0, 0);æ—¶é—´å¤æ‚åº¦è¯æ˜å¦‚æœä¸€ä¸ªèŠ‚ç‚¹ä¸ºå…¶çˆ¶èŠ‚ç‚¹çš„è½»å„¿å­ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°å…¶ä¸ºè½»èŠ‚ç‚¹ã€‚æ‰€æœ‰è½»èŠ‚ç‚¹ä¼šåœ¨æ¸…é™¤ç»Ÿè®¡æ—¶éå†ä¸€éå…¶å­æ ‘ï¼Œæ‰€ä»¥æ¯ä¸ªèŠ‚ç‚¹è¢«éå†çš„æ¬¡æ•°ä¸ºå…¶åˆ°æ ¹èŠ‚ç‚¹è·¯å¾„ä¸Šçš„è½»èŠ‚ç‚¹çš„æ•°é‡åŠ ä¸€ï¼ˆåŠ ä¸€æ˜¯å› ä¸º dfs æœ¬èº«ä¼šéå†ä¸€éï¼‰ã€‚ç”±äºè½»èŠ‚ç‚¹çš„å­æ ‘å¤§å°è‡³å¤šä¸ºå…¶çˆ¶èŠ‚ç‚¹çš„çš„ä¸€åŠï¼Œæ‰€ä»¥ä»»æ„èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„ä¸Šçš„è½»èŠ‚ç‚¹æ•°é‡æœ€å¤šä¸º ï¼Œæ‰€ä»¥æ¯ä¸ªç‚¹è¢«éå†çš„æ¬¡æ•°ä¸º ï¼Œæ‰€ä»¥æ€»ä½“çš„æ—¶é—´å¤æ‚åº¦ä¸º ã€‚å¤šè¯´ä¸€å˜´ä¸ºä»€ä¹ˆè¿™ä¸ªç®—æ³•æ²¡æœ‰ä»»ä½•åˆå¹¶æ“ä½œå´è¢«å«åšâ€œå¯å‘å¼åˆå¹¶â€ï¼Œå› ä¸ºä»–å’ŒçœŸæ­£çš„â€œå¯å‘å¼åˆå¹¶â€æœ‰ç€ç±»ä¼¼çš„è¿‡ç¨‹ï¼šå¦‚æœæˆ‘ä»¬å…ˆéå†é‡å„¿å­ï¼Œé‚£ä¹ˆåˆå¹¶æ—¶æ°¸è¿œæ˜¯ä»è½»å„¿å­åˆå¹¶åˆ°é‡å„¿å­ä¸Šï¼Œæ‰€ä»¥æˆ‘ä»¬åˆå¹¶æ—¶å°±ç›¸å½“äºéå†äº†ä¸€éè½»å„¿å­çš„å­æ ‘ï¼ˆç±»æ¯”äºæ¸…é™¤è½»å„¿å­ç»Ÿè®¡ï¼‰ï¼Œæ‰€ä»¥â€œå¯å‘å¼åˆå¹¶â€çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿæ˜¯ ã€‚"},{"id":"easy-ssl-for-local-services","title":"è®©ä½ çš„å®¶åº­æœåŠ¡å™¨é‡Œçš„æœ¬åœ°æœåŠ¡ä¹Ÿç”¨ä¸Š SSL è¯ä¹¦","content":"è¿™ä¸ªæ–¹æ³•æ¥è‡ªäº è§†é¢‘ ï¼Œç”± Walfgang çš„é¢‘é“æä¾›ã€‚è¿™ç¯‡å¸–å­ä»…ä¸ºæœ‰ç»éªŒçš„äººæä¾›å¯¹é‚£ä¸ªè§†é¢‘çš„ç¬”è®°ã€‚å…³é”®ç‚¹åœ¨äºï¼Œä½ å¯ä»¥åˆ›å»ºä¸€ä¸ª DNS è®°å½•ï¼Œå°†å…¶æŒ‡å‘ä½ çš„æœ¬åœ° IP åœ°å€ã€‚å…ˆå†³æ¡ä»¶ï¼šä¸€ä¸ªåŸŸåï¼Œä¸€ä¸ªåå‘ä»£ç†ï¼ˆæˆ‘åœ¨è¿™é‡Œä½¿ç”¨çš„æ˜¯ Nginx Proxy Managerï¼‰ï¼Œç”¨äºåŸŸåçš„ SSL è¯ä¹¦ã€‚æ­¥éª¤ 1ï¼šåˆ›å»ºä¸€ä¸ª A ç±»å‹çš„ DNS è®°å½•ï¼Œå°†å…¶æŒ‡å‘ä½ æœåŠ¡å™¨çš„æœ¬åœ° IP åœ°å€ï¼Œä¾‹å¦‚ ã€‚æ­¥éª¤ 2ï¼šåœ¨ä½ çš„åå‘ä»£ç†ä¸­ï¼Œå°†åŸŸåä»£ç†åˆ°ä½ çš„æœ¬åœ°æœåŠ¡ï¼Œå¹¶å¯ä»¥ä½¿ç”¨ä½ çš„ SSL è¯ä¹¦ã€‚å°±æ˜¯è¿™ä¹ˆç®€å•ï¼"},{"id":"file-browser","title":"File Browser (filebrowser)","content":"File Browseræ˜¯ä¸€ä¸ªç½‘é¡µç«¯æ–‡ä»¶ç®¡ç†/æµè§ˆå™¨ï¼Œå®ƒå¾ˆè½»é‡ä½†åŒæ—¶æ‹¥æœ‰ä¸°å¯Œçš„åŠŸèƒ½ã€‚åœ¨GitHubä¸Šæœ‰1.7ä¸‡çš„æ˜Ÿæ˜Ÿã€‚ä¸ºä»€ä¹ˆä¸ç”¨Nextcloud?NextcloudåŠŸèƒ½å¾ˆå¼ºå¤§ï¼Œä½†å¾ˆå¤šäººåªæŠŠä»–å½“ä½œäº‘å­˜å‚¨ç”¨æ‰€ä»¥å°±æ˜¾å¾—æ¯”è¾ƒè‡ƒè‚¿ã€‚è€Œä¸”å®ƒçš„ç½‘é¡µç«¯ç”¨èµ·æ¥æ„Ÿè§‰æœ‰ç‚¹æ…¢è€Œä¸”æ’­æ”¾å™¨ç»å¸¸å‡ºbugã€‚IOSç«¯ä¹Ÿå¡å¡çš„ï¼ˆå¯èƒ½ä¹Ÿä¸æˆ‘æ‰‹æœºæ¯”è¾ƒè€æœ‰å…³ï¼‰ï¼Œç½‘é¡µç«¯åœ¨æ‰‹æœºä¸Šæ›´ä¸å¥½ç”¨ã€‚æœ€é‡è¦çš„ä¸€ç‚¹ï¼šæ–‡ä»¶å•ç‹¬å­˜æ”¾åœ¨ä¸€ä¸ªåœ°æ–¹è€Œä¸”æ˜¯ä»¥www-dataç”¨æˆ·ç®¡ç†ï¼Œæ‰€ä»¥å¦‚æœä½ è¦åœ¨æœåŠ¡å™¨ä¸Šå¯¼å…¥ã€å¯¼å‡ºã€ä¸‹è½½æ–‡ä»¶çš„è¯æ¥å›åˆ‡æ¢ç”¨æˆ·å¾ˆä¸æ–¹ä¾¿ã€‚æ‰€ä»¥æˆ‘å°±ä¸€ç›´åœ¨æ‰¾ä¸€ä¸ªæ›¿ä»£Nextcloudçš„æ–¹æ¡ˆï¼Œå°è¯•äº†å„ç§æ–¹æ¡ˆä¹‹åï¼ŒFile Browserä¹Ÿè®¸æ˜¯æœ€ç¬¦åˆæˆ‘éœ€æ±‚çš„ã€‚ï¼ˆä¸»è¦ç—›ç‚¹å°±æ˜¯è§†é¢‘å°é¢ï¼Œå…¶å®File Browserä¹Ÿæ²¡æœ‰ï¼Œä½†æœ‰åˆ«äººçš„forkåŠ ä¸Šäº†ï¼Œç„¶åæˆ‘åˆå®Œå–„äº†ä¸€ä¸‹å¹¶ä¼ åˆ°äº†docker hubä¸Šï¼‰å®‰è£…version: '3'\nservices:\n  app:\n    container_name: filebrowser\n    #image: filebrowser/filebrowser\n    image: thallium54/filebrowser\n\n    restart: unless-stopped\n    user: 1000:1000\n    ports:\n    - \"8335:80\"\n    volumes:\n      - /path/to/manage:/srv\n      - /path/to/database/filebrowser.db:/database.db\n      - /path/to/cache:/cacheé•œåƒå¯ä»¥ç”¨æˆ‘çš„æˆ–è€…å®˜æ–¹çš„ã€‚volumeæ ¹æ®ä½ çš„æƒ…å†µä¿®æ”¹ï¼Œç¬¬ä¸€ä¸ªæ˜¯ä½ è¦ç®¡ç†çš„ç›®å½•ï¼Œæ¯”å¦‚æˆ‘ç›´æ¥æŠŠhomeç›®å½•æŒ‚ä¸Šå»äº†ã€‚ç¬¬äºŒä¸ªæ˜¯æ•°æ®åº“çš„ä½ç½®ï¼Œä¸€å®šè¦è‡ªå·±åˆ›å»ºè¿™ä¸ªæ–‡ä»¶ï¼Œä¸ç„¶dockerä¼šæŠŠè¿™ä¸ªå½“æˆç›®å½•ç„¶ååˆ›å»ºä¸€ä¸ªå«çš„ç›®å½•ã€‚ç¬¬ä¸‰ä¸ªæ˜¯è§†é¢‘å’Œå›¾ç‰‡é¢„è§ˆçš„ç¼“å­˜ç›®å½•ï¼Œå®˜æ–¹é•œåƒæ²¡æœ‰å¼€ç¼“å­˜æ‰€ä»¥å¦‚æœç”¨å®˜æ–¹é•œåƒçš„è¯å°±åˆ æ‰è¿™ä¸€è¡Œå°±è¡Œã€‚å¦‚ä½•è‡ªå·±æ„å»ºä»¥æˆ‘è‡ªå·±çš„ç‰ˆæœ¬ä¸¾ä¾‹ï¼šï¼ˆåˆ‡æ¢åˆ°æœ‰è§†é¢‘é¢„è§ˆçš„branch)ï¼ˆç¼–è¯‘å¯æ‰§è¡Œæ–‡ä»¶ï¼Œå¦‚æœä½ ä¸æ‰“ç®—ç”¨dockerçš„è¯ç¼–è¯‘å‡ºæ¥çš„å°±ç›´æ¥å¯ä»¥ç”¨äº†ï¼Œå…·ä½“ç”¨æ³•è§ï¼‰ï¼ˆæ„å»ºdockeré•œåƒï¼‰ï¼ˆå¦‚æœåœ¨æœ¬åœ°ç”¨çš„è¯å¯ä»¥ä¸pushï¼‰"},{"id":"game_theory","title":"åšå¼ˆè®ºå…¥é—¨å­¦ä¹ ç¬”è®°","content":"å‡ ä¸ªæœˆå‰çš„ç¬”è®°ï¼Œæ‰ç–å­¦æµ…ï¼Œä»…ä¾›å‚è€ƒ~åŸºæœ¬æ¦‚å¿µPNç‚¹ä»€ä¹ˆæ˜¯PNç‚¹Pç‚¹ï¼šå‰ä¸€ä¸ªé€‰æ‰‹ï¼ˆprevious person)å°†å–èƒœçš„ç‚¹ï¼Œå³å¿…è´¥ç‚¹ã€‚Nç‚¹ï¼šä¸‹ä¸€ä¸ªé€‰æ‰‹ï¼ˆnext person)å°†å–èƒœçš„ç‚¹ï¼Œå³å¿…èƒœç‚¹ã€‚æ³¨æ„ï¼šPNç‚¹æ˜¯ç›¸å¯¹äºæŸä¸ªç‚¹çš„å±æ€§ï¼Œä¸å…ˆåæ‰‹æ— å…³ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´å…ˆæ‰‹çš„Pç‚¹æˆ–åæ‰‹çš„Pç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´æ— è®ºæ˜¯å…ˆæ‰‹è¿˜æ—¶åæ‰‹ï¼Œèµ°åˆ°Pç‚¹éƒ½æ˜¯å¿…è´¥çš„ã€‚PNç‚¹çš„å±æ€§æ‰€æœ‰ç»ˆç»“çŠ¶æ€å‡ä¸ºPç‚¹ã€‚ä»ä»»ä½•Nç‚¹éƒ½è‡³å°‘æœ‰ä¸€ç§æ–¹æ³•è¿›å…¥Pç‚¹ã€‚ï¼ˆå½“å‰ç©å®¶çš„å¿…èƒœç‚¹ä¸€å®šå¯ä»¥èµ°åˆ°ä¸‹ä¸€ä¸ªç©å®¶çš„å¿…è´¥ç‚¹ï¼‰ä»Pç‚¹åªèƒ½è¿›å…¥Nç‚¹ã€‚ï¼ˆå¦‚æœèƒ½èµ°åˆ°Pç‚¹çš„è¯å°±ç›¸å½“äºèƒœè´Ÿå±€åŠ¿å˜åŒ–äº†ï¼Œè¿™æ ·å°±ä¸æ˜¯å¿…è´¥çš„äº†ï¼‰æ³¨æ„ï¼šè¿™é‡Œè¯´çš„éƒ½æ˜¯èµ°åˆ°æœ€åçŠ¶æ€çš„ç©å®¶è·èƒœçš„æ¸¸æˆã€‚SGå‡½æ•°å¦‚æœæ¸¸æˆæ¡ä»¶æ¯”è¾ƒå¤æ‚ï¼Œä¸ºäº†åˆ¤æ–­æ¯ä¸ªç‚¹çš„èƒœè´ŸçŠ¶æ€ï¼Œå°±éœ€è¦å¼•å…¥SGå‡½æ•°ã€‚å®šä¹‰ï¼šå…¶ä¸­vä¸ºuçš„åç»§çŠ¶æ€ï¼Œmexå‡½æ•°æ˜¯ä½œç”¨äºæ•´æ•°é›†åˆçš„å‡½æ•°ï¼Œå‡½æ•°å€¼æ˜¯ä¸å±äºè¯¥é›†åˆçš„æœ€å°è‡ªç„¶æ•°ã€‚é‚£ä¹ˆï¼Œç»ˆæ­¢çŠ¶æ€çš„SGå€¼æ˜¾ç„¶ä¸º0ï¼Œå¹¶ä¸”SGå€¼ä¸º0çš„çŠ¶æ€å°±æ˜¯PçŠ¶æ€ï¼ŒSGå€¼ä¸ä¸º0çš„çŠ¶æ€å°±æ˜¯NçŠ¶æ€ã€‚\nè¯æ˜åˆ™éå¸¸æ˜¾ç„¶ï¼ŒSGå€¼ä¸º0çš„çŠ¶æ€ï¼Œè¯´æ˜å®ƒçš„æ‰€æœ‰åç»§çŠ¶æ€éƒ½ä¸ä¸º0ï¼Œä¹Ÿå°±æ˜¯å®ƒåªèƒ½è½¬ç§»åˆ°é0çŠ¶æ€ï¼Œè€ŒSGå€¼ä¸ä¸º0çš„çŠ¶æ€åˆ™ä¸ä¸€æ ·ï¼Œåç»§çŠ¶æ€ä¸€å®šæœ‰0ï¼Œå¯èƒ½æœ‰å…¶ä»–éè´Ÿæ•´æ•°ã€‚é‚£ä¹ˆSGå€¼ä¸º0çš„çŠ¶æ€å°±æ˜¯å¿…è´¥çŠ¶æ€çš„å®šä¹‰ï¼ŒSGå€¼ä¸ä¸º0çš„çŠ¶æ€å°±æ˜¯å¿…èƒœçŠ¶æ€çš„å®šã€‚æ±‚æ³•ä»å®šä¹‰å¯ä»¥çœ‹å‡ºsgå‡½æ•°ä½¿ç”¨çš„é€’å½’å®šä¹‰ï¼Œæ‰€ä»¥æˆ‘ä»¬æ—¢å¯ä»¥ä»sgä¸º0çš„çŠ¶æ€é€’æ¨ï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨é€’å½’çš„æ–¹æ³•æ±‚ã€‚æœ‰äº›é¢˜ç›®çš„sgå‡½æ•°çš„æœ‰è§„å¾‹çš„ï¼Œé€šè¿‡æ‰“è¡¨æˆ–è€…æ€è€ƒå¯ä»¥å‘ç°è§„å¾‹;æœ‰äº›æ˜¯æ²¡æœ‰è§„å¾‹çš„ï¼Œéœ€è¦è‡ªå·±å†™sgå‡½æ•°æ¥æ‰“è¡¨ã€‚ä¸€èˆ¬çš„sgå‡½æ•°æ‰“è¡¨æ¨¡æ¿ï¼š\næ³¨ï¼šéœ€è¦æ‰“è¡¨çš„ä¸€èˆ¬æ˜¯ç®€å•çš„å–çŸ³å­æ¸¸æˆï¼Œä¸”åœ¨å–çŸ³å­çš„æ•°é‡ä¸Šæœ‰é™åˆ¶ã€‚è¿™ç§é—®é¢˜çš„çŠ¶æ€æ–¹ä¾¿ç”¨æ•°å­—è¡¨ç¤ºï¼Œæ‰€ä»¥å®ç°ç®€å•ã€‚bool flag[N];\nint sg[N];\nvoid getsg(){\n    for1(i,N){\n        ms(flag,0);\n        //æšä¸¾åç»§çŠ¶æ€\n        for(int j=1;j<=K;j++){//Kä¸ºèƒ½å–ä¸åŒä¸ªæ•°çŸ³å­çš„ç§ç±»æ•°\n            flag[sg[i-shizi[j]]]=1;\n        }\n        //æ‰¾mex\n        forn(j,N){\n            if(flag[j]==0){\n                sg[i]=j;\n                break;\n            }\n        }\n    }\n}æœ‰è§„å¾‹çš„sgå‡½æ•°:HDU-1847æ‰“è¡¨å¯å‘ç°sgå‡½æ•°æ˜¯0ï¼Œ1ï¼Œ2ï¼Œ0ï¼Œ1ï¼Œ2â€¦â€¦å˜åŒ–çš„ã€‚ç¨å¾®éš¾ä¸€ç‚¹æ‰¾è§„å¾‹ï¼šLightOJ-1296è§„å¾‹ï¼šå¦‚æœnæ˜¯å¥‡æ•°gx(n)=gx(n/2),å¦‚æœä¸ºå¶æ•°ï¼Œgx(x)=x/2;éœ€è¦æ‰“è¡¨çš„é¢˜ï¼šHDU-1848å·´ä»€åšå¼ˆé¢˜ç›®æè¿°åªæœ‰ä¸€å †nä¸ªçŸ³å­ï¼Œä¸¤ä¸ªäººè½®æµä»è¿™å †çŸ³å­ä¸­å–çŸ³å­ï¼Œè§„å®šæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œæœ€å¤šå–mä¸ªï¼Œæœ€åå–å®Œçš„äººè·èƒœã€‚åˆ†æå½“n = m+1 çš„æ—¶å€™ï¼Œç”±äºå…ˆæ‰‹æœ€å¤šå–èµ°mä¸ªï¼Œæ— è®ºå…¶å–èµ°å¤šå°‘ä¸ªï¼Œå‰©ä¸‹çš„åæ‰‹å‡å¯ä»¥ä¸€æ¬¡å–å®Œï¼Œæ˜¾ç„¶åæ‰‹èƒœã€‚æ ¹æ®ä»¥ä¸Šåˆ†æï¼Œæˆ‘ä»¬å¯ä»¥å°†nå†™æˆ  çš„å½¢å¼ã€‚å¯¹äºå…ˆæ‰‹ç©å®¶ï¼Œæˆ‘ä»¬å¯ä»¥å–èµ°rä¸ªï¼Œç»™å¯¹æ–¹é€ æˆå‰©ä¸‹çš„æƒ…å½¢ã€‚æ­¤æ—¶æ— è®ºå¯¹æ‰‹å–èµ°å¤šå°‘ä¸ªï¼Œå‡è®¾å¯¹æ‰‹å–èµ°nä¸ªï¼Œ æˆ‘ä»¬ä¸€å®šå¯ä»¥åšåˆ°å–èµ° ä¸ªï¼Œæ­¤æ—¶å‰©ä¸‹ä¸ªï¼Œé‚£ä¹ˆç•™ç»™å¯¹æ–¹åˆæ˜¯(m+1)çš„æ•´æ•°å€ï¼Œå¦‚æ­¤å°±å¯ä»¥ä¿è¯å…ˆæ‰‹å–èƒœã€‚ç»“è®ºå½“æ—¶ï¼Œå…ˆæ‰‹èƒœï¼Œå¦åˆ™åæ‰‹èƒœã€‚å¨ä½å¤«åšå¼ˆé¢˜ç›®æè¿°æœ‰ä¸¤å †å„è‹¥å¹²ä¸ªçŸ³å­ï¼Œä¸¤ä¸ªäººè½®æµä»æŸä¸€å †æˆ–è€…ä¸¤å †ä¸­å–åŒæ ·å¤šçš„ç‰©å“ï¼Œè§„å®šæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œå¤šç€ä¸é™ï¼Œæœ€åå–å®ŒçŸ³å­çš„äººè·èƒœã€‚åˆ†ææˆ‘ä»¬ç”¨ è¡¨ç¤ºä¸€ç§å±€åŠ¿ï¼Œå…ˆæ‰‹å¿…è¾“çš„å±€åŠ¿æˆ‘ä»¬ç§°ä¸ºå¥‡å¼‚å±€åŠ¿ï¼Œæ˜¾ç„¶æ˜¯ä¸€ç§å¥‡å¼‚å±€åŠ¿ã€‚é‚£ä¹ˆå¿…ç„¶æ˜¯éå¥‡å¼‚å±€åŠ¿ï¼Œå› ä¸ºå¯ä»¥é€šè¿‡ä¸€æ­¥åˆ°è¾¾å¥‡å¼‚å±€åŠ¿ã€‚æˆ‘ä»¬å¯ä»¥å‘ç°ä¸è®ºå¦‚ä½•æ“ä½œéƒ½å°†æˆä¸ºéå¥‡å¼‚å±€åŠ¿ï¼Œæ‰€ä»¥æ˜¯ä¸‹ä¸€ä¸ªå¥‡å¼‚å±€åŠ¿ï¼Œæ‰€ä»¥ä¹Ÿéƒ½æ˜¯éå¥‡å¼‚å±€åŠ¿ï¼Œä»¥æ­¤ç±»æ¨æˆ‘ä»¬å¯ä»¥å‘ç°ä¹‹åçš„å‡ ä¸ªå¥‡å¼‚å±€åŠ¿æ˜¯ã€‚é€šè¿‡è§‚å¯Ÿæˆ‘ä»¬å¯ä»¥å‘ç°ä¸ºå‰é¢æ²¡å‡ºç°è¿‡çš„æœ€å°æ­£æ•´æ•°ï¼Œã€‚å¥‡å¼‚å±€åŠ¿æœ‰ä»¥ä¸‹ä¸‰æ¡æ€§è´¨ä»»ä½•æ­£æ•´æ•°éƒ½åŒ…å«åœ¨å¥‡å¼‚å±€åŠ¿ä¸­ã€‚ä»»ä½•æ“ä½œéƒ½ä¼šå°†å¥‡å¼‚å±€åŠ¿å˜ä¸ºéå¥‡å¼‚å±€åŠ¿ã€‚é‡‡å–é€‚å½“çš„æ“ä½œå¯ä»¥å°†éå¥‡å¼‚å±€åŠ¿å˜ä¸ºå¥‡å¼‚å±€åŠ¿ã€‚äº‹å®ä¸Šï¼Œæ˜¯ä¸€å¯¹beattyæ•°åˆ—ã€‚Beattyæ•°åˆ—å–ä¸¤ä¸ªæ— ç†æ•°ä½¿å¾—ã€‚ä¸€å¯¹Beattyæ•°åˆ—å°±æ˜¯ã€‚Rayleighå®šç†(Beattyå®šç†)åˆ’åˆ†æ­£æ•´æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªæ­£æ•´æ•°åªåœ¨ä¸¤ä¸ªæ•°åˆ—ä¸­å‡ºç°ä¸€æ¬¡ã€‚æˆ‘ä»¬å†å›åˆ°è¿™ä¸ªé—®é¢˜ï¼Œ\næ ¹æ®è§£å¾—ã€‚æˆ‘ä»¬å¯å¾—åˆ°é€šé¡¹å¯¹äºä»»æ„å±€åŠ¿æˆ‘ä»¬åªéœ€åˆ¤æ–­å¸¸è§çš„å‡ ç±»é—®é¢˜ç»™å‡ºå±€åŠ¿åˆ¤æ–­æ˜¯å¦æ˜¯å¥‡å¼‚å±€åŠ¿ã€‚ç»™å‡ºå±€åŠ¿ï¼Œåˆ¤æ–­æ˜¯å¦å…ˆæ‰‹èµ¢ï¼Œè‹¥èµ¢ï¼Œç»™å‡ºç¬¬ä¸€æ­¥èµ°æ³•ã€‚ä¾‹é¢˜ï¼šHDU-2177å…ˆæŠŠæ‰€æœ‰å¥‡å¼‚å±€åŠ¿æ±‚å‡ºæ¥ï¼Œç„¶ååˆ¤æ–­æ˜¯ä¸æ˜¯ï¼Œå¦‚æœä¸æ˜¯ï¼šå…ˆåˆ¤æ–­èƒ½å¦ä¸¤å †åŒæ—¶å–ï¼Œè®¾ åˆ¤æ–­å¦‚æœæˆç«‹å°±å¯ä»¥åŒæ—¶å–åˆ°ã€‚åˆ¤æ–­å–ä¸€å †çš„ã€‚å…ˆåˆ¤æ–­,å¦‚æœæˆç«‹å°±å¯ä»¥å–åˆ°,å¦‚æœä¸æˆç«‹é‚£ä¹ˆï¼Œæ­¤æ—¶ï¼Œæ‰€ä»¥å¯ä»¥å–åˆ°ã€‚Nimåšå¼ˆé¢˜ç›®æè¿°æœ‰nå †çŸ³å­ï¼Œæ•°é‡åˆ†åˆ«ä¸ºæ¯äººæ¯æ¬¡å¯åœ¨ä»»æ„ä¸€å †ä¸­å–èµ°ä»»æ„æ•°é‡ï¼ˆä¸å°‘äº1ï¼‰çš„çŸ³å­ã€‚ç»“è®ºNimæ¸¸æˆä¸­å…ˆæ‰‹å¿…è´¥å½“ä¸”ä»…å½“æ—¶æ‰©å±•äº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å°†Nimæ¸¸æˆè§†åšå¤šä¸ªå­æ¸¸æˆçš„åˆé›†ï¼Œæ ¹æ®Nimå®šç†ï¼Œæ€»æ¸¸æˆçš„sgå€¼ç­‰äºæ‰€æœ‰å­æ¸¸æˆçš„sgå€¼çš„å¼‚æˆ–å’Œã€‚è¯æ˜å¼‚æˆ–æœ‰ä¸€æ¡æ€§è´¨,ï¼Œæ ¹æ®sgçš„å®šä¹‰ï¼Œå­æ¸¸æˆèµ°ä¸€æ­¥ï¼Œsgå€¼å¿…ç„¶å‘ç”Ÿæ”¹å˜ï¼Œæ ¹æ®å¼‚æˆ–çš„æ€§è´¨æ‰€ä»¥æ€»æ¸¸æˆçš„sgå€¼ä¹Ÿä¸€å®šå‘ç”Ÿæ”¹å˜ï¼Œ0ä¸€å®šä¼šå˜æˆé0ï¼Œé0ç»è¿‡æŸä¸€æ­¥å¯ä»¥å˜æˆ0ï¼Œæ‰€ä»¥å½“ä¸”ä»…å½“å’Œæ¸¸æˆçš„sgä¸º0æ—¶ï¼Œå…ˆæ‰‹å¿…è¾“ï¼Œå› ä¸ºåæ‰‹æ€»å¯ä»¥æ§åˆ¶sgå€¼å›åˆ°0ã€‚ä¾‹é¢˜ï¼šHDU-2176"},{"id":"gcj2021_r2_matrygons","title":"Google Code Jam 2021 R2 Matrygonsé¢˜è§£","content":"æ¯”èµ›çš„æ—¶å€™æƒ³é”™æ–¹å‘äº†:disappointed:Solutionè®¾ä»é‡Œå‘å¤–å¤šè¾¹å½¢çš„è¾¹æ•°ä¸ºã€‚ä¸éš¾å‘ç°å¿…é¡»æ˜¯çš„å€\næ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥æŠŠå†™æˆã€‚æ‰€ä»¥\nå¦‚æœæˆ‘ä»¬çŸ¥é“æœ€é‡Œé¢çš„å¤šè¾¹å½¢çš„è¾¹æ•°ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„äº‹æƒ…å°±æ˜¯æ‰¾åˆ°æœ€é•¿çš„åºåˆ— ä½¿å¾—æ˜¯çš„å€æ•°å¹¶ä¸”ã€‚æ³¨æ„éƒ½æ˜¯çš„å€æ•°ï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬æŠŠå®ƒä»¬éƒ½é™¤ä»¥å°±åˆå¾—åˆ°\näº†ä¸€ä¸ªä»¥å¼€å¤´çš„åºåˆ—ï¼ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªæ›´å°çš„å­é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨åŠ¨æ€è§„\nåˆ’æ¥è§£å†³ï¼šè®¾ä¸ºå’Œä¸ºçš„ä¸Šè¿°åºåˆ—çš„æœ€å¤§é•¿åº¦ã€‚å› ä¸ºæˆ‘ä»¬å¯ä»¥æŠŠä¸€ä¸ªçŸ­çš„åºåˆ—ä¹˜ä¸Š\nä¸€ä¸ªæ•°å¹¶åœ¨æœ€å‰é¢æ”¾ä¸€ä¸ªï¼Œä»è€Œå¾—åˆ°ä¸€ä¸ªæ›´é•¿çš„åºåˆ—ï¼Œæ‰€ä»¥çŠ¶æ€è½¬ç§»å°±æ˜¯ï¼š\nä»£ç #include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt = 1;\n    cin >> tt;\n    constexpr int N = 1e6;\n    vector<int> dp(N + 1, 1);\n    for (int i = 1; i <= N; i++) {\n        for (int j = 2 * i + 1; j <= N; j += i) {\n            dp[j] = max(dp[j], dp[i] + 1);\n        }\n    }\n    for (int cas = 1; cas <= tt; cas++) {\n        int x;\n        cin >> x;\n        int ans = 1;\n        cout << \"Case #\" << cas << \": \";\n        for (int f = 3; f <= x; f++) {\n            if (x % f == 0)  ans = max(ans, dp[x / f]);\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}"},{"id":"git","title":"Gitå°æŠ€å·§","content":"æ­£å¸¸æ˜¾ç¤ºä¸­æ–‡æ–‡ä»¶ågit config --global core.quotepath falseç”¨rebaseåˆå¹¶commitsgit rebase -i HEAD~3æ•°å­—ä¸ºæœ€åå‡ ä¸ªè¦ç¼–è¾‘çš„commitsç„¶åæ ¹æ®æƒ…å†µç¼–è¾‘commitsï¼Œå¦‚æœæ˜¯å…¨éƒ¨åˆå¹¶çš„è¯å°±ç¬¬ä¸€è¡Œç•™ä¸‹ï¼Œå…¶ä»–å…¨éƒ¨æ”¹æˆã€‚æœ€åå†ç¼–è¾‘commitä¿¡æ¯å³å¯ã€‚å¦‚æœåªæ˜¯åˆå¹¶æˆä¸€ä¸ªcommitçš„è¯ï¼Œå¯ä»¥ç›´æ¥ç„¶åå†commitä¸€æ¬¡å°±å¥½ä»indexä¸­ç§»é™¤æ–‡ä»¶git rm --cached removed_file"},{"id":"home-server-guide","title":"å®¶åº­æœåŠ¡å™¨æŠ˜è…¾è®°å½•","content":"ç®€å•è®°å½•è‡ªå·±æœåŠ¡å™¨çš„é…ç½®è¿‡ç¨‹ï¼Œæ–¹ä¾¿éœ€è¦æ—¶æŸ¥çœ‹ä»¥åŠä½†æ„¿å¯¹ä½ æœ‰æ‰€å¸®åŠ©ã€‚æœåŠ¡å™¨é…ç½®æ•´æœºIntel NUCCPUi7-10710Uå†…å­˜16Gç¡¬ç›˜500Gè¥¿æ•°è“ç›˜+1TBå¸Œæ·æœºæ¢°OSUbuntu 20.04.4 LTSé€šç”¨è¿œç¨‹è®¿é—®ï¼šç«¯å£è½¬å‘ï¼ŒDDNS...SSLè¯ä¹¦ï¼šhttps://www.youtube.com/watch?v=c1t_OrIia1Uhttps://certbot.eff.org/instructions?ws=apache&os=ubuntufocalè½¯ä»¶Nextcloudå®‰è£…æ•™ç¨‹åå‘ä»£ç†Pi-holeå®‰è£…ï¼šä½¿ç”¨å®˜æ–¹å®‰è£…è„šæœ¬å³å¯ã€‚æ³¨æ„ï¼šè„šæœ¬æœ‰ä¸ªbugï¼Œå³ä½¿ä½ å·²ç»è£…äº†å…¶ä»–web serverï¼ˆæ¯”å¦‚Apacheï¼‰ä¹Ÿè¦é€‰æ‹©è£…lighttdpï¼Œå¦åˆ™é‡å¯æœåŠ¡çš„æ—¶å€™è„šæœ¬ä¼šå´©æºƒã€‚ã€‚ã€‚ï¼ˆå½“ä½ çœ‹åˆ°æ­¤çš„æ—¶å€™ä¹Ÿè®¸å·²ç»ä¿®å¤äº†ï¼‰é…ç½®Apacheä»¥è®¿é—®web UIä¸€äº›é»‘åå•ï¼šhttps://github.com/blocklistproject/Listshttps://anti-ad.net/domains.txtPhotoprismå®‰è£…åå‘ä»£ç†ï¼ŒæŠŠhttpä¸­çš„photoprismæ¢æˆlocalhostRSSHubdocker composeéƒ¨ç½²Minifluxdocker composeéƒ¨ç½²Navidromedocker-composeqBittorrent(-nox)åœ¨æœåŠ¡å™¨ç”±äºæ²¡æœ‰xorgæ‰€ä»¥è£…çš„æ˜¯noxç‰ˆæœ¬[å®‰è£…æ•™ç¨‹](https://github.com/qbittorrent/qBittorrent/wiki/Running-qBittorrent-without-X-server-(WebUI-only,-systemd-service-set-up,-Ubuntu-15.04-or-newer)ä¸çŸ¥é“ä¸ºå•¥ç”¨å±€åŸŸç½‘ä¹Ÿè®¿é—®ä¸åˆ°ï¼Œä¸€ç§è§£å†³åŠæ³•æ˜¯åˆ©ç”¨sshå»ºç«‹é€šé“ï¼ˆæ•™ç¨‹)ï¼Œæˆ–è€…apacheåå‘ä»£ç†ã€‚"},{"id":"k-th-smallest-substring","title":"åç¼€è‡ªåŠ¨æœºåº”ç”¨ä¹‹æ±‚å­—å…¸åºç¬¬kå°å­ä¸²ï¼ˆåŒ…æ‹¬ä¸ä¸åŒ…æ‹¬ç›¸åŒå­ä¸²ï¼‰","content":"ä¸åŒ…æ‹¬ç›¸åŒå­ä¸²åç¼€è‡ªåŠ¨æœºä¸­æ¯ä¸€ä¸ªè·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªå­ä¸²ï¼Œæ‰€ä»¥ç¬¬kå°å­ä¸²å°±å¯¹åº”ç¬¬kå°è·¯å¾„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆè®¡ç®—ä»æ¯ä¸ªçŠ¶æ€å¼€å§‹æœ‰å¤šå°‘æ¡è·¯å¾„ï¼Œç„¶åå†æ ¹æ®kåˆ¤æ–­èµ°å“ªæ¡è·¯å¾„ã€‚è®¡ç®—è·¯å¾„çš„æ–¹æ³•å¦‚ä¸‹ï¼š\nåŒ…æ‹¬ç›¸åŒå­ä¸²ç”±äºæ ‡å‡†çš„åç¼€è‡ªåŠ¨æœºé‡Œæ˜¯ä½“ç°ä¸å‡ºé‡å¤è·¯å¾„çš„ä¿¡æ¯çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦åœ¨ä¸Šé—®çš„åŸºç¡€ä¸Šç»´æŠ¤æ¯ä¸ªçŠ¶æ€ä»£è¡¨çš„å­ä¸²ä»¬å‡ºç°çš„æ¬¡æ•°:å¦‚ä½•ç†è§£ï¼Ÿå½“å‰çŠ¶æ€çš„å­ä¸²ä»¬éƒ½æ˜¯ä¸‹ä¸€ä¸ªçŠ¶æ€å­ä¸²ä»¬çš„å‰ç¼€ï¼Œæ‰€ä»¥ä¸‹ä¸€ä¸ªçŠ¶æ€çš„å‡ºç°æ¬¡æ•°åº”å½“åŠ åˆ°å½“å‰çŠ¶æ€ä¸Šã€‚ç‰¹åˆ«çš„ï¼Œå¦‚æœå½“å‰çŠ¶æ€æ˜¯ç»ˆæ­¢çŠ¶æ€ï¼Œå®ƒçš„å‡ºç°æ¬¡æ•°åº”ä¸º1ã€‚è·¯å¾„æ•°çš„è®¡ç®—ä¸å‰é¢ç±»ä¼¼ï¼š\nä¾‹é¢˜ï¼š[TJOI2015]å¼¦è®ºä»£ç ï¼š#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nint t;\nstruct SAM {\n    struct state {\n        int len = 0, link = -1;\n        unordered_map<char, int> next;\n        bool is_term;\n        ll occur = 0, path_cnt=0;\n    };\n    // the index of the equivalence class of the whole string\n    int last = 0;\n    vector<state> st;\n\n    void extend(char c) {\n        int cur = (int)st.size();\n        st.emplace_back();\n        st[cur].len = st[last].len + 1;\n\n        int p = last;\n        while (p != -1 && !st[p].next.count(c)) {\n            st[p].next[c] = cur;\n            p = st[p].link;\n        }\n        if (p == -1) st[cur].link = 0;\n        else {\n            int q = st[p].next[c];\n            if (st[p].len + 1 == st[q].len) {\n                st[cur].link = q;\n            } else {\n                int clone = (int)st.size();\n                st.push_back(st[q]);\n                st[clone].len = st[p].len + 1;\n                while (p != -1 && st[p].next[c] == q) {\n                    st[p].next[c] = clone;\n                    p = st[p].link;\n                }\n                st[q].link = st[cur].link = clone;\n            }\n        }\n        last = cur;\n    }\n\n    SAM() { st.emplace_back(); }\n\n    SAM(const string &s) : SAM() {\n        for (auto c : s)\n            extend(c);\n        int p = last;\n        while (p != 0) {\n            st[p].is_term = true;\n            p = st[p].link;\n        }\n    }\n\n    void dfs(int i) {\n        if (st[i].occur) return;\n        if (st[i].is_term) st[i].occur++;\n        for (auto [_, v] : st[i].next) {\n            dfs(v);\n            st[i].occur += st[v].occur;\n            st[i].path_cnt += st[v].path_cnt;\n        }\n        st[i].path_cnt += t ? st[i].occur : 1;\n    }\n\n    string query(ll k) {\n        string ans;\n        int cur = 0;\n        while (k > 0) {\n            for (char c = 'a'; c <= 'z'; c++) {\n                if (!st[cur].next.count(c)) continue;\n                auto &nxt = st[st[cur].next[c]];\n                if (nxt.path_cnt < k) k -= nxt.path_cnt;\n                else {\n                    ans += c;\n                    cur = st[cur].next[c];\n                    k -= t ? st[cur].occur : 1;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    int k;\n    cin >> s >> t >> k;\n    int len = (int)s.size();\n    SAM sa(s);\n    sa.dfs(0);\n    if (sa.st[0].path_cnt<k) cout<< -1 <<'\\n';\n    else cout << sa.query(k);\n    return 0;\n}"},{"id":"kattis-goldbandits","title":"NAIPC2014 F - Gold Bandits é¢˜è§£","content":"å¾ˆè€ƒéªŒæ€ç»´çš„ä¸€é“é¢˜æ­¤é¢˜ä¸ºNorth American Invitational Programming Contest (NAIPC) 2014 Fé¢˜ï¼Œé¢˜ç›®é“¾æ¥ã€‚é¢˜æ„ç»™å‡ºä¸€å¼ å›¾ï¼Œæ¯ä¸ªé¡¶ç‚¹æœ‰çš„é‡‘å­ï¼Œä½ è¦ä»é¡¶ç‚¹1æ²¿æœ€çŸ­è·¯åˆ°é¡¶ç‚¹2ï¼Œå†æ²¿ä»»æ„è·¯å¾„è¿”å›ã€‚å¯¹äºè·¯å¾„ä¸Šçš„æ¯ä¸ªé¡¶ç‚¹ï¼Œä½ å¯ä»¥é€‰æ‹©æŠ¢åŠ«ä»–ä»¬çš„é‡‘å­ï¼Œä½†å¦‚æœä½ æŠ¢äº†é‡‘å­ï¼Œè¿”å›çš„æ—¶å€™å°±ä¸èƒ½ç»è¿‡è¿™ä¸ªé¡¶ç‚¹ï¼Œé—®æœ€å¤šèƒ½æŠ¢å¤šå°‘é‡‘å­ã€‚é¢˜è§£ç”±äºnå¾ˆå°ï¼Œå¯ä»¥è€ƒè™‘æš´åŠ›æšä¸¾æ¯ä¸€æ¡æœ€çŸ­è·¯ã€‚æˆ‘ä»¬ä¸å¦¨æ¢ä¸ªè§’åº¦æ€è€ƒï¼šå»çš„æ—¶å€™å…ˆæŠŠè·¯å¾„ä¸Šçš„é‡‘å­éƒ½æŠ¢äº†ï¼Œå›æ¥çš„æ—¶å€™å†æŠŠç»è¿‡çš„é¡¶ç‚¹çš„é‡‘å­è¿˜å›å»ã€‚è¿™æ ·å›å»çš„è·¯å¾„å°±å¯ä»¥çœ‹ä½œæ˜¯æœ€çŸ­è·¯ï¼šå¦‚æœç»è¿‡åœ¨æ¥çš„è·¯å¾„ä¸Šçš„ç‚¹èŠ±è´¹å°±æ˜¯æ²¡ï¼Œå¦åˆ™èŠ±è´¹å°±æ˜¯0.ä»£ç #include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int i = 2; i < n; i++)\n        cin >> a[i];\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    queue<int> q;\n    q.push(0);\n    vector<int> dep(n, -1);\n    dep[0] = 0;\n    while (!q.empty()) {\n        auto u = q.front();\n        q.pop();\n        for (auto v : g[u]) {\n            if (dep[v] == -1) {\n                dep[v] = dep[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    int ans = 0;\n    vector<bool> vis(n);\n    auto dijkstra = [&]() {\n        vector<int> dis(n, -1);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> q;\n        dis[0] = 0;\n        q.emplace(0, 0);\n        while (!q.empty()) {\n            auto [d, u] = q.top();\n            q.pop();\n            if (d != dis[u]) continue;\n            for (auto v : g[u]) {\n                int nd = d + (vis[v] ? a[v] : 0);\n                if (dis[v] == -1 || nd < dis[v]) {\n                    dis[v] = nd;\n                    q.emplace(nd, v);\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i]) sum += a[i];\n        }\n        ans = max(ans, sum - dis[1]);\n    };\n    auto dfs = [&](auto &me, int u) -> void {\n        vis[u] = true;\n        for (auto v : g[u]) {\n            if (v == 1) dijkstra();\n            else if (dep[v] == dep[u] + 1 && dep[v] < dep[1])\n                me(me, v);\n        }\n        vis[u] = false;\n    };\n    dfs(dfs, 0);\n    cout << ans << '\\n';\n    return 0;\n}"},{"id":"kattis_fareysums","title":"Kattis - Farey Sumsé¢˜è§£","content":"ç»è¿‡é•¿æ—¶é—´æ€è€ƒå¹¶è§£å†³è°ƒé—®é¢˜çš„æ„Ÿè§‰å¤ªå¥½äº†  â€”â€”xlsé¢˜ç›®é“¾æ¥ç½‘ä¸Šçš„é¢˜è§£æ¯”è¾ƒå°‘è€Œä¸”éƒ½è®²çš„æ¯”è¾ƒè·³è·ƒï¼Œä¸çŸ¥é“æ˜¯ä»–ä»¬å¤ªèªæ˜è¿˜æ˜¯æˆ‘å¤ªç¬¨äº†ã€‚äºæ˜¯æœ¬ç€åˆ¨æ ¹é—®åº•çš„ç²¾ç¥æˆ‘è¯¦ç»†æ¨å¯¼äº†ä¸‹è¿‡ç¨‹ã€‚å¦‚æœæƒ³éº»çƒ¦äº†æ¬¢è¿æŒ‡æ­£ã€‚é¦–å…ˆï¼Œfareyæ•°åˆ—çš„åˆ†æ¯æ„æˆçš„æ•°åˆ—ä¸€å®šæ˜¯å¯¹ç§°çš„ï¼Œå› ä¸ºå¦‚æœåˆ†å­ä¸åˆ†æ¯äº’è´¨ï¼Œé‚£ä¹ˆåˆ†æ¯ä¸åˆ†å­çš„å·®ä¹Ÿä¸€å®šä¸åˆ†æ¯äº’è´¨ï¼Œè¿™ä¸ªå¯ä»¥ç”¨åè¯æ³•è¯æ˜ï¼šè®¾åˆ†æ¯æ˜¯ï¼Œåˆ†å­æ˜¯ï¼Œå¦‚æœä¸ä¸äº’è´¨ï¼Œé‚£ä¹ˆå¯ä»¥å†™æˆé‚£ä¹ˆä¸ä¹Ÿä¸äº’è´¨ï¼Œæ‰€ä»¥ä¸è¦ä¹ˆéƒ½åœ¨æ•°åˆ—é‡Œè¦ä¹ˆéƒ½ä¸åœ¨æ•°åˆ—é‡Œã€‚å…¶æ¬¡ï¼Œè®¾å½“å‰çš„orderæ˜¯,é‚£ä¹ˆå½“orderå¢åŠ åˆ°æ—¶ï¼Œå°†ä¼šæœ‰ä¸ªæ•°è¢«æ’å…¥ï¼Œè¿™ä¸ªé“ç†å¾ˆç®€å•ï¼šå¦‚æœä¸æ˜¯äº’è´¨çš„è¯å°±è¢«çº¦æ‰äº†ã€‚ä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸‹æ’å…¥çš„è¿™äº›æ•°å¯¹farey sumsæœ‰ä»€ä¹ˆå½±å“ï¼šè®¾æ’åˆ°äº†ä¸ä¹‹ä¸­ï¼Œæˆ‘çœ‹åˆ°çš„é¢˜è§£éƒ½ç›´æ¥ç»™å‡ºäº†ç»“è®ºè¿™ä¸ªç»“è®ºçœ‹èµ·æ¥å¾ˆç¥å¥‡ï¼ˆäº‹å®ä¸Šè¿˜æœ‰ï¼‰ï¼Œä½†æˆ‘æ€ä¹ˆä¹Ÿæƒ³ä¸å‡ºæ¥è¿™ä¸ªæ˜¯æ€ä¹ˆå¾—åˆ°çš„ï¼Œäºæ˜¯æˆ‘ä¸Šäº†ç»´åŸºç™¾ç§‘å¾—åˆ°äº†æ€è·¯ï¼šé¦–å…ˆè¦å…ˆè¯æ˜ä¸å¦‚æœåœ¨orderä¸ºä¸­æ˜¯ç›¸é‚»çš„ä¸¤é¡¹ï¼ˆå‡è®¾åœ¨åï¼Œå†™å®Œæ‰å‘ç°åé¢è¯æ˜æŠŠä¸¤ä¸ªå¼„åäº†ï¼Œæ‡’çš„æ”¹äº†â€¦â€¦ï¼‰é‚£ä¹ˆæœ‰å³ï¼Œè¿™ä¸ªç»´åŸºä¸Šä¹Ÿæ²¡ç»™å‡ºè¯æ˜ï¼Œä¸è¿‡æ¯”è¾ƒå¥½æƒ³ï¼Œä¾ç„¶æ˜¯åè¯æ³•ï¼šå¦‚æœä¸¤ä¸ªæ•°ä¹‹é—´è¿˜æœ‰å…¶ä»–çš„æ•°ï¼Œé‚£ä¹ˆï¼Œå¦‚æœ æˆ‘ä»¬å°±çœ‹å‰é¢é‚£ä¸ªä¸ç­‰å¼ï¼Œé€šåˆ†å¾—ï¼Œå› ä¸ºæ‰€ä»¥ï¼Œä½†å› ä¸ºorderä¸ºæ‰€ä»¥mä¸èƒ½å¤§äºï¼Œä¸å‡è®¾çŸ›ç›¾ã€‚çš„æƒ…å†µä¸å‰é¢åŒç†ã€‚æœ‰äº†è¿™ä¸ªæˆ‘ä»¬å°±å¯ä»¥è½»æ¾è¯æ˜å½“ä¸ä¹‹é—´æœ‰æ–°çš„æ•°æ’å…¥æ—¶é‚£ä¹ˆæœ‰ç§»é¡¹å¾—ï¼Œæœ€ç»ˆå¾—åˆ°æ˜ç™½äº†è¿™å…³é”®çš„ä¸€æ­¥ä¹‹åï¼ŒåŸæ¥farey sumsä¸­å’Œï¼ˆæ•°åˆ—ä¸­å¯¹ç§°çš„ä¸¤é¡¹ï¼‰å°±å˜æˆäº†ï¼Œæ‰€ä»¥æ¯æ’å…¥ä¸¤é¡¹ï¼Œfarey sumså°±å¢åŠ 3ï¼Œä¸€å…±æ’å…¥äº†é¡¹ï¼Œé‚£ä¹ˆfarey sumså°±å¢åŠ äº†ï¼Œåˆå› ä¸ºorderä»0å˜æˆ1çš„æ—¶å€™åªå¢åŠ äº†1,æ¯”å°‘äº†ï¼Œæ‰€ä»¥æœ€ç»ˆç­”æ¡ˆåº”ä¸ºä»£ç #include <iostream>\r\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\r\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\r\nusing namespace std;\r\n\r\nconst int N = 10005;\r\nint phi[N], phisum[N];\r\nvoid phi_table(int n) {\r\n  phi[1] = 1;\r\n  for (int i = 2; i <= n; i++)\r\n    if (!phi[i])\r\n      for (int j = i; j <= n; j += i) {\r\n        if (!phi[j])\r\n          phi[j] = j;\r\n        phi[j] = phi[j] / i * (i - 1);\r\n      }\r\n}\r\nint main() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(0);\r\n  int n;\r\n  cin >> n;\r\n  phi_table(10000);\r\n  for1(i, 10000) phisum[i] = phisum[i - 1] + phi[i];\r\n  for1(i, n) {\r\n    int p, x;\r\n    cin >> x >> p;\r\n    cout << x << ' ' << (3 * phisum[p] - 1) << \"/2\\n\";\r\n  }\r\n  return 0;\r\n}"},{"id":"knapsack-binary-optimization","title":"äºŒè¿›åˆ¶åˆ†ç»„ä¼˜åŒ–èƒŒåŒ…","content":"å…³äºåå­—åå­—çœ‹ä¸æ‡‚æ— æ‰€è°“ï¼Œæˆ‘çœ‹æœ‰ä¸€ç¯‡åšå®¢è¿™ä¹ˆå«æ„Ÿè§‰æœ‰ç‚¹é“ç†å°±ä¹Ÿè¿™ä¹ˆå«äº†ï¼Œdlsç®¡è¿™ä¸ªå«æ•°ä½èƒŒåŒ…ï¼Œä½†é‚£æ ·å«å°±æ„Ÿè§‰æœ‰ç‚¹è‡ªæˆä¸€æ´¾ï¼Œå…¶å®å°±æ˜¯ä¸€ç§ç‰¹æ®Šçš„01èƒŒåŒ…ã€‚å¼•å…¥ç›´æ¥çœ‹ä¸€ä¸ªä¾‹é¢˜ï¼š[HNOI2007]æ¢¦å¹»å²›å®ç ï¼Œé¢˜æ„å°±æ˜¯ä¸€ä¸ªå®¹é‡å¾ˆå¤§çš„01èƒŒåŒ…é—®é¢˜ï¼Œä½†èƒ½å†™æˆ çš„å½¢å¼ã€‚è¿™ä¸ªç‰¹æ®Šé™åˆ¶å°±å¼€å§‹æš—ç¤ºæˆ‘ä»¬ä»äºŒè¿›åˆ¶çš„è§’åº¦è€ƒè™‘ï¼Œæˆ‘ä»¬è¦åšçš„æ˜¯å°†ç‰©å“æŒ‰åˆ†ç»„ï¼Œä»å¤§åˆ°å°ï¼Œæ¯æ¬¡è€ƒè™‘ä¸€ä¸ªåˆ†ç»„é‡Œæˆ‘ç‰©å“ã€‚å½“å¯¹åˆ†ç»„è¿›è¡Œdpæ—¶ï¼Œè®¾å½“å‰å‰©ä½™çš„å®¹é‡ä¸ºï¼Œç”±äºåˆ†ç»„é‡Œç‰©å“é‡é‡éƒ½èƒ½å†™æˆçš„å½¢å¼ï¼Œæ‰€ä»¥åªæœ‰å®¹é‡çš„ç³»æ•°ä¼šå˜åŒ–ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åªç”¨ç³»æ•°æ¥ä»£è¡¨å½“å‰å‰©ä½™å®¹é‡ã€‚å…¶å®æœ€é‡è¦çš„é™åˆ¶æ˜¯ ï¼Œå› ä¸ºä»»ä½•æ•°éƒ½èƒ½å†™æˆ  çš„å½¢å¼ï¼Œåªä¸è¿‡  å¾ˆå¤§ç½¢äº†ã€‚ å¾ˆå°è¿™ä¸ªé™åˆ¶å°±ç¡®ä¿äº†æ•´ä¸ªç»„é‡Œæ‰€æœ‰ç‰©å“çš„é‡é‡ä¹‹å’Œä¸è¶…è¿‡ ï¼ˆ100æ¥è‡ªäºé¢˜ç›®ä¸­æœ€å¤šæœ‰100ä¸ªç‰©å“çš„é™åˆ¶ï¼‰ã€‚å†ç»“åˆä¸Šä¸€æ®µä¸­ç”¨ç³»æ•°è¡¨ç¤ºå®¹é‡çš„æ–¹æ³•ï¼Œè¿™æ ·é‡é‡çš„çŠ¶æ€å°±ä»æ ‡å‡†01èƒŒåŒ…åšæ³•çš„ç¼©å°åˆ°äº†1000ï¼è¿™å°±æ˜¯æœ¬é¢˜çš„æ ¸å¿ƒæ€æƒ³ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬è¯´çŠ¶æ€è½¬ç§»ï¼Œä»¤ä¸ºè€ƒè™‘å®ŒåŠä»¥ä¸Šçš„ç»„ä¹‹åï¼ŒèƒŒåŒ…å‰©ä½™å®¹é‡ä¸ºæ—¶èƒ½å¾—åˆ°çš„æœ€é«˜ä»·å€¼ï¼ˆçš„ä¸Šé™ä¸º1000ï¼Œå› ä¸ºå†å¤šäº†åé¢çš„ç‰©å“ä¹Ÿç”¨ä¸å®Œï¼‰ã€‚åœ¨ä¸€ä¸ªåˆ†ç»„å†…dpæ—¶å°±æ˜¯å¸¸è§„çš„01èƒŒåŒ…ï¼Œé‡ç‚¹åœ¨äºä»è½¬ç§»åˆ°ï¼šå½“å‰å‰©ä½™å®¹é‡ å˜æˆ ï¼Œå…¶ä¸­ä»£è¡¨èƒŒåŒ…æ€»å®¹é‡äºŒè¿›åˆ¶è¡¨ç¤ºçš„ç¬¬ä½ï¼Œç°åœ¨åŠ ä¸Šæ˜¯å› ä¸ºä¹‹å‰è¿™éƒ¨åˆ†å®¹é‡å¤ªå°äº†ç”¨ä¸ä¸Šï¼Œåœ¨è€ƒè™‘ç»„çš„æ—¶å€™å°±èƒ½ç”¨ä¸Šäº†ã€‚ç”¨ä»£ç è¡¨ç¤ºä¸€ä¸‹è½¬ç§»çš„è¯å°±æ˜¯dp[i - 1][j * 2 + s[i - 1]] = max(dp[i - 1][j * 2 + s[i - 1]], dp[i][j]);#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    while (cin >> n >> m) {\n        if (n == -1 && m == -1) break;\n\n        const int N = 31;\n        vector<int> s(N), weight(n), value(n);\n        vector<vector<int>> items(N);\n        vector dp(N, vector<int>(1001, -1e9));\n\n        for (int i = 0; i < N; i++) {\n            s[i] = m >> i & 1;\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> weight[i] >> value[i];\n            int b = 0;\n            while (weight[i] % 2 == 0) {\n                weight[i] /= 2;\n                b++;\n            }\n            items[b].push_back(i);\n        }\n\n        auto cmax = [](auto &x, auto y) { x = max(x, y); };\n\n        for (int i = N - 1; i >= 0; i--) {\n            cmax(dp[i][s[i]], 0);\n            for (auto item : items[i]) { // ç»„å†…dp\n                for (int j = 0; j + weight[item] <= 1000; j++) {\n                    cmax(dp[i][j], dp[i][j + weight[item]] + value[item]);\n                }\n            }\n            if (i) { // è½¬ç§»åˆ°ä¸‹ä¸€ç»„\n                for (int j = 0; j <= 1000; j++) {\n                    cmax(dp[i - 1][min(j * 2 + s[i - 1], 1000)], dp[i][j]);\n                }\n            }\n        }\n        cout << *max_element(begin(dp[0]), end(dp[0])) << endl;\n    }\n}å¦ä¸€é“é¢˜æ¥ä¸‹æ¥çœ‹ä¸€é“ä¸æ˜¯å¾ˆâ€œèƒŒåŒ…â€çš„é¢˜CF1670F. Jee, You See?ï¼Œæ ¸å¿ƒæ€è·¯ä¸å˜ã€‚å˜äº†çš„åœ°æ–¹åŠå¯¹åº”çš„è§£å†³æ–¹æ³•ï¼šæœ€å¤§é‡é‡å˜æˆäº†æ–¹æ³•æ•°maxå˜æˆ+ç‰©å“å˜æˆäº†æ•°ç»„ä¸­ç¬¬ä½1çš„ä¸ªæ•°ï¼Œå¯ä»¥é€‰ä»0åˆ°nä¸ªç›¸å½“äºä¸Šé¢çš„é¢˜ä¸­çš„ä»0åˆ°å„ä¸€ä¸ªï¼Œéå†å³å¯å¼‚æˆ–çš„é™åˆ¶å¦‚æœå½“å‰ä½æ˜¯ï¼Œé‚£å°±é€‰ä¸ªï¼Œå¦‚æœæ˜¯å°±é€‰ä¸ª#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    ModInt(int v = 0) : val(v % MOD) { if (val < 0) val += MOD; };\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const {\n        auto a = val, m = MOD, u = 0, v = 1;\n        while (a != 0) { auto t = m / a; m -= t * a; swap(a, m); u -= t * v; swap(u, v); }\n        assert(m == 1);\n        return u;\n    }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    friend ModInt operator+ (ModInt lhs, const ModInt& rhs) { return lhs += rhs; }\n    friend ModInt operator- (ModInt lhs, const ModInt& rhs) { return lhs -= rhs; }\n    friend ModInt operator* (ModInt lhs, const ModInt& rhs) { return lhs *= rhs; }\n    friend ModInt operator/ (ModInt lhs, const ModInt& rhs) { return lhs /= rhs; }\n    ModInt& operator+=(const ModInt& x) { if ((val += x.val) >= MOD) val -= MOD; return *this; }\n    ModInt& operator-=(const ModInt& x) { if ((val -= x.val) < 0) val += MOD; return *this; }\n    ModInt& operator*=(const ModInt& x) { val = int64_t(val) * x.val % MOD; return *this; }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<1'000'000'007>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    ll l, r, z;\n    cin >> n >> l >> r >> z;\n\n    vector<mint> choose(n + 1);\n    choose[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        choose[i] = choose[i-1] * (n - i + 1) / i;\n    }\n\n    auto solve = [&](ll r) {\n        vector<mint> dp(n + 1);\n        dp[0] = 1;\n        for (int i = 59; i >= 0; i--) {\n            int s = r >> i & 1;\n            vector<mint> ndp(n + 1);\n            for (int j = 0; j <= n; j++) {\n                int k = j * 2 + s;\n                for (int x = z >> i & 1; x <= n && x <= k; x += 2) {\n                    ndp[min(n, k - x)] += dp[j] * choose[x];\n                }\n            }\n            swap(dp, ndp);\n        }\n        return accumulate(begin(dp), end(dp), mint{});\n    };\n\n    cout << solve(r) - solve(l - 1) << endl;\n}"},{"id":"latex-pictures","title":"LaTex æ’å…¥å›¾ç‰‡","content":"åŒ…\\usepackage{graphicx}è®¾å®šå›¾ç‰‡ç›®å½•\\graphicspath{ {./images1/}{./images2/} }æ’å…¥å›¾ç‰‡\\includegraphics{universe}å‚æ•°scalewidthheightangle"},{"id":"longestPathOnDAG","title":"DAGä¸Šæœ€é•¿è·¯","content":"vector<int> G[N];\nint dp[N];\n\nint get(int u){\n\tif(dp[u]) return dp[u];\n\tfor(auto it:G[u]){\n\t\tdp[u]=max(dp[u],get(it)+1);\n\t}\n\treturn dp[u];\n}"},{"id":"luatex-chinese-guide","title":"åœ¨LuaTex/LuaLaTexä½¿ç”¨ä¸­æ–‡ï¼Œé™„Font KaitiSC not found.è§£å†³æ–¹æ³•","content":"å¦‚æœæ˜¯ä¸­æ–‡æ–‡æ¡£çš„è¯å¯ä»¥ç”¨ctexåŒ…ï¼š\\usepackage{ctex}\n\\setCJKmainfont{Source Han Sans SC} % è®¾ç½®é»˜è®¤ä¸­æ–‡å­—ä½“\n\\setCJKfamilyfont{songti}{FZShuSong-Z01S} % è®¾ç½®é»˜è®¤å®‹ä½“å­—ä½“\n% ä¸Šé¢çš„songtiä¹Ÿå¯ä»¥æ¢æˆåˆ«çš„ï¼Œé»˜è®¤å®šä¹‰äº†songtiã€heitiã€fangsong\n\n\\begin{document}\nä½¿ç”¨é»˜è®¤å­—ä½“\n{\\heiti ä½¿ç”¨ç‰¹å®šå­—ä½“}\n\\end{document}å¦‚æœåªåŠ å…¥å°‘é‡ä¸­æ–‡çš„è¯å¯ä»¥ç›´æ¥è°ƒç”¨ä¸­æ–‡å­—ä½“ï¼š\\usepackage{fontspec}\n\\newfontfamily{\\han}{Source Han Sans SC}\n\n\\begin{document}\n{\\han ä¸­æ–‡}\n\\end{document}é™„ï¼šmacOSä¸‹â€œThe font \"KaitiSC\" cannot be found.â€è§£å†³æ–¹æ¡ˆè¯¦ç»†æƒ…å†µè¯·çœ‹åŸæ–‡, Montereyä¸‹æ‰§è¡Œsudo tlmgr conf texmf OSFONTDIR /System/Library/AssetsV2/com_apple_MobileAsset_Font7"},{"id":"manjaro-setup","title":"Manjaro æŠ˜è…¾è®°å½•","content":"éšç¼˜æ›´æ–°ï¼Œæƒ³åˆ°å•¥å°±è®°å•¥é…ç½®è§¦æ‘¸æ¿ä¸€å¼€å§‹å‘ç°è§¦æ‘¸æ¿å³é”®å’Œå·¦é”®æ•ˆæœæ˜¯ä¸€æ ·çš„ï¼ŒåŒæŒ‡è½»æŒ‰è¿˜æ˜¯ä¸­é”®â€¦â€¦è§£å†³æ–¹æ³•ï¼šç¼–è¾‘ Section \"InputClass\"\n    Identifier \"touchpad\"\n    MatchIsTouchpad \"on\"\n    MatchDevicePath \"/dev/input/event*\"\n    Driver \"libinput\"\n    Option \"Tapping\" \"on\"\n    Option \"ButtonMapping\" \"1 3 2\"\n    Option \"TappingButtonMap\" \"lmr\"\nEndSectionæ˜ å°„caps+hjklä¸ºæ–¹å‘é”®ç¼–è¾‘clear lock\nkeycode  43 = h H Left H\nkeycode  44 = j J Down J\nkeycode  45 = k K Up K\nkeycode  46 = l L Right L\nkeycode  66 = Mode_switch Caps_Lock\nkeycode  31 = i I KP_Home I\nkeycode  32 = o O KP_End OThen update xmodmap:xmodmap ~/.Xmodmapè§£å†³æŒ‚èµ·åå¤±æ•ˆçš„é—®é¢˜ï¼šsudo touch /usr/lib/systemd/system-sleep/xkeyboard\nsudo chmod 755 /usr/lib/systemd/system-sleep/xkeyboardç¼–è¾‘#!/bin/bash\n\ncase $1 in\n    pre)\n        exit 0\n    ;;\n    post)\n        export DISPLAY=:0\n        sleep 10\n        xmodmap /home/thallium/.Xmodmap\n    ;;\nesacä¸»é¢˜arcsudo pacman -S arc-gtk-themeè½¯ä»¶vimé…ç½®å¾…æ›´æ–°fcitxç è¡¨å¾…æ›´æ–°Autojumpå¿«é€Ÿè·³è½¬æ–‡ä»¶å¤¹ï¼Œå†ä¹Ÿä¸ç”¨é•¿é•¿çš„cdäº†ï½å®‰è£…yay autojumpSource the correct autojump fileecho \"/usr/share/autojump/autojump.bash\" >> ~/.bashrc\nchmod 755 /usr/share/autojump/autojump.bash\nsource ~/.bashrcæ³¨æ„äº‹é¡¹å¿«é€Ÿè·³è½¬çš„æ–‡ä»¶å¤¹éœ€è¦æ­£å¸¸è®¿é—®ä¸€æ¬¡ã€‚æˆªå›¾: Deepin screenshotä¸€å¼€å§‹ç”¨çš„æ˜¯ç«ç„°æˆªå›¾ï¼Œä½†æ˜¯ä¸èƒ½è‡ªåŠ¨è¯†åˆ«çª—å£ï¼Œåæ¥å¶ç„¶å‘ç°deepin screenshotæ„Ÿè§‰æŒºä¸é”™çš„ã€‚sudo pacman -S deepin-screenshotå¦‚æœä¸èƒ½æ­£å¸¸å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼Œå®‰è£…è¯å…¸Wudao dictå®‰è£…ï¼šgit clone https://github.com/chestnutheng/wudao-dict\ncd ./wudao-dict/wudao-dict\nsudo bash setup.shé—®é¢˜è§£å†³ä¿®æ”¹å¯¼è‡´å¾ªç¯ç™»å½•2020.03.27ä¸€èˆ¬çš„è§£å†³æ–¹æ³•æ˜¯ä»å‘½ä»¤è¡Œç™»å½•ç„¶åæ¢å¤ä¹‹å‰çš„ä¿®æ”¹ï¼Œä½†æˆ‘ä»å‘½ä»¤è¡Œä¹Ÿæ˜¯å¾ªç¯ç™»å½•â€¦â€¦äºæ˜¯æƒ³åˆ°èƒ½ä¸èƒ½ä»windowsä¿®æ”¹ç„¶åå‘ç°æœ‰ä¸ªè½¯ä»¶å«linux file system for windowsï¼Œç„¶åé—®é¢˜å°±è§£å†³äº†ã€‚çœŸçš„å¤ªä¸å®¹æ˜“äº†ï¼Œå¿ƒæ€å·®ç‚¹å´©äº†â€¦â€¦Gnome-shellå†…å­˜æ³„æ¼é—®é¢˜gnomeä¼ ç»Ÿè‰ºèƒ½ï¼Œå†è¾“å…¥å¯ä»¥é‡æ–°å¯åŠ¨shellã€‚è®©gvimé»˜è®¤åœ¨æ–°æ ‡ç­¾ä¸­å¯åŠ¨ç¼–è¾‘æŠŠExec=gvim -f %Fæ”¹æˆExec=gvim -p --remote-tab-silent %Fi3wmä¸‹è¿è¡ŒQQ/TIM/Wechat2020-04-13åŸä½œè€…nohup /usr/lib/gsd-xsettings > /dev/null 2>&1 &\ncd /opt/deepinwine/apps/Deepin-TIM\n./run.shæœ€åå°†ç¬¬ä¸€æ­¥æ·»åŠ åˆ°i3å¯åŠ¨é¡¹é‡Œã€‚"},{"id":"math_model","title":"ä¸€äº›æ•°å­¦æ¨¡å‹","content":"æ€»ç»“ä¸€äº›å¸¸è§çš„æ•°å­¦æ¨¡å‹ã€‚å°†ç›´çº¿ä¸Šå¤šä¸ªç‚¹ç§»åŠ¨åˆ°ä¸€ä¸ªç‚¹çš„æœ€å°è·ç¦»ç§»åŠ¨åˆ°æœ€ä¸­é—´çš„é‚£ä¸ªç‚¹è·ç¦»æœ€å°ï¼Œæˆ–è€…è¯´æ˜¯ç§»åŠ¨åˆ°ä¸€ç‚¹ä½¿å¾—ä¸¤ä¾§çš„ç‚¹ä¸€æ ·å¤šã€‚å°†ç›´çº¿ä¸Šå¤šä¸ªç‚¹ç§»åŠ¨åˆ°è¿ç»­çš„ä½ç½®å‡è®¾èµ·ç‚¹ä¸º, ä¹Ÿå°±æ˜¯è¯´æœ€å°åŒ–, äºæ˜¯é—®é¢˜åˆè½¬åŒ–æˆäº†å°†åæ ‡ä¸ºçš„ç‚¹ç§»åŠ¨åˆ°ä¸€ç‚¹çš„é—®é¢˜ï¼Œå–ä¸­é—´çš„åæ ‡å³å¯ã€‚Chicken McNugget Theoremå‡è®¾äº’è´¨ï¼Œæœ€å¤§çš„ä¸èƒ½è¢«è¡¨ç¤ºä¸ºçš„æ•°æ˜¯.sourceæœ€å°åŒ–ä¸€ç‚¹åˆ°å…¶ä»–ç‚¹è·ç¦»çš„å¹³æ–¹çš„å’Œç”±äºï¼Œè€Œxå’Œyå¯ä»¥ç‹¬ç«‹æ”¹å˜ï¼Œæ‰€ä»¥å¯ä»¥åˆ†åˆ«æœ€å°åŒ–ä¸¤ä¸ªåæ ‡è½´çš„è·ç¦»ï¼Œä¹Ÿå°±æ˜¯åæ ‡çš„å¹³å‡æ•°ã€‚"},{"id":"minimum_path_cover","title":"æ ‘å’ŒDAGçš„æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜","content":"è·¯å¾„è¦†ç›–æ˜¯ä¸€ä¸ªè·¯å¾„çš„é›†åˆä½¿å¾—æ¯ä¸ªé¡¶ç‚¹éƒ½åªè¢«ä¸€æ¡è·¯å¾„è¦†ç›–ã€‚æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜è¦æ±‚é›†åˆä¸­è·¯å¾„çš„æ¡æ•°æ˜¯æœ€å°çš„ã€‚æ ‘çš„æœ€å°è·¯å¾„è¦†ç›–åšæ³•1ï¼šDPä»£è¡¨å½“uä¸ä¸ºè·¯å¾„çš„ç«¯ç‚¹çš„æ—¶å€™ï¼Œu çš„å­æ ‘é‡Œæœ€å°‘çš„è·¯å¾„çš„æ•°ç›®ï¼Œä»£è¡¨å½“uä¸ºè·¯å¾„çš„ç«¯ç‚¹çš„æ—¶å€™ï¼Œu çš„å­æ ‘é‡Œæœ€å°‘çš„è·¯å¾„çš„æ•°ç›®ã€‚è®¾ä¸ºuçš„å„¿å­ï¼ŒçŠ¶æ€è½¬ç§»æ—¶uä¸ä¸ºç«¯ç‚¹çš„æƒ…å†µå¯ä»¥æ˜¯ä¹‹å‰uä¸ä¸ºç«¯ç‚¹çš„æƒ…å†µåŠ ä¸Švä¸ä¸ºç«¯ç‚¹çš„æƒ…å†µï¼Œå³:ä¹Ÿå¯ä»¥æ˜¯ä»¥uä¸ºç«¯ç‚¹çš„è·¯ä¸ä»¥vä¸ºç«¯ç‚¹ çš„è·¯è¿æˆä¸€æ¡è·¯ï¼Œå³:uä¸ºç«¯ç‚¹çš„æƒ…å†µç±»ä¼¼ï¼Œå¯ä»¥æ˜¯ä¹‹å‰uä¸ºç«¯ç‚¹çš„æƒ…å†µåŠ ä¸Švä¸ä¸ºç«¯ç‚¹çš„æƒ…å†µï¼Œå³ï¼šä¹Ÿå¯ä»¥æ˜¯å‰é¢æ‰€æœ‰å„¿å­çš„ä¸ä»¥å„¿å­ä¸ºç«¯ç‚¹çš„è·¯å¾„åŠ ä¸Šä»¥vä¸ºç«¯ç‚¹çš„è·¯å¾„,å³ï¼šç»¼ä¸Šæ‰€è¿°ï¼šå¦‚æœè¦è®°å½•æ–¹æ¡ˆçš„è¯åªå…ˆåœ¨dpçš„è¿‡ç¨‹ä¸­è®°å½•ç»è¿‡uçš„è·¯å¾„å¾€ä¸‹èµ°çš„å„¿å­ï¼Œç„¶åå†è·‘ä¸€édfsæ„å»ºè·¯å¾„ã€‚ä»£ç ï¼švector dp(n, vector<int>(2));\nvector nxt(n, vector(2, pair{-1, -1}));\n\nauto dfs=[&](auto& dfs, int u, int p) -> void {\n    dp[u][0]=dp[u][1]=1;\n    int sum=0;\n    for (auto v : g[u]) {\n        if (v==p) continue;\n        dfs(dfs, v, u);\n        if (dp[u][0]+dp[v][0] > dp[u][1]+dp[v][1]-1) {\n            nxt[u][0]={nxt[u][1].first, v};\n        }\n        dp[u][0]=min(dp[u][0]+dp[v][0], dp[u][1]+dp[v][1]-1);\n        if (dp[u][1]+dp[v][0] > sum+dp[v][1]) {\n            nxt[u][1]={v, v};\n        }\n        dp[u][1]=min(dp[u][1]+dp[v][0], sum+dp[v][1]);\n        sum+=dp[v][0];\n    }\n};\n\nvector<vector<int>> end_point(n); //è·¯å¾„çš„ç«¯ç‚¹\nvector<pii> remove; // ä¸åœ¨è·¯å¾„è¦†ç›–ä¸­çš„è·¯å¾„\nint tot{};\nauto dfs2=[&](auto& dfs2, int u, int p, int flag, int id) -> void { // id ä¸ºå½“å‰è·¯å¾„çš„ç¼–å·\n    for (auto v : g[u]) {\n        if (v==p) continue;\n        if (v==nxt[u][flag].first || v==nxt[u][flag].second) {\n            dfs2(dfs2, v, u, 1, id);\n        } else {\n            remove.emplace_back(u, v);\n            tot++;\n            int nflag=dp[v][0]<dp[v][1] ? 0 : 1;\n            if (nflag) end_point[tot].push_back(v);\n            dfs2(dfs2, v, u, nflag, tot);\n        }\n    }\n    if (nxt[u][flag]==pair{-1, -1}) end_point[id].push_back(u);\n};åšæ³•2ï¼šè´ªå¿ƒè´ªå¿ƒåšæ³•æ›´åŠ ç®€å•ï¼Œåªç”¨ä¸€ä¸ªdfså°±èƒ½å®ç°ã€‚å¦‚æœuæœ‰ä¸¤ä¸ªå„¿å­æ˜¯è·¯å¾„çš„ç«¯ç‚¹é‚£ä¹ˆå°±è¿æ¥é‚£ä¸¤æ¡è·¯ï¼Œå¦åˆ™å°±å°†uåšä¸ºç«¯ç‚¹ã€‚ä»£ç ï¼švector<pii> end_points, remove;\nauto dfs=[&](auto& dfs, int u, int p) -> int { // è¿”å›-1ä»£è¡¨uä¸æ˜¯ç«¯ç‚¹ï¼Œå¦åˆ™è¿”å›ä»¥uä¸ºç«¯ç‚¹çš„è·¯å¾„çš„å¦ä¸€ç«¯ã€‚\n    vector<int> next;\n    for (auto v : g[u]) {\n        if (v==p) continue;\n        int end_v=dfs(dfs, v, u);\n        if (end_v>=0) {\n            if (next.size() <= 1) {\n                next.push_back(end_v);\n            } else {\n                remove.emplace_back(u, v);\n                end_points.emplace_back(end_v, v);\n            }\n        } else {\n            remove.emplace_back(u, v);\n        }\n    }\n\n    if (next.empty()) next.push_back(u);\n    if (next.size()==1) {\n        if (p!=-1) return next[0];\n        end_points.emplace_back(next[0], u);\n        return -1;\n    } else {\n        end_points.emplace_back(next[0], next[1]);\n        return -1;\n    }\n};ç»ƒä¹ é¢˜CF1521D - Nastia Plays with a TreeDAGçš„æœ€å°è·¯å¾„è¦†ç›–æˆ‘ä»¬æŠŠåŸå›¾ä¸Šçš„æ¯ä¸ªç‚¹æ‹†æˆä¸¤ä¸ªç‚¹ï¼ˆå¯¹äºç‚¹ï¼Œå¯ä»¥æŠŠä»å®ƒæ‹†å‡ºå»çš„ç‚¹è®°ä¸ºï¼‰ï¼Œå…¶ä¸­ä¸€ä¸ªç‚¹ä¸æºç‚¹ç›¸è¿ï¼Œå¦ä¸€ä¸ªä¸æ±‡ç‚¹ç›¸è¿ã€‚å¯¹äºåŸDAGä¸Šçš„è¾¹ï¼Œåœ¨æ–°å›¾ä¸­è¿æ¥ ï¼Œæ‰€æœ‰è¾¹çš„å®¹é‡å‡ä¸º1ã€‚è·‘ä¸€éæœ€å¤§æµï¼ˆæœ¬è´¨ä¸Šæ˜¯äºŒåˆ†å›¾åŒ¹é…ï¼‰ï¼Œå¾—åˆ°çš„æœ€å¤§æµï¼ˆæˆ–è€…æœ€å¤§åŒ¹é…ï¼‰ä¾¿æ˜¯è¢«è¦†ç›–çš„è¾¹æ•°ï¼Œç”±äºè·¯å¾„ä¸Šçš„ç‚¹æ•°ç­‰äºè¾¹æ•°+1ï¼Œæ‰€ä»¥ç‚¹æ•°å‡è¢«è¦†ç›–çš„è¾¹æ•°ä¾¿æ˜¯è·¯å¾„çš„æ•°ç›®ã€‚ä¹Ÿå¯ä»¥ç†è§£ä¸ºæœ€å¤§æµç»è¿‡çš„æ¯ä¸€æ¡è¾¹å¯¹åº”åŸå›¾ä¸­æœ‰ä¸€æ¡å‘è¾¹çš„èµ·ç‚¹ï¼Œæ‰€ä»¥è·¯å¾„çš„ç»ˆç‚¹æ˜¯æ²¡æœ‰å¯¹åº”çš„è¾¹çš„ï¼Œæ‰€ä»¥ç‚¹æ•°å‡è¢«è¦†ç›–çš„è¾¹æ•°ä¾¿æ˜¯ç»ˆç‚¹çš„æ•°ç›®ä¹Ÿå°±æ˜¯è·¯å¾„çš„æ•°ç›®ã€‚å¦‚ä½•è®°å½•è·¯å¾„ï¼Ÿå¯ä»¥åœ¨å¢å¹¿é€”ä¸­è®°å½•æ¯ä¸ªç‚¹çš„ä¸‹ä¸€ä¸ªç‚¹ã€‚å¦‚ä½•æ‰¾èµ·ç‚¹ï¼Ÿå¦‚æœåˆ°æ±‡ç‚¹çš„å‰©ä½™å®¹é‡ä¸º1ï¼Œè¯´æ˜æ²¡æœ‰ç‚¹æµå‘ï¼Œä¹Ÿå°±è¯´æ˜æ˜¯èµ·ç‚¹ã€‚æ¨¡æ¿é¢˜ï¼šæ´›è°·P2764 æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜ä»£ç ï¼š#include <bits/stdc++.h>\nusing namespace std;\nstruct Flow {\n    static constexpr int INF = 1e9;\n    int n;\n    struct Edge {\n        int to, cap;\n        Edge(int to, int cap) : to(to), cap(cap) {}\n    };\n    std::vector<Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h, nxt; \n\n    Flow(int n) : n(n), g(n), nxt(n) {}\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t) return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t) return f;\n        int r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i) {\n            int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (a) nxt[u] = v; // å¢å¹¿æˆåŠŸä¾¿è®°å½•è·¯å¾„\n                if (r == 0) return f;\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, int c) {\n        g[u].push_back((int)e.size());\n        e.emplace_back(v, c);\n        g[v].push_back((int)e.size());\n        e.emplace_back(u, 0);\n    }\n    void maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        n = (n - 2) / 2;\n        for (int i = n + 1; i <= 2 * n; i++) {\n            if (e[g[i].back()].cap == 1) {\n                int u = i - n;\n                while (u > 0) {\n                    cout << u << ' ';\n                    u = nxt[u] - n;\n                }\n                cout << '\\n';\n            }\n        }\n        cout << n - ans << '\\n';\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    Flow g(2 * n + 2);\n    while (m--) {\n        int u, v;\n        cin >> u >> v;\n        g.addEdge(u, v + n, 1);\n    }\n    for (int i = 1; i <= n; i++) {\n        g.addEdge(0, i, 1);\n        g.addEdge(i + n, 2 * n + 1, 1);\n    }\n    g.maxFlow(0, 2 * n + 1);\n    return 0;\n}å‚è€ƒèµ„æ–™https://zhuanlan.zhihu.com/p/125759333"},{"id":"monotonic_stack","title":"å•è°ƒæ ˆå¸¸è§æ¨¡å‹","content":"æ€»ç»“ä¸€ä¸‹åŠ æ·±å°è±¡å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”å½“å‰å°ä¸¥æ ¼å•è°ƒé€’å¢æ ˆï¼Œå¦‚æœæ±‚çš„æ˜¯æ•°å­—æ ˆå†…å°±å­˜æ•°å­—ï¼Œå¦‚æœæ±‚è·ç¦»æ ˆå†…å°±å­˜æ•°å­—+ä¸‹æ ‡æˆ–è€…æ•°å­—+åˆ°æ ˆå†…å‰ä¸€ä¸ªå…ƒç´ çš„è·ç¦»ã€‚ä¸¾ä¾‹ ç©ºæ ˆï¼Œè¯´æ˜2ä¹‹å‰æ²¡æœ‰æ¯”2å°çš„å…ƒç´ ï¼Œç„¶å2å…¥æ ˆ ä¸ºäº†ä¿æŒå•è°ƒé€’å¢ï¼Œéœ€è¦æŠŠ2å¼¹å‡ºï¼Œå˜æˆç©ºæ ˆï¼Œè¯´æ˜1å‰é¢ä¹Ÿæ²¡æœ‰æ¯”1å°çš„ï¼Œç„¶å1å…¥æ ˆ 6æ¯”1å¤§ï¼Œç›´æ¥å…¥æ ˆï¼Œå…ˆæŠŠæ¯”4å¤§çš„å…ƒç´ å¼¹å‡º,ç„¶åå…¥æ ˆ 5ç›´æ¥å…¥æ ˆ æ±‚è·ç¦»ï¼š ->  ->  ->  ->  -> ä»£ç æ±‚å…ƒç´ ï¼šstack<int> stk\nvector<int> ans(n);\nfor(int i=0;i<n;i++){\n    while(!stk.empty()&&stk.top()>=a[i]) stk.pop();\n    ans[i]=stk.top();\n    stk.push(a[i]);\n}æ±‚è·ç¦»:stack<pair<int,int>> stk;\nvector<int> ans(n);\nfor(int i=0;i<n;i++){\n    int res=1;\n    while(!stk.empty()&&stk.top().first>=a[i]){\n        res+=stk.top().second;\n        stk.pop();\n    }\n    ans[i]=res;\n    stk.push({a[i],res});\n}å·¦è¾¹ç¬¬ä¸€ä¸ªå¤§ï¼Œç¬¬ä¸€ä¸ªå¤§äºç­‰äºï¼Œç¬¬ä¸€ä¸ªå°äºç­‰äºä¸¥æ ¼å•è°ƒé€’å‡æ ˆï¼Œéä¸¥æ ¼é€’å‡æ ˆï¼Œéä¸¥æ ¼é€’å¢å³è¾¹ç¬¬ä¸€ä¸ªå¤§ç­‰ç­‰ä»å³å¾€å·¦å¤„ç†å³å¯"},{"id":"multi-pattern-matching","title":"å¤šæ¨¡å¼ä¸²åŒ¹é…çš„3ç§æ–¹æ³•","content":"ä¾‹é¢˜ï¼š Another Substring Query Problemç”±äºæ¬¡é¢˜ä¸­æ¨¡å¼ä¸²æœ‰é‡å¤ï¼Œä¼šå½±å“æ—¶é—´å¤æ‚åº¦ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦æå‰å¤„ç†ç›¸åŒçš„å­—ç¬¦ä¸²ã€‚ä¸‹é¢çš„æ–¹æ³•å‡å‡è®¾æ— é‡å¤æ¨¡å¼ä¸²ã€‚å¹¶ä»¥ä¸ºæ¨¡å¼ä¸²çš„æ€»é•¿åº¦ï¼Œä¸ºæ–‡æœ¬ä¸²çš„é•¿åº¦ã€‚æ–¹æ³•ä¸€ï¼šå­—ç¬¦ä¸²å“ˆå¸Œç”±äºæ€»é•¿ä¸ºçš„æ¨¡å¼ä¸²æœ€å¤šåªæœ‰ç§é•¿åº¦ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥éå†æ¯ç§é•¿åº¦ç„¶åéå†æ¯ä¸ªä½ç½®ç„¶ååˆ¤æ–­ä»å¼€å§‹é•¿åº¦ä¸ºçš„å­ä¸²æ˜¯å¦æ˜¯æ¨¡å¼ä¸²ã€‚æ—¶é—´å¤æ‚åº¦ä¸ºã€‚#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nstruct PolyHash {\n    static constexpr int mod = (int)1e9 + 123;\n    static vector<int> pow;\n    static constexpr int base = 233;\n\n    vector<int> pref;\n    PolyHash(const string &s) : pref(s.size() + 1) {\n        assert(base < mod);\n        int n = (int)s.size();\n        while ((int)pow.size() <= n) {\n            pow.push_back((ll)pow.back() * base % mod);\n        }\n        for (int i = 0; i < n; i++) {\n            pref[i + 1] = ((ll)pref[i] * base + s[i]) % mod;\n        }\n    }\n\n    int get_hash() { return pref.back(); }\n\n    int substr(int pos, int len) {\n        return (pref[pos + len] - (ll)pref[pos] * pow[len] % mod + mod) % mod;\n    }\n};\nvector<int> PolyHash::pow{1};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin >> s;\n    int len = (int)s.size();\n    PolyHash ha(s);\n    int q;\n    cin >> q;\n    vector<string> qstr(q);\n    vector<int> qk(q);\n    vector<vector<int>> lens(len + 1);\n    vector<int> ans(q);\n    for (int i = 0; i < q; i++) {\n        cin >> qstr[i] >> qk[i];\n        if ((int)qstr[i].size() <= len)\n            lens[qstr[i].size()].push_back(i);\n        else\n            ans[i] = -1;\n    }\n    for (int l = 1; l <= len; l++) {\n        if (lens[l].empty()) continue;\n        unordered_map<int, vector<int>> mp, poss;\n        for (auto i : lens[l]) {\n            mp[PolyHash(qstr[i]).get_hash()].push_back(i);\n        }\n        for (int p = 0; p + l <= len; p++) {\n            if (mp.count(ha.substr(p, l))) {\n                poss[ha.substr(p, l)].push_back(p);\n            }\n        }\n        for (auto &[h, v] : mp) {\n            auto &pos = poss[h];\n            for (auto i : v) {\n                if (pos.size() >= qk[i]) ans[i] = pos[qk[i] - 1] + 1;\n                else\n                    ans[i] = -1;\n            }\n        }\n    }\n    for (auto x : ans)\n        cout << x << '\\n';\n}æ–¹æ³•äºŒï¼šACè‡ªåŠ¨æœºå…ˆå°†æ‰€æœ‰æ¨¡å¼ä¸²åŠ å…¥ACè‡ªåŠ¨æœºï¼Œç„¶åå†åŒ¹é…æ–‡æœ¬ä¸²ã€‚æ³¨æ„ACè‡ªåŠ¨æœºä¸­è¦ç»´æŠ¤output linkï¼ˆæ²¿fail linkè·³è½¬æ—¶ç¬¬ä¸€ä¸ªæ¨¡å¼ä¸²ï¼‰ã€‚æ—¶é—´å¤æ‚åº¦ã€‚#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct AhoCorasick {\n    enum { alpha = 26, first = 'a' }; // change this!\n    struct Node {\n        // (nmatches is optional)\n        int back, end = -1, nmatches = 0, output = -1;\n        array<int, alpha> next;\n        Node(int v = -1) { fill(next.begin(), next.end(), v); }\n    };\n    vector<Node> N;\n\n    AhoCorasick() : N(1) {}\n\n    void insert(string &s, int j) { // j: id of string s\n        assert(!s.empty());\n        int n = 0;\n        for (char c : s) {\n            int &m = N[n].next[c - first];\n            if (m == -1) {\n                n = m = (int)N.size();\n                N.emplace_back();\n            } else\n                n = m;\n        }\n        N[n].end = j;\n        N[n].nmatches++;\n    }\n\n    void build() {\n        N[0].back = (int)N.size();\n        N.emplace_back(0);\n\n        queue<int> q;\n        q.push(0);\n        while (!q.empty()) {\n            int n = q.front();\n            q.pop();\n            for (int i = 0; i < alpha; i++) {\n                int pnx = N[N[n].back].next[i];\n                auto &nxt = N[N[n].next[i]];\n                if (N[n].next[i] == -1) N[n].next[i] = pnx;\n                else {\n                    nxt.back = pnx;\n                    nxt.output = N[pnx].end == -1 ? N[pnx].output : pnx;\n                    q.push(N[n].next[i]);\n                }\n            }\n        }\n    }\n\n    vector<vector<int>> find(const string &text) {\n        int n = 0;\n        vector<vector<int>> res(text.size()); // ll count = 0;\n        for (int i = 0; i < (int)text.size(); i++) {\n            n = N[n].next[text[i] - first];\n            if (N[n].end != -1) {\n                res[i].push_back(N[n].end);\n            }\n            for (int ind = N[n].output; ind != -1; ind = N[ind].output) {\n                res[i].push_back(N[ind].end);\n            }\n        }\n        return res;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin >> s;\n    AhoCorasick ac;\n    int q;\n    cin >> q;\n    unordered_map<string, int> mp;\n    vector<string> qstr(q);\n    vector<int> qk(q), ans(q);\n    vector<vector<int>> same(q);\n    for (int i = 0; i < q; i++) {\n        cin >> qstr[i] >> qk[i];\n        if (!mp.count(qstr[i])) {\n            mp[qstr[i]] = mp.size();\n            ac.insert(qstr[i], mp.size() - 1);\n        }\n        same[mp[qstr[i]]].push_back(i);\n    }\n    ac.build();\n    auto v = ac.find(s);\n    vector<vector<int>> pos(mp.size());\n    for (int i = 0; i < (int)v.size(); i++) {\n        for (auto p : v[i]) {\n            pos[p].push_back(i);\n        }\n    }\n    for (int i = 0; i < (int)mp.size(); i++) {\n        for (auto qi : same[i]) {\n            if (pos[i].size() >= qk[qi]) {\n                ans[qi] = pos[i][qk[qi] - 1] - qstr[qi].size() + 2;\n            } else {\n                ans[qi] = -1;\n            }\n        }\n    }\n    for (auto x : ans)\n        cout << x << '\\n';\n}æ–¹æ³•ä¸‰ï¼šåç¼€æ•°æ®ç»“æ„åç¼€æ•°æ®ç»“æ„ä¹Ÿèƒ½æ˜¯å¾ˆæ“…é•¿å­—ç¬¦ä¸²åŒ¹é…çš„ï¼Œåç¼€æ ‘å’Œåç¼€è‡ªåŠ¨æœºéƒ½å¯ä»¥è§£å†³æœ¬é¢˜ï¼Œç”±äºæ²¡å­¦è¿‡åç¼€æ ‘å°±åªå†™åç¼€è‡ªåŠ¨æœºçš„åšæ³•äº†ï¼šè‹±æ–‡åŸæ–‡ä¸­æ–‡ç¿»è¯‘æ³¨æ„åç¼€è‡ªåŠ¨æœºæ˜¯è¿™ä¸‰ç§åšæ³•ä¸­å”¯ä¸€å¯ä»¥åœ¨çº¿å¤„ç†è¯¢é—®çš„åšæ³•ï¼Œå¤„ç†å•æ¬¡è¯¢é—®çš„æ—¶é—´å¤æ‚åº¦ä¸ºï¼Œoccurrenceä¸ºå‡ºç°æ¬¡æ•°ã€‚æ•´ä½“æ—¶é—´å¤æ‚åº¦ã€‚#include <bits/extc++.h>\nusing namespace std;\n\nstruct SAM {\n    struct state {\n        int len = 0, link = -1;\n        unordered_map<char, int> next;\n        bool is_clone;\n        int first_pos;\n        vector<int> inv_link;\n    };\n\n    int last = 0; // the index of the equivalence class of\n                  // the whole string\n    vector<state> st;\n\n    void extend(char c) {\n        int cur = (int)st.size();\n        st.emplace_back();\n        st[cur].len = st[last].len + 1;\n        st[cur].first_pos = st[cur].len - 1;\n\n        int p = last;\n        while (p != -1 && !st[p].next.count(c)) {\n            st[p].next[c] = cur;\n            p = st[p].link;\n        }\n        if (p == -1) st[cur].link = 0;\n        else {\n            int q = st[p].next[c];\n            if (st[p].len + 1 == st[q].len) {\n                st[cur].link = q;\n            } else {\n                int clone = (int)st.size();\n                st.push_back(st[q]);\n                st[clone].len = st[p].len + 1;\n                st[clone].is_clone = true;\n                while (p != -1 && st[p].next[c] == q) {\n                    st[p].next[c] = clone;\n                    p = st[p].link;\n                }\n                st[q].link = st[cur].link = clone;\n            }\n        }\n        last = cur;\n    }\n\n    SAM() { st.emplace_back(); }\n\n    SAM(const string &s) : SAM() {\n        for (auto c : s)\n            extend(c);\n        for (int v = 1; v < (int)st.size(); v++) {\n            st[st[v].link].inv_link.push_back(v);\n        }\n    }\n    vector<int> get_all_occur(const string &s) {\n        vector<int> pos;\n        int cur = 0;\n        for (auto c : s) {\n            if (!st[cur].next.count(c)) return pos;\n            cur = st[cur].next[c];\n        }\n        auto dfs = [&](auto &slf, int v) -> void {\n            if (!st[v].is_clone)\n                pos.push_back(st[v].first_pos - s.size() + 1);\n            for (int u : st[v].inv_link)\n                slf(slf, u);\n        };\n        dfs(dfs, cur);\n        return pos;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin >> s;\n    SAM sam(s);\n    int q;\n    cin >> q;\n    unordered_map<string, vector<int>> mp;\n    vector<string> qstr(q);\n    vector<int> qk(q), ans(q);\n    for (int i = 0; i < q; i++) {\n        cin >> qstr[i] >> qk[i];\n        mp[qstr[i]].push_back(i);\n    }\n    for (auto &[str, idxs] : mp) {\n        auto pos = sam.get_all_occur(str);\n        sort(pos.begin(), pos.end());\n        for (auto i : idxs) {\n            if (pos.size() >= qk[i]) ans[i] = pos[qk[i] - 1] + 1;\n            else\n                ans[i] = -1;\n        }\n    }\n    for (auto x : ans)\n        cout << x << '\\n';\n    return 0;\n}æ€»ç»“ä¸‰ç§åšæ³•å„æœ‰å„çš„ä¼˜ç¼ºç‚¹ï¼Œå°±æœ¬é¢˜æ¥çœ‹ä¸‰ç§åšæ³•çš„æ—¶é—´å¤æ‚åº¦ç›¸åŒï¼Œæ—¶é—´å¦‚ä¸‹ï¼šACè‡ªåŠ¨æœº 2.55ç§’ ï¼ˆä½†æˆ‘æœ‰ä¸€ç§å¾ˆæ„šè ¢çš„å†™æ³•ç«Ÿç„¶åªè¦1.32ç§’ï¼‰å“ˆå¸Œ 3.41ç§’åç¼€è‡ªåŠ¨æœº 4.83ç§’ (å¯èƒ½å› ä¸ºåç¼€è‡ªåŠ¨æœºæœ¬èº«å¸¸æ•°æ¯”è¾ƒå¤§)"},{"id":"nginx-proxy-manager","title":"Nginx Proxy Manager","content":"Nginx Proxy Manager(ä»¥ä¸‹ç®€ç§°NPM)å¯ä»¥å®ç°åå‘ä»£ç†ï¼ˆreverse proxyï¼‰ï¼Œå³åªæš´éœ²80å’Œ443ç«¯å£ç„¶åç”±ä»£ç†æ ¹æ®åŸŸåå°†è¯·æ±‚å‘é€ç»™å¯¹åº”çš„æœåŠ¡ã€‚NPMé›†æˆäº†Let's Encryptæ‰€ä»¥å¯ä»¥å¾ˆç®€å•çš„ç”³è¯·åˆ°SSLè¯ä¹¦ã€‚å®‰è£…ä½¿ç”¨dock-composeï¼Œæ ¹æ®æƒ…å†µä¿®æ”¹è·¯å¾„ï¼ˆå°¤å…¶æ˜¯å¦‚æœä½ ç”¨portainerçš„è¯ï¼‰version: '3'\nservices:\n  app:\n    image: 'jc21/nginx-proxy-manager:latest'\n    restart: unless-stopped\n    ports:\n      - '80:80'\n      - '81:81'\n      - '443:443'\n    volumes:\n      - ./data:/data\n      - ./letsencrypt:/etc/letsencryptWeb UIåœ¨81ç«¯å£ï¼Œåˆå§‹è´¦å·é‚®ç®±ï¼šadmin@example.com å¯†ç ï¼šchangemeç”³è¯·é€šé…ç¬¦SSLè¯ä¹¦SSL Certificates -> Add SSL Certificate -> Let's EncryptDomain names:  (æ¢æˆä½ çš„åŸŸåï¼‰æ‰“å¼€Use a DNS Challengeï¼Œé€‰æ‹©ä½ çš„æä¾›å•†ï¼ŒCredentials File Contentçš„å¡«å†™å¯ä»¥å‚ç…§ç”³è¯·é€šé…SSLè¯ä¹¦ã€‚æ·»åŠ é…ç½®Hosts -> Proxy Hosts -> Add Proxy HostDomain Namesæ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚Forward Hostname / IP å¡«æœåŠ¡å™¨çš„å†…ç½‘IPï¼Œä¸è¦å¡«127.0.0.1å› ä¸ºä¼šè®¿é—®åˆ°NPMå®¹å™¨å†…ç½‘ç»œForward Portï¼šå¯¹åº”åº”ç”¨çš„ç«¯å£ï¼Œå¦‚æœæœ‰é˜²ç«å¢™è¯·ç¡®ä¿ç«¯å£æ˜¯æ‰“å¼€çš„ï¼Œå¦‚æœä¸æƒ³åŠ¨é˜²ç«å¢™è®¾ç½®è¯·çœ‹Tipså»ºè®®æ‰“å¼€Cache Assetså’ŒBlock Common ExploitsSSLè¯ä¹¦é‡Œé€‰å‰é¢ç”³è¯·åˆ°çš„è¯ä¹¦æ‰“å¼€Force SSL, HTTP/2 Support, HSTS Enabledã€‚Tipsåˆ©ç”¨dockerç½‘ç»œåœ¨docker-composeæ–‡ä»¶æœ€ååŠ ä¸Šnetworks:\n  default:\n    external:\n      name: nginx-proxy-manager_defaultè®©åº”ç”¨åŠ å…¥NPMçš„ç½‘ç»œï¼Œè¿™æ ·å°±ç›¸å½“äºè®©NPMå’Œå®¹å™¨å¤„äºåŒä¸€ä¸ªdockerç½‘ç»œï¼Œäºæ˜¯å°±é¿å…äº†å‰é¢æ‰€è¯´çš„é˜²ç«å¢™çš„é—®é¢˜ã€‚è¿™æ ·çš„è¯æ·»åŠ é…ç½®æ—¶hostè¦å¡«åº”ç”¨çš„åå­—ï¼ˆä¸æ˜¯å¾ˆç¡®å®šï¼Œä¹Ÿå¯èƒ½æ˜¯seviceçš„åå­—ï¼Œä¸è¿‡ä¸€èˆ¬æƒ…å†µä¸¤ä¸ªåå­—æ˜¯ä¸€æ ·çš„ï¼Œæ¯”å¦‚nextcloud)ï¼Œç«¯å£è¦å¡«å†…éƒ¨ç«¯å£ï¼Œæ¯”å¦‚ä¸€ä¸ªåº”ç”¨çš„ç«¯å£æ˜ å°„æ˜¯90:8080é‚£ä¹ˆä½ åº”è¯¥å¡«8080.å‚è€ƒèµ„æ–™https://nginxproxymanager.com/"},{"id":"nowcoder-Agnej","title":"2023ç‰›å®¢å¤šæ ¡10 D - Agnej é¢˜è§£","content":"è€ƒè™‘æ¯ä¸€å±‚çš„ SG å‡½æ•°ï¼Œæœ€ç»ˆç»“æœç”±æ¯ä¸€å±‚çš„ SG å‡½æ•°çš„å¼‚æˆ–å’Œå†³å®šã€‚å¦‚æœ  ä¸ºå¶æ•°ï¼Œè®¾å·¦å³å„æœ‰  ä¸ªç§¯æœ¨ï¼Œæ˜¾ç„¶ ã€‚å¦‚æœ  ä¸ºå¥‡æ•°ï¼Œè®¾æœ€ä¸­é—´çš„ä½ç½®å·¦å³å„æœ‰  ä¸ªç§¯æœ¨ï¼ŒSG å‡½æ•°è®°ä½œ ï¼šå¦‚æœæœ€ä¸­é—´æ²¡æœ‰ç§¯æœ¨ï¼šç­‰ä»·äº  ä¸ºå¶æ•°çš„æƒ…å†µå¦åˆ™ï¼Œå¦‚æœ  æˆ– ï¼Œåªèƒ½ä»ä¸€è¾¹å–ï¼Œå¦åˆ™ï¼Œå¦‚æœ  æˆ– ï¼Œä¸å¦¨è®°ä½œ ï¼Œæˆ‘ä»¬å¯ä»¥åˆ°è¾¾  ä¸‰ç§çŠ¶æ€ã€‚æ³¨æ„åˆ°  å’Œ  çš„ SG å‡½æ•°å¿…ç„¶ä¸€ä¸ªä¸º  ä¸€ä¸ªä¸º ã€‚ä½†  çš„ SG å‡½æ•°ä¸å®¹æ˜“çœ‹å‡ºè§„å¾‹ï¼Œæˆ‘ä»¬è§‚å¯Ÿä¸€ä¸‹  æ¯”è¾ƒå°çš„æƒ…å†µï¼šï¼Œå¯ä»¥å‘ç° å¦åˆ™ï¼Œè§‚å¯Ÿåˆ° ï¼Œé€šè¿‡æ•°å­¦å½’çº³æ³•å¯ä»¥æ¨å‡º #include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        int mid = 0, l = 0, r = 0;\n        if (m % 2) {\n            mid = s[m / 2] - '0';\n        }\n\n        for (int j = 0; j < m / 2; j++) {\n            l += s[j] - '0';\n        }\n\n        for (int j = (m + 1) / 2; j < m; j++) {\n            r += s[j] - '0';\n        }\n\n        int sg = 0;\n        if (mid == 0) {\n            sg = (l + r) % 2;\n        } else {\n            if (l == 0 || r == 0) {\n                sg = (l + r) % 2;\n            } else if (l == 1 || r == 1) {\n                sg = 2 + (l + r) % 2;\n            } else {\n                sg = (l + r + 1) % 2;\n            }\n        }\n\n        ans ^= sg;\n    }\n\n    cout << (ans ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}"},{"id":"nvim-plugins-for-no-lsp","title":"æ–¹ä¾¿æ—  Language Server å¼€å‘çš„ Neovim æ’ä»¶","content":"æœ€è¿‘å®ä¹ å·¥ä½œå¼€å§‹å†™C/C++äº†ï¼Œç”±äºé¡¹ç›®ç»“æ„è¿‡äºå¤æ‚å¯¼è‡´ VSCode çš„ language server å‡ ä¹æ˜¯ä¸å¯ç”¨çš„çŠ¶æ€ï¼Œæ‰€ä»¥å¿ƒæƒ³ä¸å¦‚æ¢å›æœ€é¡ºæ‰‹çš„ neovimï¼Œä½†ä»æ¥æ²¡æœ‰ç”¨ neovim åšè¿‡å¤§é¡¹ç›®ï¼Œæ‰€ä»¥è¦ç ”ç©¶å¦‚ä½•å®ç°æˆ‘åœ¨ VSCode é‡Œå¸¸ç”¨çš„ä¸€äº›åŠŸèƒ½ï¼šæœç´¢è¿™é‡Œç”¨çš„æ˜¯ nvim-spectreï¼Œç”¨èµ·æ¥å’Œ VSCode å·®ä¸å¤šï¼Œé»˜è®¤æœç´¢ç”¨çš„æ˜¯ripgrepæ‰€ä»¥é€Ÿåº¦å¾ˆå¿«ï¼Œç›®å‰åœ¨ç”¨çš„å¿«æ·é”®ï¼šlocal map = vim.keymap.set -- ä¹‹åä¸å†é‡å¤\n\nmap('n', '<leader>S', require('spectre').open)\nmap('n', '<leader>fw', function() require('spectre').open_visual({select_word=true}) end) -- æŸ¥æ‰¾å‡½æ•°å®šä¹‰æˆ–å¼•ç”¨å¾ˆæœ‰ç”¨æ–‡ä»¶ç›¸å…³VSCode é‡Œ(Windows)/(MacOS) å¯ä»¥å‘¼å‡ºæ–‡ä»¶è·³è½¬ï¼Œåœ¨ Neovim é‡Œå¯ä»¥ç”¨ telescope çš„ find_files picker å®ç°ï¼Œå”¯ä¸€ç¾ä¸­ä¸è¶³å°±æ˜¯ä¸ä¼šä¼˜å…ˆæ˜¾ç¤ºæœ€è¿‘æ‰“å¼€çš„æ–‡ä»¶ä¸”æ²¡æœ‰ç¼“å­˜æ‰€ä»¥åŠ è½½ä¼šç¨æ…¢ä¸€ç‚¹ç‚¹ã€‚map('n', '<Leader>ff', require\"telescope.builtin\".find_files)å¸¸ç”¨æ–‡ä»¶è·³è½¬å¯ä»¥ç”¨harpoonmap('n', '<Leader>fm', require(\"harpoon.ui\").toggle_quick_menu)\nmap('n', '<Leader>ma', require(\"harpoon.mark\").add_file)å¤§çº²/Symbolä¹‹å‰ç”¨çš„ symbols-outline.nvim ä½†å¯æƒœä¸æ”¯æŒ treesitterï¼Œç„¶åå‘ç°äº†æ›´å¥½ç”¨çš„ aerialï¼šä¸ä»…æ”¯æŒ treesitter è¿˜æœ‰lualineæ‰©å±•ï¼ˆæ˜¾ç¤ºå½“å‰å‡½æ•°ï¼‰ï¼Œtelescope pickerï¼ˆæ¯”telescopeè‡ªå¸¦çš„symbol pickerï¼‰å¥½ç”¨ã€‚require('telescope').load_extension('aerial')\n\nmap('n', '<Leader>s', require'telescope'.extensions.aerial.aerial)ç»ˆç«¯ç”¨nvim-toggleterm.luaç®¡ç†ç»ˆç«¯ï¼Œä¸€ä¸ªå¾ˆå¥½ç”¨çš„åŠŸèƒ½æ˜¯è‡ªå®šä¹‰ç»ˆç«¯ï¼Œæ¯”å¦‚å®šä¹‰ä¸€ä¸ªé»˜è®¤æ‰“å¼€lazygitçš„ç»ˆç«¯ï¼šlocal Terminal  = require('toggleterm.terminal').Terminal\nlocal lazygit = Terminal:new({\n    cmd = \"lazygit\",\n    hidden = true,\n    direction = 'float',\n    float_opts = {\n        border = 'double'\n    }\n})\nmap('n', '<Leader>g', function() lazygit:toggle() end)"},{"id":"palindrome-partition","title":"ä¸€ä¸ªå…³äºå°†å­—ç¬¦ä¸²åˆ’åˆ†ä¸ºç¬¦åˆæ¡ä»¶çš„å›æ–‡å­ä¸²çš„ç»“è®º","content":"å¦‚æœé‡åˆ°äº†å…³äºå°†å­—ç¬¦ä¸²åˆ’åˆ†ä¸ºç¬¦åˆæ¡ä»¶çš„å›æ–‡ï¼ˆæ¯”å¦‚é•¿åº¦ä¸ºå¶æ•°çš„å›æ–‡ï¼‰å­ä¸²ï¼Œæœ‰å¯èƒ½ä¼šç”¨åˆ°è¿™ä¸ªå®šç†ï¼šå¦‚æœå­—ç¬¦ä¸²å¯ä»¥è¢«åˆ’åˆ†çš„è¯ï¼Œå®ƒçš„æœ€å¤§åˆ’åˆ†æ˜¯å”¯ä¸€çš„ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡ä»å·¦å¾€å³è´ªå¿ƒåœ°é€‰æ‹©æœ€çŸ­çš„å›æ–‡å­ä¸²æ¥å¾—åˆ°æœ€å¤§åˆ’åˆ†ã€‚è¿™é‡Œçš„â€œæœ€å¤§â€æŒ‡åˆ’åˆ†ä¸ºå›æ–‡å­ä¸²çš„ä¸ªæ•°ã€‚ç¬¬ä¸€æ¬¡æ¥è§¦åˆ°è¿™ä¸ªç»“è®ºæ˜¯åœ¨ Codeforces 1827C çš„é¢˜è§£ä¸­ï¼Œåé¢ä¼šé™„ä¸Šé¢˜è§£é‡Œè¯æ˜çš„ç¿»è¯‘ã€‚æœ€è¿‘åˆåœ¨23å¹´ç‰›å®¢å¤šæ ¡ç¬¬äºŒåœºçš„Gé¢˜é‡åˆ°äº†è¿™ä¸ªç»“è®ºã€‚åé¢ä¼šç®€å•åœ°è®¨è®ºè¿™ä¸¤ä¸ªé¢˜ã€‚è¯æ˜å‡è®¾å­—ç¬¦ä¸²  å½“å‰æœ‰ä¸€ä¸ªåˆ’åˆ†çš„ç¬¬ä¸€éƒ¨åˆ†æ˜¯ ï¼Œ æ˜¯æœ€çŸ­çš„å‰ç¼€å›æ–‡å­ä¸²ã€‚æˆ‘ä»¬è¦è¯æ˜å¦‚æœ ï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ å‡ºå­ä¸²æ•°é‡æ›´å¤šçš„åˆ’åˆ†ã€‚è€ƒè™‘ä¸¤ç§æƒ…å†µï¼šï¼šå¾ˆæ˜æ˜¾  éƒ½æ˜¯å›æ–‡å­ä¸²ï¼Œæˆ‘ä»¬å¯ä»¥å°†  æ›¿æ¢æˆå®ƒä»¬ã€‚ï¼š æ˜¯å›æ–‡å­ä¸²ï¼ˆå› ä¸ºå…³äºé‡å¿ƒå¯¹ç§°ï¼‰ï¼Œå…¶åœ¨  ä¸­çš„å¯¹ç§°éƒ¨åˆ†ä¸º ï¼Œæ‰€ä»¥  ä¹Ÿæ˜¯å›æ–‡å­ä¸²ï¼Œä¸æˆ‘ä»¬çš„å‡è®¾çŸ›ç›¾ï¼Œæ‰€ä»¥ä¸ä¼šå‡ºç°è¿™ç§æƒ…å†µã€‚å¦‚ä½•è¿ç”¨å¯¹äº Codeforces çš„é‚£ä¸ªé¢˜ï¼Œæˆ‘ä»¬å¯¹äºæ¯ä¸ªä½ç½®æ‰¾åˆ°æœ€çŸ­åœ¨æ­¤ç»“æŸçš„å›æ–‡å­ä¸²ï¼Œç„¶åè¿›è¡ŒçŠ¶æ€è½¬ç§»ã€‚å¯¹äºç‰›å®¢é‚£ä¸ªé¢˜ï¼ˆä»¥åŠä¸€èˆ¬çš„åˆ¤æ–­èƒ½å¦åˆ’åˆ†çš„é—®é¢˜ï¼‰ï¼Œæˆ‘ä»¬ç»´æŠ¤æœ€é•¿çš„å¯ä»¥è¢«åˆ’åˆ†çš„å‰ç¼€ï¼Œå¦‚æœä»¥å½“å‰ä½ç½®ä¸ºä¸­å¿ƒçš„å›æ–‡å­ä¸²å¯ä»¥æ‰©å±•è¯¥å‰ç¼€ï¼Œæˆ‘ä»¬å°±æ‰©å±•è¯¥å‰ç¼€ã€‚è¿™æœ¬è´¨å°±æ˜¯è´ªå¿ƒåœ°é€‰æ‹©æœ€çŸ­çš„å›æ–‡å­ä¸²ã€‚"},{"id":"paperless-ngx","title":"Paperless-ngx","content":"ä½¿ç”¨linuxserver.ioçš„é•œåƒæ„Ÿè§‰æ¯”å®˜æ–¹é•œåƒåšçš„å¥½ä¸€äº›ï¼Œå› ä¸ºç”¨å®˜æ–¹çš„é•œåƒä¸€ç›´æŠ¥é”™ã€‚ã€‚ã€‚GitHubä»“åº“æˆ‘ä¿®æ”¹åçš„docker-composeæ–‡ä»¶ï¼š---\nversion: \"2.1\"\nservices:\n  paperless-ngx:\n    image: lscr.io/linuxserver/paperless-ngx\n    container_name: paperless-ngx\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=America/Toronto\n      - REDIS_URL= #optional\n      - PAPERLESS_URL= #å¦‚æœä½ è¦é€šè¿‡äº’è”ç½‘è®¿é—®çš„è¯ï¼Œè®¾ç½®è¿™ä¸ªç¯å¢ƒå˜é‡ä¸ºä½ çš„URL\n      - PAPERLESS_OCR_LANGUAGES=chi-sim # è²Œä¼¼æ²¡ä½œç”¨\n      - PAPERLESS_OCR_LANGUAGE=eng+chi_sim\n\n    volumes:\n      - config:/config\n      - data:/data\n    ports:\n      - 8010:8000\n    restart: unless-stopped\nvolumes:\n  data:\n  config:\nnetworks:\n  default:\n    external:\n      name: nginx-proxy-manager_defaulté»˜è®¤ç”¨æˆ·åå’Œå¯†ç éƒ½æ˜¯ã€‚å·²çŸ¥bugå®˜æ–¹é•œåƒç¼ºå¯¼è‡´æ–‡ä»¶ä¸Šä¼ åæ— æ³•è¢«å¤„ç†ï¼Œç›®å‰GitHubä¸Šçš„å·²ç»ä¿®å¤ä½†é•œåƒè¿˜æ²¡æ›´æ–°ï¼Œå¯ä»¥è‡ªå·±æœ¬åœ°æ„å»ºã€‚ç¯å¢ƒå˜é‡ä¼¼ä¹æ²¡ç”¨ï¼Œå¹¶ä¸ä¼šè‡ªåŠ¨å®‰è£…å¯¹åº”çš„ocråŒ…ï¼Œéœ€è¦è‡ªå·±æ·»åŠ åˆ°ä¸­ï¼Œç„¶åè‡ªå·±æ„å»ºã€‚ä½¿ç”¨å®˜æ–¹é•œåƒå®˜æ–¹docker-composeæ–‡ä»¶åˆ›å»ºé»˜è®¤è¶…çº§ç”¨æˆ·:ä¸Šé¢çš„docker-composeæ–‡ä»¶é‡Œæœ‰ä½†æˆ‘è¿˜æ˜¯è¦å†™ä¸€ä¸‹æé†’è‡ªå·±ã€‚æ‰“å¼€å®¹å™¨åˆ—è¡¨ï¼Œé€‰æ‹©paperless_webserver_1ç‚¹'Console'ç„¶å'Connect'æ¥æ‰“å¼€å‘½ä»¤è¡Œè¿è¡Œä»¥åˆ›å»ºç”¨æˆ·"},{"id":"parallel_bsearch","title":"æ•´ä½“äºŒåˆ†å­¦ä¹ ç¬”è®°","content":"æ•´ä½“äºŒåˆ†åœ¨å›½å¤–ç§°ä¸º parallel binary searchï¼Œæ˜¯ä¸€ç§ç”¨äºè§£å†³å¤šä¸ªäºŒåˆ†æœç´¢çš„ç¦»çº¿ç®—æ³•ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯å°†ä¸€ä¸ªçŠ¶æ€ç”¨äºå¤šä¸ªè¯¢é—®ä¸­ã€‚é€‚ç”¨çš„é—®é¢˜/æ ¸å¿ƒæ€æƒ³ä¸€èˆ¬çš„äºŒåˆ†å¥—è·¯ä¸ºï¼šäºŒåˆ†ä¸€ä¸ªâ€œæŒ‡æ ‡â€ï¼Œå¯¹äºå½“å‰è¦æ£€æŸ¥çš„æŒ‡æ ‡ï¼Œåº”ç”¨æ‰€æœ‰ç¬¦åˆæŒ‡æ ‡çš„æ“ä½œï¼Œæ¯ä¸ªæ“ä½œä¼šäº§ç”Ÿä¸€äº›è´¡çŒ®ï¼Œæœ€ååˆ¤æ–­è´¡çŒ®æ˜¯å¦ç¬¦åˆæ¡ä»¶ã€‚å¦‚æœæˆ‘ä»¬è¦å¤„ç†å¾ˆå¤šä¸ªäºŒåˆ†é—®é¢˜è€Œä¸”åº”ç”¨æ“ä½œçš„æ—¶é—´å¼€é”€å¾ˆå¤§ï¼Œæ¯ä¸€ä¸ªäºŒåˆ†é—®é¢˜å•ç‹¬è®¡ç®—å°±ä¼šå¾ˆæ…¢ã€‚ä½†ç»å¸¸åº”ç”¨å®Œæ“ä½œåçš„çŠ¶æ€å¯ä»¥ç”¨äºå¤šä¸ªäºŒåˆ†é—®é¢˜çš„æ¡ä»¶æ£€æŸ¥ï¼Œè¿™å°±æ˜¯æ•´ä½“äºŒåˆ†çš„æ ¸å¿ƒæ€æƒ³ã€‚æ€è·¯å¯¹äºå¦‚ä½•é‡å¤åˆ©ç”¨æ“ä½œä¹‹åçš„çŠ¶æ€ï¼Œä¸€èˆ¬æœ‰ä¸¤ç§æ€è·¯ï¼šä¸€ç§æœ€å¸¸è§çš„æ€è·¯æ˜¯æ ¹æ®å½“å‰äºŒåˆ†çš„æŒ‡æ ‡ä»å°åˆ°å¤§è¿›è¡Œæ£€æŸ¥ï¼Œè¿™æ ·å¯ä»¥åœ¨ä¹‹å‰æ“ä½œä¹‹åçŠ¶æ€ä¸Šç»§ç»­åº”ç”¨æ–°çš„æ“ä½œç„¶åå†è¿›è¡Œæ£€æŸ¥ã€‚å¦‚æœå› ä¸ºä¸€äº›å› ç´ ä½¿å¾—æ— æ³•åº”ç”¨ç¬¬ä¸€ç§æ€è·¯ï¼Œä½†æ“ä½œçš„è´¡çŒ®æ»¡è¶³å¯åŠ æ€§çš„è¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è€ƒè™‘ç¬¬äºŒç§æ€è·¯ï¼šè®°å½•ä¸‹å½“å‰çš„çŠ¶æ€çš„è´¡çŒ®ï¼Œè¿™æ ·ä¸‹ä¸€è½®äºŒåˆ†çš„æ—¶å€™æˆ‘ä»¬å¯ä»¥åœ¨è®°å½•ä¸‹çš„è´¡çŒ®ä¸ŠåŠ ä¸Šæ–°çš„è´¡çŒ®ã€‚è¿™æ ·è¯´å¯èƒ½æœ‰ç‚¹æŠ½è±¡ï¼Œä¸‹é¢æˆ‘ä»¬ç»“åˆä¸€ä¸ªä¾‹å­æ¥è¯´æ˜å…·ä½“çš„å®ç°æ˜¯æ€æ ·çš„ã€‚ä¾‹é¢˜é™æ€æ•°ç»„åŒºé—´ç¬¬kå°é¢˜ç›®é“¾æ¥è¿™ä¸ªé¢˜äºŒåˆ†çš„æŒ‡æ ‡å°±æ˜¯ç¬¬ k å¤§çš„å¤§å°ï¼Œå³æˆ‘ä»¬è¦æ£€æŸ¥ï¼šè¿™ä¸ªåŒºé—´  çš„ç¬¬ k å¤§æ˜¯å¦è‡³å°‘ä¸º ï¼Œè¿™å¯ä»¥é€šè¿‡åˆ¤æ–­  å†…å°äºç­‰äº  çš„å…ƒç´ çš„ä¸ªæ•°æ¥å®ç°ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªæƒå€¼æ•°ç»„  è®°å½•æ‰€æœ‰æ‰€æœ‰å°äºç­‰äº  çš„ä½ç½®ï¼Œå³ ï¼Œé‚£ä¹ˆç¬¦åˆæŒ‡æ ‡çš„æ“ä½œå°±æ˜¯å°†æƒå€¼æ•°ç»„ä¸­çš„æŸä¸ªä½ç½®åŠ ä¸€ã€‚æ˜¾ç„¶å¯¹äºå¤§çš„æŒ‡æ ‡æˆ‘ä»¬å¯ä»¥åœ¨å°æŒ‡æ ‡æ“ä½œçš„åŸºç¡€ä¸ŠåŠ å…¥æ–°çš„æ“ä½œï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åº”ç”¨ç¬¬ä¸€ç§æ€è·¯ã€‚å¯¹äºç¬¬ä¸€ç§æ€è·¯ï¼Œä¸€ç§æ¯”è¾ƒç®€å•çš„å†™æ³•æ˜¯ç”¨ä¸¤ä¸ªæ•°ç»„  è®°å½•å½“å‰æ¯ä¸ªè¯¢é—®çš„ç­”æ¡ˆæ‰€å¤„çš„èŒƒå›´ï¼Œåœ¨æ¯ä¸€è½®äºŒåˆ†ä¸­æ ¹æ®  ä»å°åˆ°å¤§éå†æ¯ä¸ªè¯¢é—®// æ ‘çŠ¶æ•°ç»„ä»£ç çœç•¥å·²çœç•¥ï¼Œè§ https://github.com/thallium/acm-algorithm-template/blob/master/src/data_structure/fenwick.hpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> a(n);\n    for (auto &x : a)\n        cin >> x;\n\n    vector<int> compress{a};\n    sort(begin(compress), end(compress));\n    compress.erase(unique(begin(compress), end(compress)), end(compress));\n    const int N = (int)size(compress);\n\n    vector<vector<int>> pos(N);\n    for (int i = 0; i < n; i++) {\n        int idx = int(lower_bound(begin(compress), end(compress), a[i]) - begin(compress));\n        pos[idx].push_back(i);\n    }\n\n    vector<array<int, 3>> query(m);\n    for (auto &[l, r, k] : query) {\n        cin >> l >> r >> k;\n        l--;\n    }\n\n    vector<int> l(m, 0), r(m, N - 1);\n    while (true) {\n        vector<vector<int>> s(N);\n        int empty = 1;\n        for (int i = 0; i < m; i++) {\n            if (l[i] <= r[i]) {\n                int mid = (l[i] + r[i]) / 2;\n                s[mid].push_back(i);\n                empty = 0;\n            }\n        }\n\n        if (empty) {\n            break;\n        }\n\n        Fenwick<int> tr(n);\n        for (int i = 0; i < N; i++) {\n            for (auto j : pos[i]) {\n                tr.add(j, 1);\n            }\n\n            for (auto j : s[i]) {\n                auto [ql, qr, k] = query[j];\n                if (tr.get(ql, qr) >= k) {\n                    r[j] = i - 1;\n                } else {\n                    l[j] = i + 1;\n                }\n            }\n        }\n    }\n\n    for (auto i : l) {\n        cout << compress[i] << '\\n';\n    }\n    return 0;\n}æˆ‘ä»¬å†æ¬¡ä¹Ÿå°†ä»‹ç»ç¬¬äºŒç§æ€è·¯çš„å†™æ³•ï¼Œè¿™æ ·æœ‰åŠ©äºç†è§£ä¸‹é¢åŠ¨æ€åŒºé—´ç¬¬ k å°çš„åšæ³•ã€‚å‡è®¾ä¸€ä¸ªè¯¢é—®çš„ç­”æ¡ˆåœ¨  ä¸­ï¼ŒæŒ‡æ ‡ä¸º ï¼Œè¯¢é—®çš„åŒºé—´ä¸­æœ‰  ä¸ªå°äºç­‰äº  çš„æ•°ï¼Œ å³ä¸ºå½“å‰æ‰€æœ‰æ“ä½œçš„æ€»è´¡çŒ®ï¼Œå¦‚æœ ï¼Œè¯´æ˜ç­”æ¡ˆåœ¨  ä¸­ã€‚å¦‚æœæˆ‘ä»¬è®°å½•ä¸‹å½“å‰çš„è´¡çŒ®ï¼Œä¸‹æ¬¡äºŒåˆ†çš„æŒ‡æ ‡ä¸º ï¼Œæˆ‘ä»¬åªè¦çŸ¥é“è¯¢é—®çš„åŒºé—´é‡Œå¤§å°åœ¨  ä¸­çš„å…ƒç´ çš„ä¸ªæ•°ï¼Œå†åŠ ä¸Šä¹‹å‰è®°å½•çš„è´¡çŒ®ï¼Œè¿™æ ·å°±ç›¸å½“äºçŸ¥é“äº†å°äºç­‰äº  çš„å…ƒç´ çš„ä¸ªæ•°ã€‚æ‰€ä»¥è¯´åœ¨ä¸‹ä¸€è½®äºŒåˆ†çš„æ—¶å€™æˆ‘ä»¬åªéœ€è¦å½±å“  ä¸­çš„å…ƒç´ ä¸ªæ•°çš„æ“ä½œï¼Œ çš„æƒ…å†µç±»ä¼¼ã€‚æ‰€ä»¥æˆ‘ä»¬æ¯æ¬¡äºŒåˆ†ä¹‹åè¦å°†æ“ä½œåˆ†æˆå·¦å³ä¸¤ç»„ç»™ä¸‹ä¸€è½®äºŒåˆ†ç”¨ã€‚#include <bits/stdc++.h>\n#include \"data_structure/fenwick.hpp\"\nusing namespace std;\n\nstruct modify {\n    int val, pos;\n};\n\nstruct query {\n    int l, r, k, i;\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> a(n);\n    for (auto &x : a)\n        cin >> x;\n\n    // ç¦»æ•£åŒ–\n    vector<int> compress{a};\n    sort(begin(compress), end(compress));\n    compress.erase(unique(begin(compress), end(compress)), end(compress));\n    const int N = (int)size(compress);\n\n    using op = variant<modify, query>;\n    vector<op> ops; // ä¸ºäº†æ–¹ä¾¿å®ç°æˆ‘ä»¬æŠŠè¯¢é—®å’Œä¿®æ”¹æ”¾åˆ°ä¸€èµ·\n\n    for (int i = 0; i < n; i++) {\n        int val = int(lower_bound(begin(compress), end(compress), a[i]) - begin(compress));\n        ops.push_back(modify{val, i});\n    }\n\n    for (int i = 0; i < m; i++) {\n        int l, r, k;\n        cin >> l >> r >> k;\n        l--;\n        ops.push_back(query{l, r, k, i});\n    }\n\n    vector<int> ans(m);\n\n    Fenwick<int> tr(n);\n    auto solve = [&](auto& slf, int l, int r, vector<op>& ops) -> void {\n        if (l == r) { // äºŒåˆ†ç»“æŸï¼Œç­”æ¡ˆç¡®å®š\n            for (const auto& o : ops) {\n                if (holds_alternative<query>(o)) { // å¦‚æœæ˜¯è¯¢é—®çš„è¯\n                    ans[get<query>(o).i] = compress[l];\n                }\n            }\n            return;\n        }\n\n        int x = (l + r) / 2;\n\n        vector<op> left, right;\n        for (auto o : ops) {\n            if (holds_alternative<query>(o)) { // è¯¢é—®\n                auto& [ql, qr, k, i] = get<query>(o);\n                int c = tr.get(ql, qr); // è´¡çŒ®\n                if (c >= k) { // æ ¹æ®è´¡çŒ®åˆ¤æ–­è¯¢é—®çš„ç­”æ¡ˆè¯¥å¦‚ä½•æ”¹å˜\n                    left.push_back(o);\n                } else {\n                    k -= c; // åœ¨ç›®æ ‡ä¸Šå‡æ‰è´¡çŒ®å’Œè®°å½•è´¡çŒ®æ˜¯ä¸€æ ·çš„\n                    right.push_back(o);\n                }\n            } else { // ä¿®æ”¹\n                auto [val, pos] = get<modify>(o);\n                if (val <= x) {\n                    tr.add(pos, 1);\n                    left.push_back(o);\n                } else {\n                    right.push_back(o);\n                }\n            }\n        }\n\n        for (auto o : left) {\n            if (holds_alternative<modify>(o)) { // è¿˜åŸæ ‘çŠ¶æ•°ç»„åˆ°åˆå§‹çŠ¶æ€\n                tr.add(get<modify>(o).pos, -1);\n            }\n        }\n\n        vector<op>{}.swap(ops); // é‡Šæ”¾ç©ºé—´\n\n        slf(slf, l, x, left);\n        slf(slf, x + 1, r, right);\n    };\n\n    solve(solve, 0, N - 1, ops);\n\n    for (auto x : ans) cout << x << '\\n';\n    return 0;\n}å¯ä»¥çœ‹å‡ºç¬¬ä¸€ç§æ€è·¯çš„å®ç°å¾€å¾€æ¯”è¾ƒå¥½å†™ï¼Œå…¶å®å¤§éƒ¨åˆ†æ•´ä½“äºŒåˆ†çš„é¢˜ç›®éƒ½æ˜¯ç”¨ç¬¬ä¸€ç§æ€è·¯è§£å†³çš„ã€‚åŠ¨æ€åŒºé—´ç¬¬kå°é¢˜ç›®é“¾æ¥å› ä¸ºè¯¢é—®å’Œä¿®æ”¹æœ‰å…ˆåé¡ºåºï¼Œæ‰€ä»¥ä¸èƒ½ç”¨ç¬¬ä¸€ç§æ€è·¯ã€‚å…¶å®å¦‚æœä½ ç†è§£äº†ä¸Šä¸€é¢˜çš„ç¬¬äºŒç§æ€è·¯çš„è¯ï¼Œä¿®æ”¹æ— éå°±æ˜¯æŠŠåŸæ¥çš„æ•°åˆ æ‰ï¼ˆåœ¨è¾…åŠ©æ•°ç»„ä¸­å‡1ï¼‰ï¼Œå†åŠ ä¸Šä¿®æ”¹ä¹‹åçš„æ•°ã€‚#include <bits/stdc++.h>\n#include \"data_structure/fenwick.hpp\"\n\nusing namespace std;\n\nstruct modify {\n    int val, pos, add;\n};\n\nstruct query {\n    int l, r, k, i;\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    using op = variant<modify, query>;\n    vector<op> ops; // ä¸ºäº†æ–¹ä¾¿å®ç°æˆ‘ä»¬æŠŠè¯¢é—®å’Œä¿®æ”¹æ”¾åˆ°ä¸€èµ·\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        ops.push_back(modify{a[i], i, 1});\n    }\n\n    // ç¦»æ•£åŒ–\n    vector<int> comp{a};\n\n    int qcnt = 0;\n    for (int i = 0; i < m; i++) {\n        char ch;\n        cin >> ch;\n        if (ch == 'Q') {\n            int l, r, k;\n            cin >> l >> r >> k;\n            l--;\n            ops.push_back(query{l, r, k, qcnt});\n            qcnt++;\n        } else {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            ops.push_back(modify{a[x], x, -1});\n            comp.push_back(y);\n            a[x] = y;\n            ops.push_back(modify{a[x], x, 1});\n        }\n    }\n\n    sort(begin(comp), end(comp));\n    comp.erase(unique(begin(comp), end(comp)), end(comp));\n    const int N = (int)size(comp);\n\n    for (auto& o : ops) {\n        if (holds_alternative<modify>(o)) {\n            auto& v = get<modify>(o).val;\n            v = int(lower_bound(begin(comp), end(comp), v) -  begin(comp));\n        }\n    }\n\n    vector<int> ans(qcnt);\n\n    Fenwick<int> tr(n);\n    auto solve = [&](auto& slf, int l, int r, vector<op>& ops) -> void {\n        if (l == r) { // äºŒåˆ†ç»“æŸï¼Œç­”æ¡ˆç¡®å®š\n            for (const auto& o : ops) {\n                if (holds_alternative<query>(o)) { // å¦‚æœæ˜¯è¯¢é—®çš„è¯\n                    ans[get<query>(o).i] = comp[l];\n                }\n            }\n            return;\n        }\n\n        int x = (l + r) / 2;\n\n        vector<op> left, right;\n        for (auto o : ops) {\n            if (holds_alternative<query>(o)) { // è¯¢é—®\n                auto& [ql, qr, k, i] = get<query>(o);\n                int c = tr.get(ql, qr); // è´¡çŒ®\n                if (c >= k) { // æ ¹æ®è´¡çŒ®åˆ¤æ–­è¯¢é—®çš„ç­”æ¡ˆè¯¥å¦‚ä½•æ”¹å˜\n                    left.push_back(o);\n                } else {\n                    k -= c; // åœ¨ç›®æ ‡ä¸Šå‡æ‰è´¡çŒ®å’Œè®°å½•è´¡çŒ®æ˜¯ä¸€æ ·çš„\n                    right.push_back(o);\n                }\n            } else { // ä¿®æ”¹\n                auto [val, pos, add] = get<modify>(o);\n                if (val <= x) {\n                    tr.add(pos, add);\n                    left.push_back(o);\n                } else {\n                    right.push_back(o);\n                }\n            }\n        }\n\n        for (auto o : left) {\n            if (holds_alternative<modify>(o)) { // è¿˜åŸæ ‘çŠ¶æ•°ç»„åˆ°åˆå§‹çŠ¶æ€\n                auto [val, pos, add] = get<modify>(o);\n                tr.add(pos, -add);\n            }\n        }\n\n        vector<op>{}.swap(ops); // é‡Šæ”¾ç©ºé—´\n\n        slf(slf, l, x, left);\n        slf(slf, x + 1, r, right);\n    };\n\n    solve(solve, 0, N - 1, ops);\n\n    for (auto x : ans) cout << x << '\\n';\n    return 0;\n}[ZJOI2013]Kå¤§æ•°æŸ¥è¯¢é¢˜ç›®é“¾æ¥æ­¤é¢˜åŒæ ·å› ä¸ºæœ‰å…ˆåé¡ºåºæ‰€ä»¥ä¹Ÿä¸èƒ½ç”¨ç¬¬ä¸€ç§æ€è·¯ï¼Œä½†æ€è·¯å’Œä¸Šé¢˜ç±»ä¼¼ã€‚  ä¸­æ¯ä¸ªé›†åˆåŠ å…¥ä¸€ä¸ªæ•°å°±ç›¸å½“äºåœ¨è¾…åŠ©æ•°ç»„ä¸­  çš„ä½ç½®ä¸ŠåŠ 1ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥åŒºé—´åŠ çš„æ•°æ®ç»“æ„ï¼Œæœ€ç®€å•çš„å°±æ˜¯æ ‘çŠ¶æ•°ç»„å•¦ã€‚å®ç°ç»†èŠ‚è¯¦è§ä»£ç ã€‚#include <bits/stdc++.h>\n#include \"data_structure/fenwick_range_update.hpp\"\nusing namespace std;\n\nstruct modify {\n    int val, l, r;\n};\n\nstruct query {\n    int l, r;\n    int64_t k;\n    int i;\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    using op = variant<modify, query>;\n    vector<op> ops; // ä¸ºäº†æ–¹ä¾¿å®ç°æˆ‘ä»¬æŠŠè¯¢é—®å’Œä¿®æ”¹æ”¾åˆ°ä¸€èµ·\n\n    int qcnt = 0;\n\n    for (int i = 0; i < m; i++) {\n        int op, l, r, c;\n        cin >> op >> l >> r >> c;\n        l--;\n        if (op == 1) {\n            ops.push_back(modify{c, l, r});\n        } else {\n            ops.push_back(query{l, r, c, qcnt++});\n        }\n    }\n\n    vector<int> ans(qcnt);\n\n    fenwick_rg tr(n);\n    auto solve = [&](auto& slf, int l, int r, vector<op>& ops) -> void {\n        if (l == r || ops.empty()) { // äºŒåˆ†ç»“æŸï¼Œç­”æ¡ˆç¡®å®š\n            for (const auto& o : ops) {\n                if (holds_alternative<query>(o)) { // å¦‚æœæ˜¯è¯¢é—®çš„è¯\n                    ans[get<query>(o).i] = l;\n                }\n            }\n            return;\n        }\n\n        int x = (l + r) / 2;\n\n        vector<op> left, right;\n        for (auto o : ops) {\n            if (holds_alternative<query>(o)) { // è¯¢é—®\n                auto& [ql, qr, k, i] = get<query>(o);\n                int64_t c = tr.get(ql, qr); // è´¡çŒ®\n                if (c >= k) { // æ ¹æ®è´¡çŒ®åˆ¤æ–­è¯¢é—®çš„ç­”æ¡ˆè¯¥å¦‚ä½•æ”¹å˜\n                    right.push_back(o);\n                } else {\n                    k -= c; // åœ¨ç›®æ ‡ä¸Šå‡æ‰è´¡çŒ®å’Œè®°å½•è´¡çŒ®æ˜¯ä¸€æ ·çš„\n                    left.push_back(o);\n                }\n            } else { // ä¿®æ”¹\n                auto [val, ql, qr] = get<modify>(o);\n                if (val > x) {\n                    tr.add(ql, qr, 1);\n                    right.push_back(o);\n                } else {\n                    left.push_back(o);\n                }\n            }\n        }\n\n        for (auto o : right) {\n            if (holds_alternative<modify>(o)) { // è¿˜åŸæ ‘çŠ¶æ•°ç»„åˆ°åˆå§‹çŠ¶æ€\n                auto [val, ql, qr] = get<modify>(o);\n                tr.add(ql, qr, -1);\n            }\n        }\n\n        vector<op>{}.swap(ops); // é‡Šæ”¾ç©ºé—´\n\n        slf(slf, l, x, left);\n        slf(slf, x + 1, r, right);\n    };\n\n    solve(solve, 0, n, ops);\n\n    for (auto x : ans) cout << x << '\\n';\n    return 0;\n}Meteorsé¢˜ç›®é“¾æ¥æ­¤é¢˜çš„ä¿®æ”¹æ“ä½œä¸ºåŒºé—´åŠ ï¼Œè€Œä¸”ä¿®æ”¹å’Œè¯¢é—®æ²¡æœ‰å‰åé¡ºåºï¼Œæ‰€ä»¥å¯ä»¥ç”¨ç¬¬ä¸€ç§æ€è·¯ã€‚#include <bits/stdc++.h>\n#include \"data_structure/fenwick.hpp\"\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> pos(n);\n    for (int i = 0; i < m; i++) {\n        int x;\n        cin >> x;\n        pos[x - 1].push_back(i);\n    }\n\n    vector<int> target(n);\n    for (auto& x : target) {\n        cin >> x;\n    }\n\n    int k;\n    cin >> k;\n    vector<array<int, 3>> meteors(k);\n    for (auto& [l, r, x] : meteors) {\n        cin >> l >> r >> x;\n        l--, r--;\n    }\n\n    vector<int> l(n, 0), r(n, k - 1);\n\n\n    while (true) {\n        vector<vector<int>> to_check(k);\n        bool done = 1;\n        for (int i = 0; i < n; i++) {\n            if (l[i] <= r[i]) {\n                int mid = (l[i] + r[i]) / 2;\n                to_check[mid].push_back(i);\n                done = false;\n            }\n        }\n\n        if (done) {\n            break;\n        }\n\n        Fenwick<int64_t> tr(m + 1);\n        auto range_add = [&](int l, int r, int x) {\n            tr.add(l, x);\n            tr.add(r, -x);\n        };\n        auto apply_meteor = [&](int i) {\n            auto [l, r, x] = meteors[i];\n            if (l <= r) {\n                range_add(l, r + 1, x);\n            } else {\n                range_add(l, m, x);\n                range_add(0, r + 1, x);\n            }\n        };\n        for (int i = 0; i < k; i++) {\n            apply_meteor(i);\n            for (auto j : to_check[i]) {\n                uint64_t sum = 0;\n                for (auto p : pos[j]) {\n                    sum += tr.get(p + 1);\n                }\n                if (sum >= target[j]) {\n                    r[j] = i - 1;\n                } else {\n                    l[j] = i + 1;\n                }\n            }\n        }\n    }\n\n    for (auto x : l) {\n        if (x == k) cout << \"NIE\\n\";\n        else cout << x + 1 << '\\n';\n    }\n    return 0;\n}AGC002D Stamp Rallyé¢˜ç›®é“¾æ¥è¿™é¢˜æ€è·¯å…¶å®ä¸éš¾ï¼Œä¿®æ”¹å°±æ˜¯åœ¨å¹¶æŸ¥é›†é‡Œè¿è¾¹ï¼Œè´¡çŒ®å°±æ˜¯è¿é€šå—çš„å¤§å°ï¼Œç”¨ç¬¬ä¸€ç§æ€è·¯è§£å†³ã€‚#include <bits/stdc++.h>\n#include \"data_structure/union_find.hpp\"\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    vector<array<int, 2>> edges(m);\n    for (auto& [u, v] : edges) {\n        cin >> u >> v;\n        u--, v--;\n    }\n\n    int q;\n    cin >> q;\n    vector<array<int, 3>> query(q);\n    for (auto& [l, r, x] : query) {\n        cin >> l >> r >> x;\n        l--, r--;\n    }\n\n    vector<int> l(q, 0), r(q, m - 1);\n\n    while (true) {\n        vector<vector<int>> to_check(q);\n        bool done = 1;\n        for (int i = 0; i < q; i++) {\n            if (l[i] <= r[i]) {\n                int mid = (l[i] + r[i]) / 2;\n                to_check[mid].push_back(i);\n                done = false;\n            }\n        }\n\n        if (done) {\n            break;\n        }\n\n        UF uf(n);\n        for (int i = 0; i < m; i++) {\n            uf.join(edges[i][0], edges[i][1]);\n\n            for (auto j : to_check[i]) {\n                auto [u, v, z] = query[j];\n                int sz = uf.size_of(u);\n                if (!uf.same(u, v)) {\n                    sz += uf.size_of(v);\n                }\n                if (sz >= z) {\n                    r[j] = i - 1;\n                } else {\n                    l[j] = i + 1;\n                }\n            }\n        }\n    }\n\n    for (auto x : l) {\n        cout << x + 1 << '\\n';\n    }\n    return 0;\n}"},{"id":"pb_ds-segment-tree","title":"ç”¨PB_DSå®ç°ç®€å•çº¿æ®µæ ‘","content":"ç”¨PB_DSå®ç°ä¸€ä¸ªåªèƒ½å•ç‚¹ä¿®æ”¹çš„çº¿æ®µæ ‘ï¼Œä½†åˆèƒ½åŠ¨æ€æ’å…¥å’Œåˆ é™¤ï¼Œç°åœºèµ›çš„æ—¶å€™åœ¨å¯¹æ—¶é—´è¦æ±‚ä¸å¤§çš„æƒ…å†µä¸‹å¯ä»¥èŠ‚çº¦æ•²ä»£ç æ—¶é—´ã€‚åŸç†åŸç†å°±æ˜¯PB_DSé‡Œçš„treeçš„æœ€åä¸€ä¸ªæ¨¡æ¿å‚æ•°å®šä¹‰äº†èŠ‚ç‚¹å¦‚ä½•æ›´æ–°ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è‡ªå®šä¹‰ç±»è®©èŠ‚ç‚¹ç»´æŠ¤é¢å¤–çš„ä¿¡æ¯ï¼ˆå­æ ‘å¤§å°ä¹‹ç±»çš„ï¼‰ã€‚éœ€è¦å®šä¹‰é¢å¤–ä¿¡æ¯ç±»ä¸ºï¼Œç„¶åé‡è½½æ‹¬å·è¿ç®—ç¬¦æ¥å®šä¹‰èŠ‚ç‚¹å¦‚ä½•åˆå¹¶ã€‚é€šè¿‡æ ‘åˆ†è£‚å®ç°åŒºé—´æŸ¥è¯¢ï¼Œä½†æœ‰ä¸ªé—®é¢˜å°±æ˜¯åˆ†è£‚ä¹‹åçš„æ ‘çš„å¤§å°æ˜¯é€šè¿‡æ¥è®¡ç®—çš„ï¼Œå¯¹äºtreeçš„è¿­ä»£å™¨æ¥è¯´æ—¶é—´å¤æ‚åº¦æ˜¯çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜è¦é‡è½½ ä¾‹å­ï¼šRMQ#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\n\nstruct Node {\n    int size, min;\n};\ntemplate<typename node_const_iterator, typename node_iterator, typename cmp_fn, typename _Alloc>\nstruct tree_max {\n    typedef Node metadata_type;\n \n    inline void operator() (node_iterator it, node_const_iterator null) const\n    {\n        auto& n = (Node&)it.get_metadata();\n        n.size=1;\n        n.min=(*it)->second;\n        for (auto& c : {it.get_l_child(), it.get_r_child()}) {\n            if (c != null) {\n                n.size+=c.get_metadata().size;\n                n.min=min(n.min, c.get_metadata().min);\n            }\n        }\n    }\n};\n\nusing Tree = __gnu_pbds::tree<int, int, std::less<int>, __gnu_pbds::splay_tree_tag, tree_max>;\nusing ti = Tree::iterator;\nTree *other;\nnamespace std {\n    template<> iterator_traits<ti>::difference_type distance<ti>(ti a, ti b) {\n        return other->node_begin().get_metadata().size; \n    }\n}\nvoid split(Tree& a, Tree& b, int x) {\n    other = &b;\n    a.split(x, b);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n, q;\n    cin >> n >> q;\n    Tree tr;\n    for (int i=0; i<n; i++) {\n        int x;\n        cin >> x;\n        tr.insert({i, x});\n    }\n    while (q--) {\n        int l, r;\n        cin >> l >> r;\n        Tree B, C;\n        split(tr, C, r-1);\n        split(tr, B, l-1);\n        cout << B.node_begin().get_metadata().min<<'\\n';\n        tr.join(B);\n        tr.join(C);\n    }\n}éåˆ†è£‚åšæ³•å¯¹äºå¯é€†çš„ä¿¡æ¯ï¼ˆå¦‚åŒºé—´å’Œï¼‰æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨æ ‘ä¸Šè¡Œèµ°è·å¾—å‰ç¼€ä¿¡æ¯ï¼Œç„¶åé€šè¿‡å‰ä¸ªå‰ç¼€ä¿¡æ¯å¾—åˆ°åŒºé—´ä¿¡æ¯ã€‚ç›®å‰å…ˆè´´ä¸ªåˆ«äººçš„é“¾æ¥ï¼Œè¿˜æ²¡ç ”ç©¶å¦‚ä½•å†™çš„çŸ­ç‚¹ã€‚"},{"id":"portainer","title":"Portainer","content":"Portaineræ˜¯ä¸€ä¸ªDockerå’ŒKubernetesç®¡ç†è½¯ä»¶ï¼ˆæœ¬æ–‡åªæ¶‰åŠDocker)ã€‚å®‰è£…å…ˆåˆ›å»ºä¸€ä¸ªvolumndocker volume create portainer_dataå®‰è£…docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.11.1å…¶ä¸­9443æ˜¯web uiçš„ç«¯å£ï¼Œå¯ä»¥æ ¹æ®æƒ…å†µä¿®æ”¹ã€‚ä½¿ç”¨docker-composestacks -> add stack -> å¤åˆ¶docker-composeæ–‡ä»¶ -> deploy the stackQuick Actionså¸¸ç”¨ä¸¤ä¸ªquick actions:Logs: æŸ¥çœ‹logExec Console: è¿è¿›containeré‡Œé¢å¹²ä¸€äº›éªšæ“ä½œï¼Œæ¯”å¦‚è£…ä¸ªåŒ…ä»€ä¹ˆçš„ã€‚ã€‚ã€‚Tipsè®¾ç½®å†…ç½‘IPå·¦ä¾§è¾¹æ Environment -> é€‰æ‹©æœåŠ¡å™¨ï¼ˆé»˜è®¤å«Localï¼‰-> Public IPé‡Œå¡«å…¥æœåŠ¡å™¨çš„å†…ç½‘IPè¿™æ ·ç‚¹å‡»ç«¯å£å°±èƒ½è‡ªåŠ¨è·³è½¬åˆ°æ­£ç¡®çš„åœ°å€äº†ã€‚å‚è€ƒèµ„æ–™https://docs.portainer.io/v/ce-2.11/start/install/server/docker/linuxhttps://www.youtube.com/watch?v=ljDI5jykjE8#1"},{"id":"pro-micro-dfu-bootloader","title":"ç”¨ä¸¤ä¸ªPro Microäº’ç›¸ç»™å¯¹æ–¹åˆ·ä¸ŠDFU bootloader","content":"ä¸€ç¯‡å¦‚ä½•ç”¨ä¸¤ä¸ªpro microå½“ä½œISP(In-System Programmer)äº’ç›¸ç»™å¯¹æ–¹åˆ·ä¸ŠDFU bootloader.ä¼—æ‰€å‘¨çŸ¥ï¼Œä¸€èˆ¬pro microè‡ªå¸¦çš„bootloaderæ˜¯caterinaï¼Œæœ‰ä¸€ä¸ªæ¯”è¾ƒçƒ¦äººçš„ç¼ºç‚¹å°±æ˜¯ä¸€æ¬¡resetä¹‹ååªæœ‰8ç§’çš„æ—¶é—´åœ¨dfuæ¨¡å¼é‡Œã€‚è€Œdfu bootloaderå°±ä¸ä¼šæœ‰è¿™ä¸ªé—®é¢˜ã€‚å…è´£å£°æ˜æœ¬äººå¹¶ä¸æ˜¯å­¦ç”µå­ä¸“ä¸šçš„ï¼Œåªæ˜¯ä»¥ä¸€ä¸ªå®¢åˆ¶åŒ–é”®ç›˜çˆ±å¥½è€…çš„è§’åº¦å†™çš„æ­¤æ•™ç¨‹ï¼Œå¦‚æœ‰ä¸æ…æˆ–æ„å¤–å¯èƒ½ä¼šå¯¼è‡´pro microå˜ç –ã€‚çº¯å°ç™½è¯·è°¨æ…è€ƒè™‘ã€‚æœ¬æ–‡å¦‚æœ‰é”™è¯¯æ¬¢è¿æŒ‡æ­£ã€‚å·¥å…·è½¯ä»¶Arduino IDEQMK toolboxbootloaderæ–‡ä»¶ç¡¬ä»¶ä¸¤ä¸ª pro microï¼Œ6æ ¹å¯¼çº¿æ­¥éª¤ç»™ä¸¤ä¸ªpro microåˆ·bootloaderçš„æ­¥éª¤ç¨æœ‰ä¸åŒç»™ç¬¬ä¸€ä¸ªpro microåˆ·æ‰“å¼€Arduino IDE, Tools -> Arduino Leonardo, Tools -> Port å¹¶è®°ä½ç«¯å£å·ï¼ŒFile -> Examples -> ArduinoISP -> ArduinoISP ç„¶åç‚¹uploadï¼Œè¿™æ ·ä¸€ä¸ªpro microå°±å˜æˆäº†ISPã€‚æ¥çº¿ï¼šæ¯è¡Œå·¦å³ä¸¤ä¾§è„šä½ç›¸è¿:ISPç›®æ ‡VCCVCCGNDGNDSCLKSCLKMISOMISOMOSIMOSI10RSTåˆ·å…¥Win+Rç„¶åè¾“å…¥cmdæ‰“å¼€å‘½ä»¤è¡Œï¼Œç„¶åè¿›åˆ°QMK Toolboxçš„ç›®å½•ï¼Œç”¨åˆ°çš„ç¨‹åºåœ¨è¿™ä¸ªç›®å½•é‡Œã€‚ä¸‹é¢çš„è¦æ¢æˆä½ QMK Toolbox çš„ç‰ˆæœ¬å·(å†™è¿™ä¸ªæ•™ç¨‹æ—¶æœ€æ–°çš„ç‰ˆæœ¬ä¸º0.1.1)ï¼Œæ‰€ä»¥ä¸è¦ç›´æ¥å¤åˆ¶ç²˜è´´ã€‚cd AppData\\Local\\QMK\\QMK Toolbox\\0.x.x\\ç„¶åè¿è¡Œåˆ·å…¥çš„å‘½ä»¤ï¼Œå…¶ä¸­æ¢æˆç¬¬ä¸€æ­¥ä¸­çš„ç«¯å£å·ï¼Œæ¢æˆbootloaderæ–‡ä»¶çš„åœ°å€avrdude.exe -c arduino -p atmega32u4 -P <PORT> -U flash:w:\"<PATH>\":a -U hfuse:w:0xD9:m -U efuse:w:0xC3:m -U lock:w:0x3F:må¦‚æœè¿è¡ŒæˆåŠŸçš„è¯ä½ å°±æˆåŠŸå°†dfu bootloaderåˆ·åˆ°pro microä¸Šäº†ã€‚ç»™å¦ä¸€ä¸ªpro microåˆ·ç”±äºarduinoä¸æ”¯æŒdfuï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç”¨å¦ä¸€ä¸ªç¨‹åºï¼ˆä¹Ÿåœ¨QMK Toolboxçš„ç›®å½•ä¸‹ï¼‰æ¥å°†åˆ·å…¥dfuçš„é‚£ä¸ªpro microå†å˜æˆISPã€‚é¦–å…ˆè¦æ‰¾åˆ°ArduinoISPç¼–è¯‘åçš„hexæ–‡ä»¶:(xxxxxxæ˜¯ä¸€ä¸²æ•°å­—ï¼Œæ¯ä¸ªäººçš„ä¸ä¸€æ ·)ã€‚æ¥ä¸‹æ¥å°±å‡†å¤‡åˆ·å…¥äº†ï¼Œè¿˜æ˜¯åœ¨QMK Toolboxçš„ç›®å½•ä¸‹ï¼Œæ‰§è¡Œä¸‹é¢3æ¡å‘½ä»¤ï¼š(å…¶ä¸­æ¢æˆåˆšæ‰æåˆ°çš„ArduinoISP.ino.hexçš„è·¯å¾„)dfu-programmer.exe atmega32u4 erase\ndfu-programmer.exe atmega32u4 flash <PATH>\ndfu-programmer.exe atmega32u4 resetæœ€åå†é‡å¤ä¸Šä¸€ä¸ªéƒ¨åˆ†çš„2ã€3æ­¥å³å¯ã€‚å‚è€ƒèµ„æ–™https://www.reddit.com/r/olkb/comments/9ctx37/qmk_burn_dfu_bootloader_into_keyboard_with/\nhttps://www.reddit.com/r/olkb/comments/8sxgzb/replace_pro_micro_bootloader_with_qmk_dfu/"},{"id":"rime-flypy","title":"Rimeé…ç½®ç è¡¨è¾“å…¥æ³•ï¼ˆä»¥å°é¹¤éŸ³å½¢ä¸ºä¾‹ï¼‰","content":"rimeè¾“å…¥æ³•æ¡†æ¶é…ç½®ç è¡¨è¾“å…¥æ³•çš„ç®€å•æ•™ç¨‹ï¼Œä»¥windowsä¸Šå°é¹¤éŸ³å½¢ä¸ºä¾‹ã€‚æœ€è¿‘ç”±äºwaylandæœ‰ç‚¹å—ä¸äº†äº†ï¼Œå†³å®šæ¢æˆwindows+wslè¯•è¯•ï¼Œè™½è¯´windowsä¸Šæœ‰ç°æˆçš„å°é¹¤éŸ³å½¢ï¼Œä½†ç›¸ä¿¡å¤§å¤šæ•°ç è¡¨ç”¨æˆ·å’Œæˆ‘ä¸€æ ·åœ¨æ ‡å‡†è¯åº“ä¸Šæœ‰æ‰€åˆ å‡ï¼Œæ‰€ä»¥éœ€è¦ä¸€ä¸ªè¾“å…¥æ³•æ¡†æ¶ã€‚ç”¨linuxçš„æ—¶å€™ä¹…é—»rimeä¹‹å¤§åï¼Œä½†å¹¶æ²¡æœ‰æ‰¾åˆ°å¾ˆå¥½é…ç½®ç è¡¨çš„æ•™ç¨‹ï¼Œè€Œå®˜æ–¹æ–‡æ¡£æœ‰ç‚¹é•¿å†åŠ ä¸Šæ˜¯ç¹ä½“å†™çš„è¯»èµ·æ¥æœ‰ç‚¹è´¹äº‹ï¼Œé‚å†³å®šè®°å½•ä¸€ä¸‹è‡ªå·±é…ç½®çš„è¿‡ç¨‹ä¾›å¤§å®¶å‚è€ƒã€‚å…¶å®ç è¡¨é…ç½®èµ·æ¥å¾ˆç®€å•ï¼Œä¸€å…±åªéœ€è¦ä¸¤ä¸ªæ–‡ä»¶ï¼šåä¸ºçš„æ–¹æ¡ˆå®šä¹‰æ–‡ä»¶å’Œåä¸ºçš„ç è¡¨æ–‡ä»¶ã€‚æ–¹æ¡ˆå®šä¹‰æ–‡ä»¶ä¸€èˆ¬éƒ½æœ‰ç°æˆçš„ï¼Œæ¯”å¦‚å°é¹¤éŸ³å½¢çš„åœ¨è¿™(æŒ‚æ¥ç¬¬ä¸‰æ–¹å¹³å°é‡Œ)ã€‚ç è¡¨æ ¼å¼è¦æ±‚çœ‹è¿™ï¼Œå¦‚æœä½ åƒæˆ‘ä¸€æ ·ä¹‹å‰æ˜¯ç”¨fcitxæ ¼å¼çš„ç è¡¨ï¼Œå¯ä»¥å¾ˆç®€å•çš„ç”¨ä¿®æ”¹æ ¼å¼ã€‚ç„¶åå°†ä¸¤ä¸ªæ–‡ä»¶æ”¾å…¥é»˜è®¤æ–‡ä»¶å¤¹ï¼ˆwindowsä¸Šé»˜è®¤ä¸ºï¼‰ï¼Œå¹¶ä¿®æ”¹:åœ¨é‡ŒåŠ ä¸€è¡Œã€‚æœ€åå³é”®è¾“å…¥æ³•å›¾æ ‡ç‚¹â€œé‡æ–°éƒ¨ç½²â€å³å¯ã€‚"},{"id":"rime","title":"RIMEç®€ä»‹ä¸å°é¹¤éŸ³å½¢","content":"ç è¡¨ä¸‹è½½ä¸ºäº†æœ€å¤§é™åº¦çš„è‡ªå®šä¹‰ï¼Œæˆ‘ä»¬è‚¯å®šè¦æ‰¾åˆ°çº¯æ–‡æœ¬ç è¡¨ï¼Œå®˜æ–¹ç»™çš„RimeæŒ‚æ¥éƒ½åªæœ‰äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œä½†æ˜¯æˆ‘æ‰¾äº†æ‰¾ç«Ÿç„¶å‘ç°æœç‹—äº”ç¬”æ˜¯çº¯æ–‡æœ¬ç è¡¨ï¼šä¸‹è½½é“¾æ¥ç è¡¨å»é‡ä»¥åŠè½¬æ¢ä¸ºRimeæ ¼å¼#include <iostream>\n#include <fstream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ifstream in{\"sougou.txt\"};\n    string code, text;\n    multimap<string, pair<string, int>> mp;\n    int order = 0;\n    auto is_substr = [&](const string& a, const string& b) {\n        return a.substr(0, size(b)) == b || b.substr(0, size(a)) == a;\n    };\n    while (in >> code >> text) {\n        if (!mp.count(text)) {\n            mp.emplace(text, pair{code, order});\n        } else if (size(text) == 3) { // å•å­—ä¿ç•™å¤šéŸ³å­—\n            auto it = mp.find(text);\n            bool dup = 0;\n            while (it!=end(mp) && it->first == text) {\n                if (is_substr(it->second.first, code)) {\n                    dup = true;\n                    if (size(code) < size(it->second.first))\n                        it->second = {code, order};\n                }\n                ++it;\n            }\n            if (!dup)\n                mp.emplace(text, pair{code, order});\n        } else if (size(text) == 6) { //ä¸¤å­—è¯ä¸¤ç å’Œå››ç ä¼˜å…ˆ\n            auto it = mp.find(text);\n            if (size(code) % 2 == 0 &&\n                    (size(it->second.first) % 2 || it->second.first.size() > code.size()))\n                it->second = {code, order};\n        } else { //å…¶ä»–è¯çŸ­ç ä¼˜å…ˆ\n            auto it = mp.find(text);\n            if (it->second.first.size() > code.size())\n                it->second = {code, order};\n        }\n        order++;\n    }\n    vector<tuple<string, int, string>> v;\n    for (const auto& [text, code] : mp)\n        v.emplace_back(code.first, code.second, text);\n    sort(begin(v), end(v));\n\n    ofstream out{\"flypy.dict.yaml\"};\n    out << R\"(---\nname: flypy\nversion: \"0.1\"\nsort: original\nuse_preset_vocabulary: false\n...\n)\";\n    for (const auto& [code, odder, text] : v) {\n        out << text << '\\t' << code << '\\n';\n    }\n}Rimeå®˜æ–¹è¾“å…¥æ–¹æ¡ˆè®¾è®¡ä¹¦schema.yamlè¯¦è§£å¸¸ç”¨çš„æ–‡ä»¶æœ‰:è¾“å…¥æ–¹æ¡ˆå¤´æ–‡ä»¶ å®šä¹‰ä¸€ä¸ªè¾“å…¥æ–¹æ¡ˆè¾“å…¥æ–¹æ¡ˆç è¡¨ è¾“å…¥æ–¹æ¡ˆçš„ç è¡¨ï¼ˆå¦‚æœç”¨åˆ°ç è¡¨çš„è¯ï¼‰è‡ªå®šä¹‰å…¨å±€è®¾å®š æ¯”å¦‚å¼€å¯äº†å“ªäº›è¾“å…¥æ³•é’ˆå¯¹ä¸åŒå‘è¡Œç‰ˆçš„è®¾å®š æ¯”å¦‚è¾“å…¥æ³•çš®è‚¤ç¤ºä¾‹# Rime schema settings\n# encoding: utf-8\n\nschema:\n  schema_id: flypy\n  name: å°é¹¤éŸ³å½¢\n  version: \"10.8.4\"\n  author:\n    - æ–¹æ¡ˆè®¾è®¡ï¼šä½•æµ·å³° <flypy@qq.com>\n  description: |\n    å°é¹¤éŸ³å½¢è¾“å…¥æ³•\n\npunctuator:\n  import_preset: default\n\nswitches:\n  - name: ascii_mode\n    reset: 0\n    states: [ ä¸­æ–‡, è‹±æ–‡ ]\n  - name: full_shape\n    states: [ åŠè§’, å…¨è§’ ]\n  - name: ascii_punct\n   # states: [ ã€‚ï¼Œ, ï¼ï¼Œ ]\n    reset: 0\n\nengine:\n  processors:\n    - ascii_composer\n    - recognizer\n    - key_binder\n    - speller\n    - punctuator\n    - selector\n    - navigator\n    - express_editor\n  segmentors:\n    - ascii_segmentor\n    - matcher\n    - abc_segmentor\n    - punct_segmentor\n    - fallback_segmentor\n  translators:\n    - punct_translator\n    - table_translator\n    - table_translator@user_dict\n    - history_translator@history\n  filters:\n    - simplifier\n    - reverse_lookup_filter\n    - uniquifier\n\nspeller:\n  alphabet: \"abcdefghijklmnopqrstuvwxyz;'\"\n  initials: ';abcdefghijklmnopqrstuvwxyz'\n  finals: \"'\"\n  #delimiter: \" '\"\n  max_code_length: 4\n  auto_select: true   #é¡¶å­—ä¸Šå±\n  auto_select_pattern: ^;.$|^\\w{4}$\n  auto_clear: max_length #manual|auto|max_length ç©ºç æŒ‰ä¸‹ä¸€é”®ç¡®è®¤æ¸…å±|ç©ºç è‡ªåŠ¨æ¸…|è¾¾åˆ°æœ€é•¿ç æ—¶åç é¡¶ä¸Šæ¸…å±\n\ntranslator:\n  dictionary: flypy\n  enable_charset_filter: false\n  enable_sentence: false\n  enable_completion: false # ç¼–ç æç¤ºå¼€å…³\n  enable_user_dict: false\n \n\nhistory:\n   input: ;f\n   size: 1 #é‡å¤å‰å‡ æ¬¡ä¸Šå±\n   initial_quality: 1 #é¦–é€‰\n\n\nuser_dict:\n  dictionary: \"\"\n  user_dict: user_dict\n  db_class: tabledb\n  enable_sentence: false\n  enable_completion: false\n  initial_quality: -1 #ä¼˜å…ˆçº§\n\n\nkey_binder:\n  import_preset: default #æ–¹æ¡ˆåˆ‡æ¢ç›¸å…³\n  bindings:\n    - {accept: bracketleft, send: Page_Up, when: paging} # [ä¸Šç¿»é¡µ\n    - {accept: bracketright, send: Page_Down, when: has_menu} # ]ä¸‹ç¿»é¡µ\n    - {accept: comma, send: comma, when: paging} #æ³¨é”€é€—å·ç¿»é¡µ\n    - {accept: period, send: period, when: has_menu} #æ³¨é”€å¥å·ç¿»é¡µ\n    - {accept: semicolon, send: 2, when: has_menu} #åˆ†å·æ¬¡é€‰\n    # - {accept: Release+semicolon, send: semicolon, when: has_menu} #å¦‚å¯ç”¨æ­¤è¡Œï¼Œåˆ™åˆ†å·å¼•å¯¼ç¬¦å·åŠŸèƒ½æ— æ•ˆ\n    - {accept: Release+period, send: period, when: composing} #å¥å·é¡¶å±\n    - {accept: Release+comma, send: comma, when: composing} #é€—å·é¡¶å±\n    - {accept: \"Tab\", send: Escape, when: composing}\n    - {accept: \"Shift_R\", send: Escape, when: composing}\n    # - {accept: \"Shift+space\", toggle: full_shape, when: always} #åˆ‡æ¢å…¨åŠè§’\n    - {accept: \"Control+period\", toggle: ascii_punct, when: always} #åˆ‡æ¢ä¸­è‹±æ ‡ç‚¹\n    # - {accept: \"Control+j\", toggle: simplification, when: always} #åˆ‡æ¢ç®€ç¹\n\nrecognizer:\n  import_preset: default\n  patterns:\n    # reverse_lookup: \"[a-z`]*`+[a-z`]*\"åæŸ¥åº”è¯¥ä¸éœ€è¦\n\nmenu:\n  page_size: 5 #å€™é€‰é¡¹æ•°\n  \nstyle:\n  horizontal: true #ç«–æ’ä¸ºfalse"},{"id":"rust-BTreeSet","title":"Rust BTreeSet","content":"æœ‰ç”¨çš„å‡½æ•°range()è¿”å›setä¸­ä¸€æ®µåŒºé—´çš„è¿­ä»£å™¨ï¼Œå¯ä»¥å½“C++ä¸­æˆ–è€…ç”¨ï¼Œä¸¾ä¾‹ï¼šuse std::ops::Bound::*;\nlet mut set = BTreeSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(3);\nassert_eq!(set.range(2..).next(), Some(&2));\nassert_eq!(set.range((Excluded(2), Unbounded)).next(), Some(&3));\nassert_eq!(set.range(..2).last(), Some(&1));\nassert_eq!(set.range(..=2).last(), Some(&2));"},{"id":"rust-iterator","title":"Rust è¿­ä»£å™¨ï¼ˆIteratorï¼‰","content":"å®ç”¨å‡½æ•°, "},{"id":"rust-pattern","title":"Rust æ¨¡å¼ï¼ˆPatternï¼‰","content":"åŒ¹é…å­—é¢é‡let x = 1;\nmatch x {\n    1 => println!(\"one\") ,\n    2 => println!(\"two\"),\n    3 => println!(\"three\") ,\n    _ => println!(\"anything\"),\n}åŒ¹é…å˜é‡let x = Some(5);\nmatch x {\n    Some(50) => println!(\"Got 50\"),\n    Some(y) => println!(\"Got {:?}\", y),\n    _ => println!(\"Got something else {:?}\", x),\n}ä¸€ä¸ªåˆ†æ”¯å¤šä¸ªæ¨¡å¼let x = 1;\nmatch x {\n    1 | 2 => println!(\"one or two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}ç”¨..=åŒ¹é…èŒƒå›´ç›®å‰åªæ”¯æŒ..=let x = 5;\n\nmatch x {\n    1..=5 => println!(\"one through five\"),\n    _ => println!(\"something else\"),\n}\n\nlet x = 'c';\n\nmatch x {\n    'a'..='j' => println!(\"early ASCII letter\"),\n    'k'..='z' => println!(\"late ASCII letter\"),\n    _ => println!(\"something else\"),\n}åˆ†è§£ç»“æ„ä½“ï¼ˆDestructing Structsï¼‰struct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x: a, y: b } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n}å½“å˜é‡åç§°ä¸fieldåç§°ç›¸åŒæ—¶å¯ä»¥ç®€å†™ï¼šstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x, y } = p;\n    assert_eq!(0, x);\n    assert_eq!(7, y);\n}åŒ¹é…éƒ¨åˆ†ï¼šstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } => println!(\"On the x axis at {}\", x),\n        Point { x: 0, y } => println!(\"On the y axis at {}\", y),\n        Point { x, y } => println!(\"On neither axis: ({}, {})\", x, y),\n    }\n}åˆ†è§£Enumsenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println!(\"The Quit variant has no data to destructure.\")\n        }\n        Message::Move { x, y } => {\n            println!(\n                \"Move in the x direction {} and in the y direction {}\",\n                x, y\n            );\n        }\n        Message::Write(text) => println!(\"Text message: {}\", text),\n        Message::ChangeColor(r, g, b) => println!(\n            \"Change the color to red {}, green {}, and blue {}\",\n            r, g, b\n        ),\n    }\n}åˆ†è§£åµŒå¥—çš„ç»“æ„ä½“æˆ–è€…Enumsenum Color {\n    Rgb(i32, i32, i32),\n    Hsv(i32, i32, i32),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(Color),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n\n    match msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) => println!(\n            \"Change the color to red {}, green {}, and blue {}\",\n            r, g, b\n        ),\n        Message::ChangeColor(Color::Hsv(h, s, v)) => println!(\n            \"Change the color to hue {}, saturation {}, and value {}\",\n            h, s, v\n        ),\n        _ => (),\n    }\n}åˆ†è§£ç»“æ„ä½“å’Œå…ƒç»„fn main() {\n    struct Point {\n        x: i32,\n        y: i32,\n    }\n\n    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });\n}å¿½ç•¥æ¨¡å¼ä¸­çš„å€¼ç”¨å¿½ç•¥æ•´ä¸ªå€¼ï¼šfn foo(_: i32, y: i32) {\n    println!(\"This code only uses the y parameter: {}\", y);\n}\n\nfn main() {\n    foo(3, 4);\n}ç”¨åµŒå¥—çš„å¿½ç•¥å€¼çš„éƒ¨åˆ†ï¼šfn main() {\n    let mut setting_value = Some(5);\n    let new_setting_value = Some(10);\n\n    match (setting_value, new_setting_value) {\n        (Some(_), Some(_)) => {\n            println!(\"Can't overwrite an existing customized value\");\n        }\n        _ => {\n            setting_value = new_setting_value;\n        }\n    }\n\n    println!(\"setting is {:?}\", setting_value);\n}å¿½ç•¥å…ƒç»„çš„éƒ¨åˆ†å€¼ï¼šfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, _, third, _, fifth) => {\n            println!(\"Some numbers: {}, {}, {}\", first, third, fifth)\n        }\n    }\n}å¿½ç•¥å‰©ä½™éƒ¨åˆ†ï¼šfn main() {\n    struct Point {\n        x: i32,\n        y: i32,\n        z: i32,\n    }\n\n    let origin = Point { x: 0, y: 0, z: 0 };\n\n    match origin {\n        Point { x, .. } => println!(\"x is {}\", x),\n    }\n}åŒ¹é…ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªï¼šfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) => {\n            println!(\"Some numbers: {}, {}\", first, last);\n        }\n    }\n}åˆ©ç”¨Match Guardså®ç°æ›´å¤šçš„æ¡ä»¶fn main() {\n    let num = Some(4);\n\n    match num {\n        Some(x) if x % 2 == 0 => println!(\"The number {} is even\", x),\n        Some(x) => println!(\"The number {} is odd\", x),\n        None => (),\n    }\n}å¤šæ¨¡å¼ï¼šfn main() {\n    let x = 4;\n    let y = false;\n\n    match x {\n        4 | 5 | 6 if y => println!(\"yes\"), // ç­‰ä»·äº (4 | 5 | 6) if y =>\n        _ => println!(\"no\"),\n    }\n}@ç»‘å®š@å…è®¸æˆ‘ä»¬åœ¨åˆ›å»ºå˜é‡çš„åŒæ—¶æµ‹è¯•å˜é‡çš„å€¼fn main() {\n    enum Message {\n        Hello { id: i32 },\n    }\n\n    let msg = Message::Hello { id: 5 };\n\n    match msg {\n        Message::Hello {\n            id: id_variable @ 3..=7,\n        } => println!(\"Found an id in range: {}\", id_variable),\n        Message::Hello { id: 10..=12 } => {\n            println!(\"Found an id in another range\")\n        }\n        Message::Hello { id } => println!(\"Found some other id: {}\", id),\n    }\n}Reference:\nPattern Syntax"},{"id":"rust-slice","title":"Rust Slice","content":"å®ç”¨å‡½æ•°, "},{"id":"rvalue-reference","title":"å…³äºå³å€¼å¼•ç”¨çš„ä¸€äº›çŸ¥è¯†ç‚¹","content":"æ„Ÿè§‰ä¸€ç›´éƒ½æ²¡æ€ä¹ˆææ˜ç™½ï¼Œé‚å†³å®šä»”ç»†å­¦ä¸€ä¸‹å¹¶è®°å½•ä¸€äº›é›¶æ•£çš„çŸ¥è¯†ç‚¹ã€‚ï¼ˆåŒ…å«ä¸ªäººç†è§£ï¼Œä¸ä¸€å®šä¸¥è°¨æ­£ç¡®ï¼‰å€¼ç±»åˆ«ä¸ç±»å‹C++ è¡¨è¾¾å¼å…·æœ‰å€¼ç±»åˆ«ä¸ç±»å‹ä¸¤ç§å±æ€§ã€‚C++ æœ‰ä¸‰ç§åŸºæœ¬ç±»åˆ«ï¼šå·¦å€¼ï¼Œçº¯å³å€¼ï¼Œäº¡å€¼ã€‚çº¯å³å€¼å’Œäº¡å€¼ç»Ÿç§°ä¸ºå³å€¼ï¼Œå³å€¼ä¸èƒ½ç”±å†…å»ºçš„å–å€è¿ç®—ç¬¦å–åœ°å€ã€‚å¤§éƒ¨åˆ†å³å€¼éƒ½æ˜¯çº¯å³å€¼ï¼Œä¸è¿™ç¯‡æ–‡ç« å…³ç³»æ¯”è¾ƒå¤§çš„äº¡å€¼æœ‰ï¼šè¿”å›ç±»å‹æ˜¯å¯¹è±¡çš„å³å€¼å¼•ç”¨çš„å‡½æ•°è°ƒç”¨æˆ–é‡è½½è¿ç®—ç¬¦è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ è½¬æ¢åˆ°å¯¹è±¡çš„å³å€¼å¼•ç”¨ç±»å‹çš„è½¬å‹è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ ç±»å‹æœ‰åŸºç¡€ç±»å‹ï¼šã€ç­‰ï¼Œå¤åˆç±»å‹ã€‚æˆ‘ä»¬è¿™é‡Œä¸»è¦è®¨è®ºå¤åˆç±»å‹ä¸­çš„å¼•ç”¨ç±»å‹ï¼Œå¼•ç”¨ç±»å‹åˆåŒ…å«å·¦å€¼å¼•ç”¨ç±»å‹ä¸å³å€¼å¼•ç”¨ç±»å‹ã€‚æ³¨æ„åŒºåˆ«å€¼ç±»åˆ«ä¸ç±»å‹ï¼Œæ¯”å¦‚ ï¼Œå˜é‡  çš„ç±»å‹æ˜¯å³å€¼å¼•ç”¨ç±»å‹ï¼Œä½†æ˜¯  è¿™ä¸ªè¡¨è¾¾å¼æ˜¯å·¦å€¼ã€‚ä¸æ˜¯  éƒ½æ˜¯å³å€¼å¼•ç”¨åªæœ‰ç¡®å®šçš„ç±»å‹åŠ æ‰æ˜¯å³å€¼å¼•ç”¨ï¼Œå¦åˆ™è¢«ç§°ä¸º universal reference(ä¸‡èƒ½å¼•ç”¨)/forwarding reference(è½¬å‘å¼•ç”¨ï¼Ÿ)ï¼Œä¸‡èƒ½å¼•ç”¨å¯èƒ½ä¼šè¢«æ¨å¯¼ä¸ºåšå·¦å€¼å¼•ç”¨ã€‚int x = 1;\nint& lref = x;\nint&& rref = 1;\nauto&& y = lref;\nauto&& z = std::move(rref);\nauto& yy = lref;\nconst auto& zz = std::move(rref);\nstatic_assert(is_same_v<decltype(y), int&>);\nstatic_assert(is_same_v<decltype(z), int&&>);\nstatic_assert(is_same_v<decltype(yy), int&>);\nstatic_assert(is_same_v<decltype(zz), const int&>); ä¸  æœ¬è´¨å°±æ˜¯æ— æ¡ä»¶è½¬æ¢æˆå³å€¼å¼•ç”¨ï¼Œ æ˜¯æœ‰æ¡ä»¶çš„ç±»å‹è½¬æ¢ï¼šå¦‚æœ  æ˜¯å³å€¼å¼•ç”¨ç±»å‹ï¼Œå‡½æ•°è¡¨è¾¾å¼ä¸ºå³å€¼å¦åˆ™  ä¸ºå·¦å€¼å¼•ç”¨ç±»å‹æˆ–éå¼•ç”¨ç±»å‹ï¼Œå‡½æ•°è¡¨è¾¾å¼ä¸ºå·¦å€¼æ³¨æ„æˆ‘ä»¬ä¸èƒ½é€šè¿‡ç®€å•çš„èµ‹å€¼æ¥å®ç°å³å€¼å¼•ç”¨çš„è½¬å‘ï¼Œå³ï¼švoid foo(int&& x) {}\n\nvoid bar(int&& x) {\n    foo(x);\n}ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸ºåœ¨  ä¸­ï¼Œè¡¨è¾¾å¼  æ˜¯å·¦å€¼ï¼Œä¸èƒ½ä½œä¸º  çš„å‚æ•°ã€‚"},{"id":"software-misc","title":"è½¯ä»¶æ‚é¡¹","content":"ç”¨cueæ–‡ä»¶åˆ†å‰²flacå¹¶æ ‡è®°shnsplit -f <cuefile> -t %n-%t -o flac <flacfile>\ncuetag <cuefile> *.flac"},{"id":"switch-to-hello-friend","title":"è®°åˆä¸€æ¬¡ç»™åšå®¢æ¢ä¸»é¢˜","content":"é¬¼çŸ¥é“æˆ‘å·²ç»æ¢äº†å¤šå°‘æ¬¡ä¸»é¢˜äº†ã€‚ã€‚ã€‚å¤§æ¦‚æ¯è¿‡ä¸€é˜µå­æˆ‘å°±ä¼šè¢«æŸä¸ªæç®€çš„ç½‘ç«™åˆºæ¿€ä¸€ä¸‹ï¼Œè¿™æ¬¡æ˜¯è¿™ä¸ªï¼ŒçœŸçš„å¥½å–œæ¬¢ç™½çº¸é»‘å­—çš„æ„Ÿè§‰ï¼Œå†åŠ ä¸Šå…¶å®ä¹Ÿä¸æ˜¯å¾ˆå–œæ¬¢ä¹‹å‰ç”¨çš„ wowchemyï¼Œè™½è¯´æ¯”è¾ƒç®€æ´äº†ä½†æ€»æ„Ÿè§‰å“ªä¸å¯¹åŠ²ï¼ˆä¸‘çš„ä¸€æ‰¹çš„çº¢è‰²è¡Œå†…ä»£ç å­—ä½“å°±æ˜¯ä¹‹ä¸€ï¼Œæƒ³æ”¹å‘ç°ä¸ç”¨è¿˜ä¸è¡Œï¼‰ï¼Œéš§æœæ–­å†³å®šæ¢ä¸»é¢˜ã€‚æœ¬æ¥æƒ³è‡ªå·±ä»å¤´åšä¸€ä¸ªæ¨¡ä»¿è¿™ä¸ªçš„ä¸»é¢˜ï¼Œä½†çœ‹äº†1ä¸ªå°æ—¶Hugoæ–‡æ¡£ä¹‹åæ„Ÿè§‰è¿˜æ˜¯æä¸å¤ªæ˜ç™½å°±æ”¾å¼ƒäº†ï¼Œå¹¸å¥½æ‰¾åˆ°è¿™ä¸ªï¼Œçœ‹èµ·æ¥å°±å¾ˆèˆ’æœï¼Œè€Œä¸”å¯ä»¥å†™é¦–é¡µçš„å†…å®¹äºæ˜¯ä¹Ÿå°±èµ·åˆ°äº† portfolio çš„æ•ˆæœã€‚è¿™æ¬¡æ¬è¿èŠ±çš„æ—¶é—´å°¤å…¶é•¿ï¼Œä¸»è¦ç”¨åœ¨åšæ–°çš„ä¸œè¥¿ä¸Šï¼ŒåŠ äº†å¦‚ä¸‹æ–°ç‰¹æ€§ï¼šæ ·å¼æ”¹åŠ¨è¯­è¨€åˆ‡æ¢èœå•ï¼ˆå¼„äº†å¥½ä¹…ï¼Œå‰ç«¯èœé¸¡çš„ç—›ï¼‰Katexè¯„è®ºç³»ç»Ÿä»£ç é«˜é‡äº®è‰²ä¸æš—è‰²ä¸»é¢˜Tabler iconæ”¯æŒå¸Œæœ›è¿™æ¬¡èƒ½å¤šç”¨ä¸€æ®µæ—¶é—´ã€‚ã€‚ã€‚"},{"id":"tarjan-lowlink","title":"å…³äºTarjanç®—æ³•ä¸­çš„low linkçš„å¦ç±»å®šä¹‰ä¸æ›´æ–°","content":"Tarjançš„è®ºæ–‡ä¸­æŒ‡å‡ºLOWLINK(v) is the smallest vertex which is in the same component as v and is reachable by traversing zero or more tree arcs followed by at most one [back edge] or [cross edge].ä¹Ÿå°±æ˜¯è¯´uçš„lowlinkæ˜¯åœ¨dfsæ ‘ä¸­uçš„å­æ ‘ä¸­çš„èŠ‚ç‚¹ç»è¿‡æœ€å¤šä¸€æ¡è¿”ç¥–è¾¹ï¼ˆback edge,ä¹Ÿå«åå‘è¾¹ï¼‰èƒ½åˆ°è¾¾æœ€ä½çš„dfsåºã€‚æ‰€ä»¥åœ¨dfsçš„æ—¶å€™å¯¹äºå·²è®¿é—®å’Œæœªè®¿é—®çš„èŠ‚ç‚¹è¦ç”¨ä¸åŒçš„æ›´æ–°ï¼šå¯¹äºæœªè®¿é—®çš„èŠ‚ç‚¹væˆ‘ä»¬ç”¨ï¼Œå¯¹äºè®¿é—®è¿‡çš„èŠ‚vç‚¹ç”¨ã€‚ä½†è¿™æ ·ä¹Ÿè®¸æœ‰ä¸€ç‚¹éº»çƒ¦ï¼Œå¢åŠ äº†è®°å¿†éš¾åº¦ï¼Œä¸€ä¸å°å¿ƒä¹Ÿå¯èƒ½å†™é”™ã€‚å¦‚æœæˆ‘ä»¬ç¨å¾®ä¿®æ”¹ä¸€ä¸‹å®šä¹‰ï¼Œå¿½ç•¥è¿”ç¥–è¾¹çš„æ•°é‡é™åˆ¶ï¼Œå¾—åˆ°çš„ç®—æ³•ä¾ç„¶æ˜¯å¯¹çš„ï¼å› ä¸ºæˆ‘ä»¬åªå…³å¿ƒlowlinkæ˜¯å¦æ˜¯uçš„ç¥–å…ˆï¼Œè‡³äºå“ªä¸ªç¥–å…ˆæ— æ‰€è°“ã€‚æ‰€ä»¥è¿™ç§å®šä¹‰åœ¨ä¿è¯æ­£ç¡®æ€§çš„åŒæ—¶ç®€åŒ–äº†ä»£ç ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ã€‚ä»£ç è§æ­¤"},{"id":"tarjans-algorithm","title":"Tarjanç®—æ³•ï¼ˆå¼ºè¿é€šï¼Œå‰²ç‚¹ï¼Œæ¡¥ï¼‰å¯¹æ¯”æ€»ç»“","content":"Tarjanç®—æ³•ä¸­å®šä¹‰äº†ä¸¤ä¸ªæ•°ç»„ï¼š: èŠ‚ç‚¹uçš„å‰åºéå†ç¼–å·ï¼Œå¦‚æœæ˜¯æœ‰å‘å›¾è¿˜è¦è§„å®šåœ¨åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„ä¸Šï¼Œæ— å‘å›¾ä¸ç”¨è¿™ä¸ªæ˜¯å› ä¸ºæ— å‘å›¾ä¸­çš„åå‘è¾¹ä¸€å®šæŒ‡å‘åˆ°æ ¹èŠ‚ç‚¹è·¯å¾„ä¸­çš„æŸä¸€ä¸ªç‚¹ã€‚æ¢è¨€ä¹‹ï¼Œå°±æ˜¯çš„å­æ ‘ä¸­çš„èŠ‚ç‚¹ç»è¿‡æœ€å¤šä¸€æ¡åå‘è¾¹èƒ½åˆ°è¾¾èŠ‚ç‚¹çš„æœ€å°å€¼ã€‚åœ¨å¼ºè¿é€šåˆ†é‡ä»¥åŠç‚¹åŒè¿é€šåˆ†é‡ç®—æ³•ä¸­ï¼Œè¿˜è¦åœ¨éå†çš„æ—¶å€™ç”¨ä¸€ä¸ªæ ˆç»´æŠ¤éå†è¿‡çš„èŠ‚ç‚¹ï¼Œåœ¨ç‰¹å®šçš„æ—¶å€™å°†æ ˆä¸­çš„æŸäº›èŠ‚ç‚¹å¼¹å‡ºå½¢æˆæ‰€å¯¹åº”çš„åˆ†é‡ã€‚å¼ºè¿é€šåˆ†é‡å½“æ—¶ï¼Œå°†ä»¥åŠä¹‹åçš„èŠ‚ç‚¹å¼¹å‡ºï¼Œè¿™äº›èŠ‚ç‚¹å±äºåŒä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ã€‚å‰²ç‚¹ä¸ç‚¹åŒè¿é€šåˆ†é‡å‰²ç‚¹ä¸ç‚¹åŒè¿é€šåˆ†é‡ä¸ªå…³ç³»ï¼šä¸€ä¸ªå‰²ç‚¹ä¼šå±äºå¤šä¸ªç‚¹åŒè¿é€šåˆ†é‡ï¼Œä¸”ä¸¤ä¸ªç‚¹åŒè¿é€šåˆ†é‡çš„äº¤é›†ä¸­æœ€å¤šåªæœ‰ä¸€ä¸ªç‚¹ã€‚å½“(ä¸ºåœ¨dfsæ ‘ä¸­çš„ä¸€ä¸ªç›´æ¥å„¿å­)æ—¶ï¼Œå·²ç»ä¹‹åçš„èŠ‚ç‚¹å±äºåŒä¸€ä¸ªç‚¹åŒè¿é€šåˆ†é‡ï¼Œå°†ä»¥åŠä¹‹åçš„èŠ‚ç‚¹å¼¹å‡ºã€‚å¦‚æœå±äºè‡³å°‘ä¸¤ä¸ªç‚¹åŒè¿é€šåˆ†é‡åˆ™ä¸ºå‰²ç‚¹ã€‚æ¡¥ä¸è¾¹åŒè¿é€šåˆ†é‡æ¡¥ä¸è¾¹åŒè¿é€šåˆ†é‡çš„å…³ç³»ï¼šæ¡¥å°†å›¾åˆ†å‰²ä¸ºè¾¹åŒè¿é€šåˆ†é‡ï¼Œå³ä¸€æ¡è¾¹ä¸ºæ¡¥å½“ä¸”ä»…å½“è¾¹çš„ä¸¤ç«¯å±äºä¸åŒçš„åˆ†é‡ã€‚ä¸€æ¡è¾¹ä¸ºæ¡¥å½“ä¸”ä»…å½“ã€‚æ¾å¼›lowæ•°ç»„å®šä¹‰åœ¨å¼ºè¿é€šåˆ†é‡ä»¥åŠè¾¹åŒè¿é€šåˆ†é‡ä¸­ï¼Œå»æ‰æ•°ç»„ä¸­æœ€å¤šä¸€æ¡åå‘è¾¹çš„é™åˆ¶å¹¶ä¸ä¼šå½±å“ç®—æ³•çš„æ­£ç¡®æ€§ï¼Œè€Œä¸”å¯ä»¥ç®€åŒ–ç¼–ç å’Œè®°å¿†éš¾åº¦ã€‚å‡è®¾å­˜åœ¨ä¸€ä¸ªç‚¹ï¼Œå…¶ä¸¤ç§å®šä¹‰çš„ä¸åŒï¼Œä¹Ÿå°±æ˜¯è¯´æ‰€å¯¹åº”çš„èŠ‚ç‚¹å¤„è¿˜æœ‰ä¸€æ¡åå‘è¾¹ï¼Œè®¾è¯¥åå‘è¾¹çš„å¦ä¸€èŠ‚ç‚¹ä¸ºã€‚ç”±äºè€ƒè™‘ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼šæƒ…å†µ1ï¼šï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆ©ç”¨çš„åå‘è¾¹å¾—åˆ°æ›´å°çš„ï¼Œä¸çš„å®šä¹‰çŸ›ç›¾ã€‚æƒ…å†µ2ï¼šï¼Œæ¾å¼›å®šä¹‰ä¹‹åä¾ç„¶å°äºï¼Œè¿™å¹¶ä¸å½±å“ä¸¤ä¸ªç®—æ³•çš„åˆ¤å®šã€‚ä¹Ÿå°±æ˜¯è¯´å½“ä¸”ä»…å½“æ—¶ï¼Œä¸¤ç§å®šä¹‰çš„æ‰ä¼šä¸åŒã€‚åœ¨å¼ºè¿é€šåˆ†é‡ä¸­ï¼Œè¿™ç§æƒ…å†µä¸ä¼šå½±å“æ¡ä»¶çš„åˆ¤å®šã€‚åœ¨è¾¹åŒè¿é€šåˆ†é‡ä¸­ï¼Œå½“æ—¶ï¼Œï¼ˆå› ä¸ºæ˜¯åˆ°æ ¹èŠ‚ç‚¹è·¯å¾„ä¸Šå€¼æœ€å¤§çš„èŠ‚ç‚¹ï¼‰æ‰€ä»¥è¾¹å·²ç»æ˜¯æ¡¥äº†ï¼Œä¸ä¼šå½±å“åˆ¤å®šã€‚ç„¶è€Œï¼Œåœ¨ç‚¹åŒè¿é€šåˆ†é‡ä¸­ï¼Œå½“æ—¶ï¼Œå¦‚æœå¤„æœ‰åå‘è¾¹ï¼Œæ¾å¼›å®šä¹‰ä¹‹åï¼Œä½¿å¾—å‰åä¸¤ç§åˆ¤å®šç»“æœä¸ä¸€è‡´å¯¼è‡´ç®—æ³•çš„æ­£ç¡®æ€§æ— æ³•å¾—åˆ°ä¿è¯ã€‚"},{"id":"tree-path-technique","title":"æ ‘ä¸Šè·¯å¾„æŠ€å·§","content":"æ±‚uåˆ°vè·¯å¾„çš„ç¬¬äºŒä¸ªèŠ‚ç‚¹å‡ºå¤„å¦‚æœvä¸åœ¨uçš„å­æ ‘é‡Œï¼Œæ˜¾ç„¶ç¬¬äºŒä¸ªèŠ‚ç‚¹æ˜¯uçš„çˆ¶äº²ï¼Œå½“våœ¨uçš„å­æ ‘é‡Œæ—¶ï¼Œæœ‰ä»¥ä¸‹ä¸¤ç§åšæ³•ï¼šä»¥dfså‰åºéå†çš„é¡ºåºå»ºstè¡¨ï¼Œæ¯”è¾ƒæ—¶å–æ·±åº¦è¾ƒå°çš„ç‚¹ï¼Œå¦‚æœæ·±åº¦ç›¸åŒåˆ™å–dfsåºè¾ƒå¤§çš„ç‚¹ï¼Œç¬¬äºŒä¸ªèŠ‚ç‚¹å³ä¸ºåŒºé—´çš„å€¼ã€‚ç¬¬äºŒä¸ªèŠ‚ç‚¹æ˜¯å€¼å°äºç­‰äºçš„èŠ‚ç‚¹ä¸­å€¼æœ€å¤§çš„èŠ‚ç‚¹ï¼Œç”¨äºŒåˆ†å³å¯ã€‚ä»£ç ï¼šint next_vertex_in_path(int u, int v) {\n    int l = 0, r = (int)size(g[u]) - 1;\n    while (l < r) {\n        int mid = (l + r) / 2;\n        if (pre[g[u][mid]] <= pre[v]) {\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return g[u][l];\n}O(1)è¯¢é—®è·¯å¾„æœ€å¤§å€¼æ„é€ Kruskalé‡æ„æ ‘ï¼Œè·¯å¾„ä¸­æƒå€¼æœ€å¤§çš„è¾¹å³ä¸ºé‡æ„æ ‘ä¸­uä¸vçš„lcaæ‰€ä»£è¡¨çš„è¾¹ã€‚"},{"id":"update-2022-04-26","title":"ä¸€äº›æ›´æ–°","content":"å¥½ä¹…æ²¡å†™ä¸œè¥¿äº†ï¼Œè€ƒè¯•ä¹ŸåŸºæœ¬å®Œäº‹äº†ï¼Œå¤§æ¦‚è¯´ä¸€ä¸‹æœ€è¿‘çš„ä¸€äº›å˜åŒ–ï¼Œä¸»è¦å°±ä¸¤ä¸ªï¼š1. åšå®¢æ¢äº†ä¸ªä¸»é¢˜ï¼Œä¸»è¦æ˜¯æƒ³å§portfolioå’Œåšå®¢åˆå¹¶åˆ°ä¸€ä¸ªç½‘ç«™ä¸Šï¼Œè€Œä¹‹å‰é‚£ä¸ªä¸»é¢˜æ‰©å±•æ€§å¤ªå·®äº†ï¼Œè€Œä¸”è‡ªå·±åˆä¸å†™å‰ç«¯ä»£ç ï¼Œäºæ˜¯ç ”ç©¶äº†å…¶ä»–å„ç§è§£å†³æ–¹æ¡ˆã€‚å…¶å®notionæˆ‘è¿˜æŒºå–œæ¬¢çš„ï¼Œå¯æƒœä¸å¼€æºè€Œä¸”æ²¡æ³•å¯¼å‡ºæ•°æ®ã€‚Ghostçœ‹èµ·æ¥ä¸é”™ä½†åˆå¢åŠ æ–°çš„å­¦ä¹ æˆæœ¬ï¼Œè€Œä¸”æ„Ÿè§‰æ˜¯ç”¨æ¥åšè®¢é˜…æœåŠ¡çš„ã€‚æœ€åè¿˜æ˜¯å†³å®šç»§ç»­hugoï¼Œwowchemyçœ‹èµ·æ¥ä¸é”™ï¼Œæ‰©å±•æ€§å’Œå®šåˆ¶æ€§å…¼å…·ã€‚2. å‰æ®µæ—¶é—´å¼„äº†ä¸ªwikiå•ç‹¬è®°å½•ä¸€äº›ä»¥åå¯èƒ½ä¼šç»å¸¸æŸ¥é˜…çš„ä¸œè¥¿ï¼Œè¦æ˜¯å‘åœ¨åšå®¢é‡Œå°±ä¼šåˆ†æ•£åœ¨å„ä¸ªåœ°æ–¹ä¸æ–¹ä¾¿æ£€ç´¢ã€‚é“¾æ¥å°±åœ¨èœå•æ ä¸Šã€‚"},{"id":"vertex-cover","title":"ç‚¹è¦†ç›–ï¼Œç‹¬ç«‹é›†ï¼Œä»¥åŠå›¢çš„å…³ç³»","content":"ç‚¹è¦†ç›–çš„è¡¥é›†æ˜¯ç‹¬ç«‹é›†ï¼Œå› ä¸ºåœ¨ç‚¹è¦†ç›–ä¸­ï¼Œä»»æ„ä¸€æ¡è¾¹éƒ½è¢«è‡³å°‘é€‰äº†ä¸€ä¸ªé¡¶ç‚¹ï¼Œæ‰€ä»¥å¯¹äºå…¶ç‚¹é›†çš„è¡¥é›†ï¼Œä»»æ„ä¸€æ¡è¾¹éƒ½è¢«è‡³å¤šé€‰äº†ä¸€ä¸ªé¡¶ç‚¹ï¼Œæ‰€ä»¥ä¸å­˜åœ¨è¾¹è¿æ¥ä¸¤ä¸ªç‚¹é›†ä¸­çš„ç‚¹ã€‚æ‰€ä»¥æœ€å°ç‚¹è¦†ç›–æ˜¯æœ€å¤§ç‹¬ç«‹é›†ç‚¹è¡¥é›†ã€‚ç‹¬ç«‹é›†æ˜¯è¡¥å›¾ä¸­çš„ä¸€ä¸ªå›¢ï¼Œè¿™ä¸ªæ˜¾è€Œæ˜“è§ã€‚æ‰€ä»¥æœ€å¤§ç‹¬ç«‹é›†æ˜¯è¡¥å›¾ä¸­çš„æœ€å¤§å›¢ã€‚ä¸‹é¢ä»‹ç»ä¸€ç§åœ¨  æ—¶é—´æ±‚æœ€å¤§å›¢çš„åšæ³•ã€‚è€ƒè™‘å¦‚ä¸‹æš´åŠ›åšæ³•ï¼šè®¾  è¿”å›ç‚¹é›†  èƒ½æ„æˆç‚¹æœ€å¤§å›¢ï¼Œæˆ‘ä»¬æ‰¾åˆ°  ä¸­æ ‡å·æœ€å°çš„ç‚¹ ï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼š ä¸åœ¨æœ€å¤§å›¢é‡Œï¼Œæ­¤æ—¶æˆ‘ä»¬æŠŠ  ä»  ä¸­é™¤å»ï¼Œè°ƒç”¨  åœ¨æœ€å¤§å›¢é‡Œï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬åªéœ€è€ƒè™‘å’Œ  ç›¸é‚»çš„ç‚¹ï¼Œè°ƒç”¨ ï¼Œå…¶ä¸­  æ˜¯ä¸  ç›¸é‚»çš„ç‚¹çš„é›†åˆã€‚ å³è¿”å›ä»¥ä¸Šä¸¤ç§æƒ…å†µçš„æœ€å¤§å€¼ã€‚ä»¥ä¸Šæš´åŠ›åšæ³•æ˜¾ç„¶æ˜¯  çš„ï¼Œä½†å¦‚æœæˆ‘ä»¬åŠ å…¥è®°å¿†åŒ–ï¼Œä»¥ä¸Šåšæ³•å°±ä¼šç¥å¥‡çš„å˜æˆ ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿè€ƒè™‘é€’å½’æ ‘ä»¥åŠæ‰€æœ‰ä¸åŒ…å«å‰  ä¸ªé¡¶ç‚¹çš„é›†åˆï¼Œå› ä¸ºæ¯ä¸€æ¬¡é€’å½’è°ƒç”¨çš„é›†åˆå¤§å°è‡³å°‘å‡ä¸€ï¼Œæ‰€ä»¥é€’å½’æ ‘ä¼šåœ¨è‡³å¤š  å±‚è®¡ç®—è¿™äº›é›†åˆï¼Œç¬¬ä¸€æ¬¡è®¡ç®—è¿™äº›é›†åˆæ€»å…±ç”¨çš„æ—¶é—´ä¸º ï¼Œä¹‹åä¼šç›´æ¥è¿”å›ï¼Œè€Œé€’å½’æ ‘å‰  å±‚æœ‰  ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¸¤éƒ¨åˆ†åŠ èµ·æ¥æ—¶é—´ä¾ç„¶æ˜¯ ã€‚ä»£ç ï¼šstatic long long max_clique(const std::vector<long long>& g, const std::vector<int>& cost) {\n    int n = (int)size(g);\n\n    std::map<long long, long long> memo{{0, 0}};\n    auto solve = [&](auto& slf, long long mask) {\n        if (memo.count(mask)) {\n            return memo[mask];\n        }\n        int first = __builtin_ctzll(mask);\n        return memo[mask] = std::max(slf(slf, mask ^ (1LL << first)), \n                g[first] >> first & 1 ? slf(slf, (mask & g[first]) ^ 1LL << first) + cost[first] : 0);\n    };\n    return solve(solve, (1LL << n) - 1);\n}æ³¨æ„ï¼šåœ¨è¿™ä¸ªå®ç°é‡Œæˆ‘ä»¬å¼ºåˆ¶æ¯ä¸ªå›¢ä¸­çš„æ¯ä¸ªé¡¶ç‚¹éƒ½åŒ…å«è‡ªç¯ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æ­£ç¡®æ±‚è§£å«è‡ªç¯çš„å›¾çš„æœ€å°ç‚¹è¦†ç›–/æœ€å¤§ç‹¬ç«‹é›†é—®é¢˜ã€‚ä¾‹é¢˜ï¼šCF1105E. Helping Hiasat ï¼ˆæœ€å¤§ç‹¬ç«‹é›†ï¼‰CF1767E. Algebra Flash ï¼ˆæœ€å°æƒç‚¹è¦†ç›–ï¼‰"},{"id":"wezterm","title":"WezTerm æŠ˜è…¾è®°å½•","content":"æœ€è¿‘æŠŠç»ˆç«¯æ¨¡æ‹Ÿå™¨ä» Kitty æ¢æˆäº† WezTermï¼Œä¸»è¦æ˜¯å› ä¸º WezTerm æœ‰éšç³»ç»Ÿè‡ªåŠ¨åˆ‡æ¢æ·±è‰²ä¸»é¢˜çš„èƒ½åŠ›ã€‚ä½œä¸ºä¸€ä¸ªç™½å¤©ç”¨äº®è‰²ä¸»é¢˜æ™šä¸Šç”¨æš—è‰²ä¸»é¢˜çš„äººï¼Œç»ˆç«¯ä¸»é¢˜çš„åˆ‡æ¢ä¸€ç›´æ˜¯ä¸€å¤§ç—›ç‚¹ï¼ˆè™½è¯´å¯ä»¥é€šè¿‡ä¸€ä¸ªç®€å•çš„è„šæœ¬æ‰‹åŠ¨åˆ‡æ¢ï¼Œä½†è¿˜æ˜¯æœ‰ç‚¹éº»çƒ¦ï¼Œä¸å¤Ÿä¼˜é›…ï¼‰ï¼Œçœ‹åˆ° WezTerm æœ‰è¿™ä¸ªèƒ½åŠ›ä¹‹åæœæ–­æ¢æˆäº† WezTermã€‚ä¸»é¢˜éšç³»ç»Ÿè‡ªåŠ¨åˆ‡æ¢å’Œæ˜¯ä¸¤ä¸ªtableï¼Œå…¶ä¸­åŒ…å«å’Œã€‚æ³¨æ„ä¹Ÿä¼šå†æ¬¡è§¦å‘äº‹ä»¶ï¼Œæ‰€ä»¥ä¸€å®šè¦åœ¨å½“å‰ä¸»é¢˜éœ€è¦æ”¹å˜çš„æ—¶å€™æ‰è°ƒç”¨ï¼Œä¸ç„¶ä¼šæ­»å¾ªç¯ã€‚local function get_color()\n    local appearance = wezterm.gui.get_appearance()\n    if appearance:find 'Dark' then\n        return tokyonight_storm\n    else\n        return tokyonight_day\n    end\nend\n\nwezterm.on('window-config-reloaded', function (window, pane)\n    local overrides = window:get_config_overrides() or {}\n    local target = get_color()\n    if overrides.colors ~= target.colors then\n        overrides.colors = target.colors\n        overrides.window_frame = target.window_frame\n        window:set_config_overrides(overrides)\n    end\nend)æ­£å¸¸æ¸²æŸ“Neovimä¸­çš„æ³¢æµªçº¿è¯¦è§å®˜æ–¹æ–‡æ¡£ä¸­çš„F.A.Q.tempfile=$(mktemp) \\\n  && curl -o $tempfile https://raw.githubusercontent.com/wez/wezterm/master/termwiz/data/wezterm.terminfo \\\n  && tic -x -o ~/.terminfo $tempfile \\\n  && rm $tempfileç„¶åè®¾ç½®ç¯å¢ƒå˜é‡ã€‚"},{"id":"wildcard-ssl","title":"é€šé…ç¬¦SSLè¯ä¹¦","content":"å®‰è£…certbotå®˜æ–¹ç½‘é¡µä¸Šè¯´ç”¨snapï¼ˆè™½è¯´æˆ‘ä¸æ˜¯å¾ˆå–œæ¬¢snapï¼‰ï¼šsudo snap install --classic certbotå®‰è£…å®Œè¿˜éœ€è¦è¿™ä¸¤æ¡å‘½ä»¤:sudo ln -s /snap/bin/certbot /usr/bin/certbot\nsudo snap set certbot trust-plugin-with-root=okè·å–è¯ä¹¦ä¸ºäº†è·å¾—é€šé…SSLè¯ä¹¦ï¼Œä½ å¿…é¡»å±•ç¤ºå‡ºå¯¹åŸŸåçš„æ‰€æœ‰æƒï¼Œå¸¸è§çš„åšæ³•æ˜¯DNSè®°å½•æŒ‘æˆ˜ï¼ˆå³è®¾å®šæŒ‡å®šçš„TXTè®°å½•ï¼‰ã€‚æŒ‘æˆ˜å¯ä»¥æ‰‹åŠ¨å®Œæˆï¼Œä¹Ÿå¯ä»¥é€šè¿‡DNSæ’ä»¶è‡ªåŠ¨å®Œæˆï¼ˆæ¨èï¼‰ã€‚DNSæ’ä»¶DNSæ’ä»¶çš„ä½œç”¨åœ¨äºå¯ä»¥è‡ªåŠ¨è¯æŒ‘æˆ˜è¿‡ç¨‹ï¼Œæ‰€ä»¥ä¹Ÿå°±å¯ä»¥å®ç°è¯ä¹¦è‡ªåŠ¨ç»­æœŸã€‚åœ¨æ­¤æŸ¥çœ‹æ‰€æœ‰æ”¯æŒçš„dnsæä¾›å•†ï¼Œå¦‚æœä¸æ”¯æŒçš„è¯å°±åªèƒ½æ‰‹åŠ¨éªŒè¯äº†ã€‚ä¸‹é¢ä»¥cloudflareä¸¾ä¾‹ï¼Œå…¶ä»–DNSæä¾›å•†åªè¦æŠŠä¸‹é¢å‡ºç°çš„cloudflareå•è¯æ›¿æ¢æˆå¯¹åº”çš„åå­—å°±å¥½ã€‚å®‰è£…æ’ä»¶sudo snap install certbot-dns-cloudflareè·å–APIä»¤ç‰Œï¼ˆä»¥cloudflareä¸ºä¾‹ï¼‰åˆ° https://dash.cloudflare.com/profile/api-tokensï¼Œç‚¹ã€ŒAPIä»¤ç‰Œã€-> ã€Œç¼–è¾‘åŒºåŸŸ DNSã€ï¼Œé€‰æ‹©åŸŸåï¼Œã€Œç»§ç»­ä»¥æ˜¾ç¤ºæ‘˜è¦ã€ï¼Œã€Œåˆ›å»ºä»¤ç‰Œã€ï¼Œå¤åˆ¶ç”Ÿæˆçš„ä»¤ç‰Œã€‚é…ç½®æ’ä»¶å°†ä¸Šä¸€æ­¥çš„ä»¤ç‰Œæ”¾åˆ°ä¸€ä¸ªiniæ–‡ä»¶ä¸­ï¼ˆæ¯”å¦‚~/certbot-creds.iniï¼‰ï¼Œæ ¼å¼å¦‚ä¸‹ï¼šdns_cloudflare_token = <your token>ä¿®æ”¹æ–‡ä»¶æƒé™chmod 600 ~/certbot-creds.iniç”³è¯·è¯ä¹¦sudo certbot certonly \\\n  --dns-cloudflare \\\n  --dns-cloudflare-credentials ~/certbot-creds.ini \\\n  -d '*.example.com'æ‰‹åŠ¨éªŒè¯sudo certbot certonly --manual -d '*.example.com' --agree-tos --no-bootstrap --manual-public-ip-logging-ok --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directoryç„¶åæ ¹æ®æç¤ºå®ŒæˆæŒ‘æˆ˜å³å¯ã€‚æŸ¥çœ‹è¯ä¹¦sudo certbot certificatesæµ‹è¯•è‡ªåŠ¨ç»­æœŸsudo certbot renew --dry-runå‚è€ƒèµ„æ–™ï¼šhttps://certbot.eff.org/instructions?ws=apache&os=ubuntufocalhttps://www.digitalocean.com/community/tutorials/how-to-create-let-s-encrypt-wildcard-certificates-with-certbot"},{"id":"york2tutr","title":"York University programming contest 2 é¢˜è§£","content":"è¿˜ç®—é¡ºåˆ©çš„ä¸€åœºé¢˜ç›®é“¾æ¥A - 3D Printed Statuesé¢˜æ„ï¼š ä½ æœ‰1ä¸ª3Dæ‰“å°æœºï¼Œæ‰“å°æœºæ¯å¤©å¯ä»¥æ‰“å°å‡º1ä¸ªæ‰“å°æœºæˆ–è€…1ä¸ªé›•å¡‘ï¼Œä½ éœ€è¦æ‰“å°å‡ºnä¸ªé›•å¡‘ï¼Œé—®æœ€å°‘éœ€è¦å‡ å¤©ã€‚æ€è·¯ï¼š ä¸éš¾æƒ³å‡ºï¼Œåªç”¨ä¸€å¤©æ‰“å°é›•å¡‘å°±å¤Ÿäº†ï¼Œå› ä¸ºå¦‚æœè¦éœ€è¦æ›´å¤šçš„å¤©æ•°ï¼Œä¸å¦‚å…ˆæ‰“å°æ‰“å°æœºç„¶åå†æ‰“å°é›•å¡‘ï¼Œæ‰€ä»¥æ€è·¯å°±æ˜¯ä¸€å¼€å§‹ç–¯ç‹‚æ‰“å°æ‰“å°æœºç›´åˆ°æ‰“å°ä¸ªæ•°å¤§äºç­‰äºnï¼Œç„¶åå¤©æ•°åŠ ä¸€ã€‚B - Digital displayé¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªæ—¶é—´ï¼Œç”¨7æ®µæ˜¾ç¤ºçš„æ–¹å¼è¾“å‡ºï¼ˆæ ¼å¼çœ‹é¢˜ç›®å°±è¡Œï¼‰æ€è·¯ï¼š å½“æ—¶å†™éº»çƒ¦äº†ï¼Œå…¶å®å¯ä»¥æŠŠç«¯ç‚¹å’Œä¸­é—´çš„çº¿åˆèµ·æ¥å†™æˆä¸€ä¸ªå‡½æ•°çš„ï¼Œè¿™æ ·å°±åªç”¨å†™ç”»æ¨ªç€å’Œç«–ç€çš„çº¿çš„å‡½æ•°ï¼Œç”¨äºŒç»´æ•°ç»„å­˜æ•´ä¸ªå›¾æ¡ˆï¼Œæ ¹æ®æ•°å­—å’Œç¬¬å‡ ä½æ•°ç¡®å®šæ¨ªçº¿å’Œç«–çº¿çš„èµ·ç‚¹åæ ‡ï¼Œè°ƒç”¨å¯¹åº”çš„ç”»çº¿å‡½æ•°å°±è¡Œäº†ã€‚æœ€å‘çš„æ˜¯è¿™ä¸ªojæ²¡æœ‰æ ¼å¼é”™è¯¯ï¼Œå½“æ—¶å°‘äº†ä¸€ä¸ªç©ºè¡Œå´ä»¥ä¸ºæ˜¯åˆ«çš„é”™ï¼Œwaäº†å¥½å‡ å‘â€¦â€¦è¿™ä¸ªé¢˜è€½è¯¯äº†è´¼é•¿æ—¶é—´ã€‚C - Eight Queensé¢˜æ„ï¼š ç»™å‡ºä¸€ä¸ªæ£‹ç›˜ï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯åˆæ³•çš„å…«çš‡åæ”¾æ³•ã€‚æ€è·¯ï¼š éå†æ£‹ç›˜ï¼Œç¢°åˆ°çš‡åå°±è¿›è¡Œåˆ¤æ–­å…¶4ä¸ªæ–¹å‘ä¸Šæœ‰æ²¡æœ‰åˆ«çš„çš‡åã€‚ä½†æ˜¯é¢˜ç›®é‡Œæœ‰ä¸€ç‚¹æ²¡è¯´å°±æ˜¯çš‡åçš„æ•°é‡å¯èƒ½ä¸ä¸º8ï¼Œè¿˜å¥½waäº†ä¸€æ¬¡å°±æƒ³åˆ°è¿™ä¸ªäº†ï¼Œä¸ç„¶å¯èƒ½è¦è‡ªé—­â€¦â€¦D - Ekoé¢˜æ„ï¼š ç»™å‡ºæ£µæ ‘çš„é«˜åº¦ï¼Œä½ å¯ä»¥é€‰æ‹©æŸä¸€ä¸ªé«˜åº¦ï¼Œç„¶åæŠŠæ‰€æœ‰åœ¨æ­¤é«˜åº¦ä¹‹ä¸Šçš„æœ¨å¤´éƒ½ç æ‰ï¼Œå¯¹äºç»™å‡ºçš„å•ä½çš„æ ‘æœ¨ï¼Œæ‰¾å‡ºè‡³å°‘èƒ½è·å¾—è¿™äº›æ•°é‡çš„æœ€é«˜é«˜åº¦ã€‚æ€è·¯ï¼š å› ä¸ºéšç€é«˜åº¦ä»ä½åˆ°é«˜ï¼Œç æ‰çš„æ ‘æœ¨çš„æ•°é‡å•è°ƒé€’å¢ï¼Œæ‰€ä»¥å¯ä»¥ç”¨äºŒåˆ†æœç´¢ã€‚æ¨èä¸€ç§äºŒåˆ†çš„å†™æ³•ï¼Œå¾ˆå¥½è®°ï¼Œå¯ä»¥å¯¹ä»˜å„ç§ç±»å‹çš„äºŒåˆ†ã€‚ä»£ç #include <bits/stdc++.h>\r\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\r\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\r\n#define fore(i, a, b) for (int i = int(a); i <= b; ++i)\r\n#define ms(a, x) memset(a, x, sizeof(a));\r\ntypedef long long ll;\r\nusing namespace std;\r\nconst int N = 1e6 + 5;\r\nll a[N];\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(0);\r\n    ll n, m;\r\n    cin >> n >> m;\r\n    ll r = 0;\r\n    forn(i, n) {\r\n        cin >> a[i];\r\n        r = max(a[i], r);\r\n    }\r\n    ll l = 0;\r\n    while (l <= r) {\r\n        ll tot = 0;\r\n        ll mid = (l + r) / 2;\r\n        forn(i, n) {\r\n            if (a[i] > mid) tot += a[i] - mid;\r\n        }\r\n        if (tot >= m) l = mid + 1;\r\n        else\r\n            r = mid - 1;\r\n    }\r\n    cout << r;\r\n    return 0;\r\n}E - Electioné¢˜æ„ï¼š æœ‰ä¸ªäººæŠ•ç¥¨ï¼Œå·²ç»çŸ¥é“ç¬¬ä¸€ä¸ªäººæœ‰ç¥¨ï¼Œç¬¬äºŒä¸ªäººæœ‰ç¥¨ï¼Œå·²çŸ¥æ¯ä¸ªäººæŠ•ç¥¨éƒ½æ˜¯éšæœºçš„ï¼Œåˆ¤æ–­æ˜¯ä»¥ä¸‹å“ªä¸‰ç§æƒ…å†µï¼š1ã€ç¬¬ä¸€ä¸ªäººçš„èƒœå‡ºçš„æ¦‚ç‡è¶…è¿‡, 2ã€ç¬¬ä¸€ä¸ªäººå¿…è¾“ï¼Œ3ã€å‰©ä¸‹çš„æƒ…å†µã€‚æ€è·¯ï¼š æ’åˆ—ç»„åˆçš„é—®é¢˜ï¼Œä¸€ç›´è¢«å¡åˆ°ç»“æŸï¼Œåˆ°ç¬¬äºŒå¤©æ‰å‘ç°æ˜¯ç®—ç»„åˆæ•°çš„æ—¶å€™çˆ†äº†å› ä¸ºç”¨äº†æœ€ä¸ºå¼±æ™ºçš„ç®—æ³•ã€‚ç®—æ—¶åº”ä¹˜ä¸€ä¸ªé™¤ä¸€ä¸ªï¼Œåˆ†å­çš„éƒ¨åˆ†åº”ä»å¼€å§‹ä¹˜ï¼Œåˆ†æ¯çš„éƒ¨åˆ†åº”ä»å¼€å§‹é™¤ï¼Œå¦‚æœæœ€ç»ˆç»“æœåœ¨long longä¹‹å†…çš„è¯è¿™æ ·ç®—å°±ä¸ä¼šçˆ†ã€‚è¿˜å¥½æœ€å¤šåªæœ‰50ä¸ªäººæŠ•ç¥¨ï¼Œæœ€å¤šåªæœ‰ç§æƒ…å†µã€‚ä»£ç #include <iostream>\r\ntypedef long long ll;\r\n\r\nll calc(int a, int b) {\r\n  if (a - b < b) b = a - b;\r\n  ll ans = 1;\r\n  for(int i=1,i<=b;i++) \r\n    ans = ans*(a -b+ i)/i;\r\n  return ans;\r\n}\r\n\r\nusing namespace std;\r\nint main() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(0);\r\n  int n, v1, v2, w;\r\n  int T;\r\n  cin >> T;\r\n  while (T--) {\r\n    cin >> n >> v1 >> v2 >> w;\r\n    if (n - v2 <= v2)\r\n      cout << \"RECOUNT!\\n\";\r\n    else {\r\n      ll ans = 0;\r\n      int lef = n - v1 - v2;\r\n      for (int i = 0; i <= lef; i++) {\r\n        if (v1 + i > v2 + lef - i) {\r\n          ans += calc(lef, i);\r\n        }\r\n      }\r\n      if (ans * 100.0 / (1ll << lef) > w)\r\n        cout << \"GET A CRATE OF CHAMPAGNE FROM THE BASEMENT!\\n\";\r\n      else\r\n        cout << \"PATIENCE, EVERYONE!\\n\";\r\n    }\r\n  }\r\n  return 0;"},{"id":"yorku1totr","title":"York Univeristy programming contest ç¬¬ä¸€åœºé¢˜è§£","content":"è¿™æ˜¯ä¸€åœºå…³äºèº«æ®‹å¿—åšçš„æ¯”èµ›ã€‚é‚£å¤©æ™šä¸Šåˆ‡èœæ—¶åˆ‡ç€æ‰‹äº†ï¼Œå»äº†åŒ»é™¢ï¼Œæ²¡æƒ³åˆ°æŒ‚ä¸ªæ€¥è¯Šè¿˜è¦ç­‰è¿™ä¹ˆä¹…ï¼Œå¿ƒæƒ³æ™šä¸Šçš„æ¯”èµ›è‚¯å®šæ³¡æ±¤äº†ï¼Œç­‰å¾…ä¹‹ä½™æƒ³èµ·è‡ªå·±åŒ…é‡Œè¿˜æœ‰iPadå’Œè“ç‰™é”®ç›˜ï¼Œè™½ç„¶æ¯”èµ›å·²ç»å¼€å§‹åŠå°æ—¶äº†ï¼Œè€Œä¸”è‡ªå·±åªæœ‰9æ ¹æŒ‡å¤´èƒ½ç”¨ï¼Œå°±å½“ç©ç©å§ï¼Œäºæ˜¯æˆ‘è¿ä¸Šé”®ç›˜ï¼Œæ‰“å¼€koderï¼Œåœ¨iPadä¸Šæ‰“èµ·äº†æ¯”èµ›ï¼Œæ²¡æƒ³åˆ°æœ€åå‡ºäº†ä¸‰ä¸ªé¢˜ï¼Œæ’åç¬¬ä¸‰ï¼Œæ‰‹æŒ‡å’Œæ¯”èµ›éƒ½ä¿ä½äº†â€¦â€¦é¢˜ç›®é“¾æ¥A. Cold-puter Scienceé¢˜æ„ï¼š ç»™å‡ºä¸ªæ•°é—®æœ‰å‡ ä¸ªæ•°å°äº0ã€‚æ€è·¯ï¼š è¿™å°±ä¸ç”¨è¯´äº†å§ï¼ŒåŸºæœ¬ä¸Šæ˜¯æˆ‘è§è¿‡çš„æœ€æ°´çš„ç­¾åˆ°é¢˜äº†ã€‚B. Are You Listening?é¢˜æ„ï¼š ç»™å‡ºè‡ªå·±çš„åæ ‡ä»¥åŠä¸ªæ•Œæ”¾ç›‘å¬ç‚¹çš„åæ ‡å’Œç›‘å¬åŠå¾„ï¼Œå¯¹æ–¹æœ€å°‘éœ€è¦3ä¸ªç‚¹æ¢æµ‹åˆ°ä½ æ‰èƒ½ç¡®å®šä½ çš„ä½ç½®ï¼Œé—®è‡ªå·±å¹¿æ’­çš„æœ€å¤§åŠå¾„æ˜¯å¤šå°‘ï¼ˆç­”æ¡ˆå¯èƒ½æ˜¯0ï¼Œå‘ä¸‹å–æ•´ï¼‰ã€‚æ€è·¯ï¼š è®¾ç›‘å¬ç‚¹çš„ä¸ä½ çš„è·ç¦»æ˜¯ï¼ŒåŠå¾„æ˜¯ï¼Œé‚£ä¹ˆå°±æ˜¯ä¸è¢«æ£€æµ‹åˆ°çš„æœ€å¤§å¹¿æ’­åŠå¾„ã€‚äºæ˜¯æ¯è¯»å…¥ä¸€ç»„ç›‘å¬ç‚¹çš„æ•°æ®å°±è®¡ç®—å‡ºå¹¶å­˜å…¥æ•°ç»„ä¸­ï¼Œæœ€åå¯¹æ•°ç»„æ’åºï¼Œå¦‚æœç¬¬ä¸‰ä¸ªæ•°å°äº0å°±è¾“å‡º0å¦åˆ™è¾“å‡ºå‘ä¸‹å–æ•´åçš„æ•°ã€‚C. Chewbaccaé¢˜æ„ï¼š ç»™å‡ºä¸€æ£µæœ‰ä¸ªèŠ‚ç‚¹çš„æ»¡æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰ä¸ªå­èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹çš„éœ€è¦ä»ä¸Šå¾€ä¸‹ã€ä»å·¦å¾€å³æ’åˆ—ï¼Œç»™å‡ºä¸ªè¯¢é—®ï¼Œé—®æ ‘ä¸Šä¸¤ä¸ªç‚¹çš„æœ€çŸ­è·¯å¾„çš„é•¿åº¦ã€‚æ€è·¯ï¼š å½“æ—¶æƒ³åˆ°æ˜¯æ±‚LCAäº†ï¼Œä½†å› ä¸ºæ²¡å­¦è¿‡è€Œä¸”æ’åˆ°æˆ‘äº†å°±æ²¡åšï¼Œå…¶å®è¿™é¢˜å¾ˆç®€å•ï¼Œå› ä¸ºé¢˜ç›®å¾ˆç‰¹æ®Šï¼šæ˜¯ä¸€æ£µæ»¡æ ‘å¹¶ä¸”çˆ¶äº²ä¸å„¿å­ä¹‹é—´çš„è·ç¦»æ˜¯1ï¼Œæ‰€ä»¥å¯èƒ½é‡‡ç”¨æ¯”è¾ƒæš´åŠ›çš„ç®—æ³•ï¼Œç»è¿‡å®éªŒå¯ä»¥å‘ç°ï¼šå¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„åºå·æ˜¯ï¼Œé‚£ä¹ˆå°±æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„åæ ‡ï¼Œç”±æ­¤æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ä¸æ–­é™¤å¾—åˆ°ä¸¤ä¸ªèŠ‚ç‚¹çš„æ·±åº¦(å…¶å®å¥½åƒä¹Ÿå¯ä»¥ç›´æ¥æ±‚)ï¼Œå…ˆä½¿æ·±åº¦æ¯”è¾ƒå¤§çš„èŠ‚ç‚¹è·³è½¬åˆ°æ·±åº¦æ¯”è¾ƒå°çš„èŠ‚ç‚¹çš„æ·±åº¦ï¼Œç„¶åä»¤ä¸¤ä¸ªç‚¹åŒæ—¶å‘ä¸Šè·³è½¬ç›´åˆ°é‡åˆã€‚D. Bike Gearsé¢˜æ„ï¼š ç»™å‡ºè‡ªè¡Œè½¦æ‰€æœ‰å‰å˜é€Ÿè½®å’Œåå˜é€Ÿè½®çš„é½¿æ•°ï¼Œå®šä¹‰ä¸€ç»„é½¿è½®ç»„åˆçš„gearå€¼ä¸ºå‰é½¿è½®æ•°é™¤ä»¥åé½¿è½®æ•°ï¼Œè¦æ±‚æŒ‰ç…§gearå€¼ä»å°åˆ°å¤§è¾“å‡ºæ‰€æœ‰é½¿è½®çš„ç»„åˆã€‚æ€è·¯ï¼š ç”±äºé½¿è½®æ•°å¯å¤§è‡³ï¼Œå³ä½¿æ˜¯ç”¨long doubleæ¥å­˜gearå€¼ä¹Ÿä¼šå‡ºç°ç²¾åº¦é—®é¢˜ã€‚æ‰€ä»¥åªèƒ½å­˜gearçš„æœ€ç®€åˆ†æ•°ï¼Œåœ¨æ’åºçš„æ—¶å€™ç”¨é€šåˆ†æ¥æ¯”è¾ƒï¼Œæ³¨æ„è™½ç„¶å•ä¸ªé½¿è½®çš„å€¼æ²¡æœ‰è¶…è¿‡intä½†é€šåˆ†çš„æ—¶å€™ç›¸ä¹˜å°±å¯èƒ½çˆ†ï¼Œæ‰€ä»¥è¦ç”¨long longæ¥å­˜å‚¨ã€‚è¿˜æœ‰ä¸€ç‚¹æ¯”è¾ƒå‘çš„å°±æ˜¯é¢˜ç›®é‡Œæ²¡è¯´å¦‚æœä¸¤ç»„é½¿è½®çš„gearç›¸åŒæ€ä¹ˆåŠï¼Œåªèƒ½ä»æ ·ä¾‹é‡Œæ¥æ¨æ–­æ˜¯å…ˆè¾“å‡ºå°çš„ã€‚\r\nsolution: As the number of sprockets can be as large as , even long double is not precise enough to store the number of gear. Therefore, the only way to do it is to store the simplified fraction of the gear and the numerator and denominator should be stored in long long variable in case the product exceed the int-max. Another thing to be noticed is that the sequence of two sets of sprockets with the same gear is not mentioned in the question, but as the sample suggested the sets with smaller front and back sprockets should be output first."}]