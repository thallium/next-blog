[{"id":"2018_ICPC_Singapore","title":"题解 2018 ICPC Asia Singapore Regional Contest","content":"官方英文题解A. Bitwise从高位往低位贪心，写一个函数判断能否至少得到。如何判断能否至少得到？依然是贪心的思路，我们从某一位开始，记录当前的或值，如果大于就开始新的一块。但如果从每个数都开始试一遍的话时间复杂度是。但是我们发现每个块的结束位置一定是某一位变成1的位置，所以说开始的位置其实并不重要，最多只会少算一个部分，所以如果我们遍历两圈，如果至少有个块的话就说明是可行的。#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin>>n>>k;\n    vector<int> a(n*2);\n    for (int i=0; i<n; i++) {\n        cin>>a[i];\n        a[i+n]=a[i];\n    }\n    auto can=[&](int x) -> bool {\n        int cnt=0, cur=0;\n        for (int i=0; i<2*n; i++) {\n            cur|=a[i];\n            if ((cur&x)==x) {\n                cnt++;\n                cur=0;\n            }\n        }\n        return cnt>=2*k-1;\n    };\n    int ans=0;\n    for (int bit=31; bit>=0; bit--) {\n        if (can(ans|(1<<bit))) ans|=(1<<bit);\n    }\n    cout<<ans;\n    return 0;\n}B. Conveyor Belts我们可以把一个点拆成个点，第个点代表第时刻。原图中的边拆完之后就变成了的第时刻连到的第时刻，容量为1。这样就保证了每时刻每条传送带上只有一个物品。然后添加一个超级源点，连到第个producer的第时刻，容量为1。最后从第个点的每一个时刻连到一个超级汇点，容量为无穷大。然后跑个最大流就行了。#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\n// indexed from 0!\nstruct Flow {\n    static constexpr int INF = 1e9;\n    int n;\n    struct Edge {\n        int to, cap;\n        Edge(int to, int cap) : to(to), cap(cap) {}\n    };\n    std::vector<Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n    Flow(int n) : n(n), g(n) {}\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t) return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t) return f;\n        int r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i) {\n            int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0) return f;\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k, m;\n    cin>>n>>k>>m;\n    Flow mf(n*k+2);\n    for (int i=0; i<m; i++) {\n        int x, y;\n        cin>>x>>y;\n        x--, y--;\n        for (int j=0; j<k; j++) {\n            mf.addEdge(x*k+j, y*k+(j+1)%k, 1);\n        }\n    }\n    for (int i=0; i<k; i++) mf.addEdge(n*k, i*k+i, 1);\n    for (int i=0; i<k; i++) mf.addEdge((n-1)*k+i, n*k+1, 1e9);\n    cout<<mf.maxFlow(n*k, n*k+1);\n    return 0;\n}C. Free Food暴力标记每一天即可D. Hoppers如果有长度为奇数的环的话并且整个网络连通就能传播到整个网络。所以只少检查每个连通分量是不是二分图并计算连通分量的个数就行了。队友写的所以没有代码QAQE. Largest Triangle这题过于经典，网上应该有很多题解。G. Non-Prime Factors先预处理答案，类似筛法的思路：如果不是质数就把它的倍数们的答案加1,质数就把它的倍数们标记成合数。输出询问即可。快读貌似不是很有必要。#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nnamespace IO {\nconst int MAXSIZE = 1 << 20;\nchar buf[MAXSIZE], *p1, *p2;\n#define gc()                                                               \\\n  (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\\n       ? EOF                                                               \\\n       : *p1++)\ninline int rd() {\n  int x = 0, f = 1;\n  char c = gc();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = gc();\n  }\n  while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc();\n  return x * f;\n}\nchar pbuf[1 << 20], *pp = pbuf;\ninline void push(const char &c) {\n  if (pp - pbuf == 1 << 20) fwrite(pbuf, 1, 1 << 20, stdout), pp = pbuf;\n  *pp++ = c;\n}\ninline void write(int x) {\n  static int sta[35];\n  int top = 0;\n  do {\n    sta[top++] = x % 10, x /= 10;\n  } while (x);\n  while (top) push(sta[--top] + '0');\n}\n}  //\nconst int N=2e6;\nint ans[N+1];\nbool not_prime[N+1];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int q=IO::rd();\n\n    for (int i=2; i<=N; i++) {\n        if (!not_prime[i]) {\n            for (int j=i+i; j<=N; j+=i)\n                not_prime[j]=1;\n        } else {\n            for (int j=i; j<=N; j+=i) {\n                ans[j]++;\n            }\n        }\n    }\n    while (q--) {\n        int x=IO::rd();\n        printf(\"%d\\n\", ans[x]+1);\n    }\n    return 0;\n}J. SG Coin其实就是个取模下的减法。。。L. Wi Know首先我们观察到：对于，一定不差于。所以在 中第一个A我们一定选在中第一次出现的A。同理，第二个B一定选中最后一出现的B。解法的大致思路就是固定B找最小的A。一种比较naive的思路是在中查询最小值，但有两个问题：不知道最小值在之前有没有出现过。最小值可能等于。所以我们不能一次把所有的数都放到线段树里，要按一定的顺序放。对于每个位置，我们记录一个为的下一个出现位置。然后我们遍历，首先查询中的最小值min，然后用更新答案，最后在线段树中把设为。这样为什么避免了上面的两个问题呢？首先，只有在之前出现过的数才会被加进去，避免了问题1，然后我们是先查询再添加，而且一次只加一个，这样就避免问题2。总之这个解法还是很妙的，比官方题解简单不少。#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nstruct SegTree{\n    int n;\n    vector<int> t;\n    SegTree(int n_):n(n_),t(4*n, 1e9){}\n    void pushup(int node){\n        t[node]=min(t[node<<1],t[node<<1|1]);\n    }\n    void update(int node,int i,int x,int l,int r){\n        if(l==r){\n            t[node]=x;\n            return;\n        }\n        int mid=(l+r)/2;\n        if(i<=mid) update(node<<1,i,x,l,mid);\n        else update(node<<1|1,i,x,mid+1,r);\n        pushup(node);\n    }\n    void update(int i, int x) {\n        update(1, i, x, 0, n-1);\n    }\n    int query(int node,int ql,int qr,int l,int r){\n        if (ql > r || qr < l) return 1e9;\n        if(ql<=l&&qr>=r){\n            return t[node];\n        }\n        int mid=(l+r)>>1;\n        return min(query(node<<1,ql,qr,l,mid), query(node<<1|1,ql,qr,mid+1,r));\n    }\n    int query(int l, int r) {\n        return query(1, l, r, 0, n-1);\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> a(n);\n    vector<int> pos(n+1, -1), nxt(n, -1), last(n+1, -1);\n    for (int i=0; i<n; i++) {\n        cin>>a[i];\n        last[a[i]]=i;\n    }\n    for (int i=n-1; i>=0; i--) {\n        nxt[i]=pos[a[i]];\n        pos[a[i]]=i;\n    }\n    pair<int, int> ans={n+1, n+1};\n    SegTree st(n);\n    for (int i=0; i<n; i++) {\n        int x=st.query(i+1, last[a[i]] - 1);\n        ans=min(ans, { x, a[i] });\n        st.update(nxt[i], a[i]);\n    }\n    if (ans.first<=n) cout<<ans.first<<' '<<ans.second<<'\\n';\n    else cout << -1;\n    return 0;\n}"},{"id":"2019_ECNA_K","title":"题解 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","content":"感觉挺套路的，但当时太菜了不会做，是道不错的题SolutionFor brevity, let's use  denote A, E, I, O, U.Let  be the cost to put all the bins of type  consecutively to where ends at .For the 5 types of bins, there's are  combinations of relative order. Let   be the best cost to put  types of bins such that the last type of bins ends at . Obviously,  can be one of of .For ,  can be calculated from :Time complexity:  (correct me if I'm wrong).题解首先先算出把每一种箱子放到结尾为的位置的花费，然后遍历  种相对位置顺序，然后记录把前种箱子放到结尾为的位置的花费。 具体转移公式看上面吧，懒得复制了QAQ.Code#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin>>s;\n    int n=(int)s.size();\n    vector<int> a(n), bins(n);\n    for (auto& i : a) cin>>i;\n    map<char, int> mp{{'A', 0}, {'E', 1}, {'I', 2}, {'O', 3}, {'U', 4}};\n    int cnt[5]{}, totalCost[5]{};\n    int d;\n    cin>>d;\n    while (d--) {\n        int x;\n        cin>>x;\n        x--;\n        a[x]=0;\n        s[x]='X';\n    }\n    for (int i=0; i<n; i++) {\n        auto c=s[i];\n        if (c!='X') {\n            cnt[mp[c]]++;\n            totalCost[mp[c]]+=a[i];\n            bins[i]=mp[c];\n        } else bins[i]=-1;\n    }\n    string t;\n    cin>>t;\n    if (t!=\"X\") for (auto c : t) cnt[mp[c]]++;\n    constexpr int INF=1e9;\n    vector endCost(5, vector(n, INF));\n    auto bestCost=endCost;\n    for (int bin=0; bin<5; bin++) {\n        for (int i=0; i<n; i++) {\n            if (i>=cnt[bin]-1) {\n                endCost[bin][i]=totalCost[bin];\n                for (int j=0; j<cnt[bin]; j++) {\n                    if (bins[i-j]==bin) endCost[bin][i]-=a[i-j];\n                }\n            }\n        }\n    }\n    int ans=1e9;\n    vector<bool> available(5, true);\n    auto solve=[&](auto& solve, int level) -> void{\n        if (level==0) {\n            for (int o=0; o<5; o++) {\n                available[o]=false;\n                bestCost[0]=endCost[o];\n                solve(solve, 1);\n                available[o]=true;\n            }\n        } else if (level==5) {\n            ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end()));\n        } else {\n            for (int o=0; o<5; o++) {\n                if (available[o]) {\n                    available[o]=false;\n                    int spaceNeeded=0;\n                    for (int o2=0; o2<5; o2++) {\n                        if (!available[o2]) spaceNeeded+=cnt[o2];\n                    }\n                    for (int i=0; i<n; i++) {\n                        bestCost[level][i]=INF;\n                        if (i>=spaceNeeded-1) {\n                            for (int j=0; j<i-cnt[o]+1; j++) {\n                                bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]);\n                            }\n                        }\n                    }\n                    solve(solve, level+1);\n                    available[o]=true;\n                }\n            }\n        }\n\n    };\n    solve(solve, 0);\n    cout<<ans;\n    return 0;\n}"},{"id":"2019summary","title":"我的2019","content":"转眼就到了2019年的最后一天了。看到了很多人的回顾和总结，又想到了今年发生的一些事情，心想我也可以写点流水账啊。2019发生的最大的事，莫过于我从中国来到了加拿大。当然也有很多别的事情值得回忆：学了自由泳、打了区域赛、桥式sub20、学会做菜……先说说留学，这个决定其实比较突然，但考虑到时间有点晚，所以准备的过程也是紧锣密鼓。对我来说最大的挑战就是考雅思，报了个网课，学一整个寒假的时间，但自己却没太努力，阅读和听力相对简单，自己最担心的还是写作和口语，尤其是口语，因为是最难练习的，再加上自己也没认真准备素材，以至于考试前夕异常紧张，果然最后成绩只有5.5。此时希望全都放在了下一次考试上面，两次考试中间的十几天也全用在了准备口语上，值得庆幸的是碰到了自己比较熟悉的话题，自我感觉良好。好歹达到了之前的目标（虽然只有6分）。从年初开始准备一直到4月中旬拿到成绩，再到4月底拿到约克的offer，这件事总算告一段落。\n\n这一年也是acm起步的第一年，虽然中间经历了一些波折，但最后还是决定走在条路。寒假训练打开了算法进阶的门，学期刚开始训练还比较正常，考完雅思之后就开始放飞自我，天天泡在实验室，有段时间就是天天敲线段树，最后基本上做完了 “大可线段树26题”,当时感觉还是想当爽的~期间打了北交校赛，卡在了道题意不清的烂题上，被北交大佬吊打。还去了北工打了程序设计天梯赛，深刻体会到了什么叫“暴力碾标算”，最后混了个铜奖。放假前打了北林校赛，矮子里面拔高个，运气好出了6题混了第四还赚了200块，不得不说这奖金还是很大气的。转眼到了暑假，由于暑假集训前还有小学期，再加上在北京也没什么好待的了，于是就早早回了家，暑假集训也就不搞了，错过了一些算法，不过现在看来大部分也没机会用毕竟简单题还做不好。在家的时候考虑到了去了加拿大还要不要继续打acm，但又不知道那边的比赛情况，于是就先选择了暂时放下acm，等到了那边再说，于是一个暑假没怎么敲代码。到了约克没几天便收到了关于ecna regional contest选拔赛的邮件，可把我激动坏了，不出意外的拿到了参赛名额，最后6个人里面3个用C++的正好凑一个队，搞了一场训练发现队友并不强，那今年就当去玩玩熟悉比赛了。因为队友都不住在学校，一起训练不太方便，所以还是以个人训练为主，期间自己也开始打cf，码力有所恢复。比赛在温莎大学，教练开车带我们过去，下午到了先签到然后就等着热身赛，滑大没有放水很快就ak了，而我们最后1分钟才过了4题排第10，毕竟好多放水的，感觉状态还行，结束之后吃了点主办方提供的披萨然后我们就去宾馆了，教练定的宾馆离学校很近，条件也相当好（除了没有热水洗澡）本想早点睡的，结果和队友聊到12点多……\n第二天一早吃了早饭就赶赴赛场，虽说是来玩玩的，但比赛开始前还是相当紧张的，按照之前的计划，三个人分别读前中后，我可能是急于想快速找到签到题，读完反而没什么印象，以至于签到题也觉得比较难，而队友也读到了签到题但给我解释的时候没抓住重点，说了半天我才明白，就是在一个不单调的序列里强行二分，看是否能找到某个数，结果我用了wa了两发最后手写二分才过的，而此时已经52分钟了，和预计的节奏（1小时做完签到）严重不符，但还好也没拖太久，一个半小时的时候做完了所有三道签到。然后发现一个很多人过的dp题，但自己dp很差，写了一个wa了之后发现思路有问题，就开始怀疑是不是dp，想了很久也没什么想法就去看别的题了，看到一个中国剩余定理的板子题然而板子里并没有印，当时内心一下就凉了，也成为了这次最大的遗憾。队友说可以尝试推一下不过最后也没推出来，没过多就发现友对把那个dp题过了，然后队友就一再提醒我说那个题肯定不难因为友队不会图论，又想了好久突然开窍发现多加一个dp状态就行了，赶紧去写然而判定边界的函数没写好最后才发现，在还有半小时结束的时候过了……最后我们排34/120，友队排31，不好也不坏，反正教练挺高兴的。但我深知这绝对不是我们的水平。\n回学校之后一切又回归正常，在寒假疯狂掉分之后发现之前在地大的训练非常有问题，非常不注重基本功，以至于经常卡在c题或d题，而事实上这些题都不需要多么高级的算法，于是自己开始练一些简单或中等难度的暴力和构造题，终于在2019最后一场止住了掉分同时也保住了正的净分数变化。最后再说说做饭吧，其实这挺神奇的，来之前完全不会做饭，感觉自己来了一下就会了哈哈，来的第二天就开始找能买菜的超市，还好学校西边有一个亚（中）洲（国）超市，这可真是太方便了。食材解决之后就是技术了，在老爸和网上的菜谱指导之下慢慢形成了自己的一套理论，其实也没什么麻烦，简单的家常菜就足够应付每日饮食了。对于学会做菜这件事自己真的是很开心的，既省钱又合自己口，这也算是一项重要的生活技能啊。2019真的是收获颇丰的一年，希望自己在2020能继续进步，立几个flag:cf1800分区域赛进前20成绩保持在A以上三速至少sub15加油，奥力给！"},{"id":"2020_ICPC_ECNA","title":"2020 ICPC East Central NA Regional Contest 总结与题解","content":"算是有所进步但还是稍有遗憾，差一题就能进division championships.更新：所有7题队都以wildcard的身份晋级NADC了，而且如果本学校只有wildcard队的话，会被分到最弱的central division，然后我们又莫名其妙的拿了个第6，晋级NAC了:joy:比赛过程两个队友一个简称T，一个简称J。开场我从前往后读，A比较长就直接跳过了，读了B感觉有点想法但又不是很确定就接着读，C很明显是个找最大环，一开始还觉得比较麻烦，但想想不是环就是链所以直接dfs就行了。同时队友J读到E发现就是个矩阵乘法于是开始写，我又跟榜做了G。之后不久队友J的E也过了。另一个队友T读了H是贪心但不会写，我此时在写B的暴力（但其实稍微想想暴力肯定超时但不知道为啥还是写完了）。B暴力写完才发现会超时，此时H还没做出来，我看了一眼也没想法，就扔给队友J了。然后发现B好像可以dp，然后就一边想一边写，虽然有点恶心但挺直接的，最后一遍过。写B的过程中队友J过了H，算是签完到了。此时才一个半小时，感觉非常好，比去年顺利多了。然后我在做K，感觉是dp，有点思路但不会写，队友J在做J，过了样例但是WA，队友T直接开I了（其实是最难的题orz）。于是三个人都卡题了，不知不觉过了一个半小时我终于放弃了，此时J题过了一大堆，于是我就跟队友J换了一下题，由于队友J用的python而我又懒的看所以就准备重写，然后没想到是个超级恶心模拟题，而且写了一堆bug，离结束还有半小时和队友J几乎同时过了J和K。然后仔细一看A发现很简单但输出格式很恶心，最后虽然勉强写完但没时间debug，以7题收场。反思卡题太久没有及时放弃，哪怕去读读别的题。题没有都读一遍，队友J其实读了A但感觉很麻烦，但我感觉比J好做多了（可能我J写的太烂了）。L到最后也没人读，其实也不难，就是个二分图匹配的板子 题。所以说也不能一味的跟榜，毕竟每个人的知识点覆盖不一样。但K卡半天没做出来也不应该。题解A数据很小，找lca直接暴力网上跳也可以。输出格式比较恶心，要多看几遍，注意不要把输出成 。#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, T;\n    cin>>n>>T;\n    vector<vector<string>> a(n);\n    vector<string> name(n);\n    unordered_map<string, int> id;\n    for (int i=0; i<n; i++) {\n        cin>>name[i];\n        id.try_emplace(name[i], id.size());\n        int x;\n        cin>>x;\n        a[i].resize(x);\n        for (auto& s : a[i]) {\n            cin>>s;\n            id.try_emplace(s, id.size());\n        }\n    }\n    vector<vector<int>> g(id.size());\n    vector<int> ind(id.size());\n    for (int i=0; i<n; i++) {\n        int u=id[name[i]];\n        for (auto& s : a[i]) {\n            g[u].push_back(id[s]);\n            ind[id[s]]++;\n        }\n    }\n    vector<int> pa(id.size());\n    vector<int> dep(id.size());\n    auto dfs=[&](auto& dfs, int u, int p) -> void {\n        pa[u] = p;\n        for (auto v : g[u]) {\n            if (v == p) continue;\n            dep[v]=dep[u]+1;\n            dfs(dfs, v, u);\n        }\n    };\n\n    auto lca=[&](int x, int y) {\n        while (x!=y) {\n            if (dep[x]<dep[y]) swap(x, y);\n            x=pa[x];\n        }\n        return x;\n    };\n\n    for (int i=0; i<id.size(); i++) {\n        if (ind[i]==0) {\n            dfs(dfs, i, i);\n            break;\n        }\n    }\n    auto ordinal=[](int x) {\n        auto s=to_string(x);\n        if (x>=11 && x<=13) return s+\"th\";\n        if (x%10==1) return s+\"st\";\n        if (x%10==2) return s+\"nd\";\n        if (x%10==3) return s+\"rd\";\n        return s+\"th\";\n    };\n    while (T--) {\n        string s, t;\n        cin>>s>>t;\n        int l=lca(id[s], id[t]);\n        int m=dep[id[s]]-dep[l];\n        int n=dep[id[t]]-dep[l];\n        int swaped=0;\n        if (m>n) {\n            swap(m, n);\n            swaped=1;\n            swap(s, t);\n        }\n        if (m==0) {\n            swap(s, t);\n            if (n==1) {\n                cout<<s<<\" is the child of \"<<t<<'\\n';\n            } else {\n                n-=2;\n                cout<<s<<\" is the \";\n                for (int i=0; i<n; i++) cout<<\"great \";\n                cout<<\"grandchild of \"<<t<<'\\n';\n            }\n        } else if (m==n && m>0) {\n            if (swaped) swap(s, t);\n            if (n==1) cout<<s<<\" and \"<<t<<\" are siblings\\n\";\n            else {\n                n--;\n                cout<<s<<\" and \"<<t<<\" are \"<<ordinal(n)<<\" cousins\\n\";\n            }\n        } else if (n>m && m>0) {\n            if (swaped) swap(s, t);\n            if (n-m==1)\n                cout<<s<<\" and \"<<t<<\" are \"<< ordinal(m-1)<<\" cousins, 1 time removed\\n\";\n            else \n                cout<<s<<\" and \"<<t<<\" are \"<<ordinal(m-1)<<\" cousins, \"<<n-m<<\" times removed\\n\";\n        }\n    }\n        return 0;\n}B 代表是否存在以坐标  的字符结尾，覆盖目标字符串的前个字符，转向次，结束时的方向是的走法。注意长度为的字符串最多转次，虽然第一个字符是没有方向的，但为了转移方便就变成了所有方向，所以枚举转向次数的话要限制一下，不然会出现长度为2转两次的走法。#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint dp[10][10][105][105][8];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin>>n>>m;\n    vector a(n, vector<char>(m));\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<m; j++) {\n            cin>>a[i][j];\n        }\n    }\n    int limit;\n    string s;\n    cin>>limit>>s;\n    limit=min(limit, int(s.size()));\n    const vector<pair<int, int>> dirs{{1, 0}, {-1, 0}, {0,1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<m; j++) {\n            if (a[i][j]==s[0]) {\n                for (int d=0; d<8; d++) \n                    dp[i][j][0][0][d]=1;\n            }\n        }\n    }\n    for (int i=1; i<s.size(); i++) {\n        for (int x=0; x<n; x++) {\n            for (int y=0; y<m; y++) {\n                if (a[x][y]!=s[i]) continue;\n                for (int used=0; used<=min(limit, i-1); used++) {\n                    for (int d=0; d<8; d++) {\n                        for (int pd=0; pd<8; pd++) {\n                            auto [dx, dy]=dirs[d];\n                            unsigned nx=x+dx, ny=y+dy;\n                            int pused=used-(d!=pd);\n                            // if (i==1) pused=0;\n                            if (nx<n && ny<m && pused>=0 && dp[nx][ny][i-1][pused][pd]) {\n                                dp[x][y][i][used][d]=1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<m; j++) {\n            for (int d=0; d<8; d++)\n                if (dp[i][j][s.size()-1][limit][d]) \n                    return cout<<\"Yes\", 0;\n        }\n    }\n    cout<<\"No\";\n    return 0;\n}C由于每个物品最多只有一个人要，所以每个点的出度最多为1，所以每个连通分量要么是环要么是链。直接dfs即可。#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<vector<int>> g(n);\n    struct node {\n        string name, has, wants;\n    };\n    vector<node> a(n);\n    unordered_map<string, int> names, toys;\n    unordered_map<string, string> wanted_by;\n    for (auto& [name, has, wants] : a) {\n        cin>>name>>has>>wants;\n        names.try_emplace(name, names.size());\n        toys.try_emplace(has, toys.size());\n        toys.try_emplace(wants, toys.size());\n        wanted_by[wants]=name;\n    }\n    for (int i=0; i<n; i++) {\n        if (wanted_by.count(a[i].has))\n            g[i].push_back(names[wanted_by[a[i].has]]);\n    }\n    vector<int> vis(n);\n    int ans=0;\n    auto dfs=[&](auto& dfs, int u, int dep) -> void{\n        vis[u]=1;\n        for (auto v : g[u]) {\n            if (vis[v]==1) {\n                ans=max(ans, dep+1);\n            } else {\n                dfs(dfs, v, dep+1);\n            }\n        }\n        vis[u]=2;\n    };\n    for (int i=0; i<n; i++) {\n        if (!vis[i]) {\n            dfs(dfs, i, 0);\n        }\n    }\n    if (ans) cout<<ans;\n    else cout<<\"No trades possible\";\n    return 0;\n}D还没来得及补E非常简单的矩阵乘法，队友写的，没要代码。。。F矩阵求逆，模运算下的高斯消元。队友赛后补的using namespace std;\n#include <bits/stdc++.h>\n#include <string>\n#define ll long long\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define FOR(i,n) for(int (i)=0;(i)<(n);++(i))\n#define PRE(i,m,n,in) for(int (i)=(m);(i)<(n);i+=in)\n#define RPRE(i,m,n,in) for(int (i)=(m);(i)>=(n);i-=in)\n#define srt(v) sort(v.begin(),v.end())\n#define printv(a) printa(a,0,a.size())\n#define debug(x) cout<<#x\" = \"<<(x)<<endl\n#define printa(a,L,R) for(int i=L;i<R;i++) cout<<a[i]<<(i==R-1?\"\\n\":\" \")\n#define printv(a) printa(a,0,a.size())\n#define print2d(a,r,c) for(int i=0;i<r;i++) for(int j=0;j<c;j++) cout<<a[i][j]<<(j==c-1?\"\\n\":\" \")\ntypedef vector<string>VS;\ntypedef pair<int,int>pii;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>VL;\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<VL>VVL;\ntypedef vector<pii>VII;\n\nconst int MOD = 37;\nconst int INF = 2; \n\nint gauss (vector < vector<int> > &a, vector<int> & ans, const vector<ll>&inv) {\n  int n = (int) a.size(); int m = (int) a[0].size() - 1;\n  vector<int> where (m, -1);\n  for (int col=0, row=0; col<m && row<n; ++col) {\n    int sel = row;\n    for (int i=row; i<n; ++i)\n      if ( a[i][col] > a[sel][col]) sel = i;\n    if (a[sel][col] == 0) continue;\n    for (int i=col; i<=m; ++i)\n      swap (a[sel][i], a[row][i]);\n    where[col] = row;\n    for (int i=0; i<n; ++i) \n      if (i != row) {\n        int c = (a[i][col] * inv[a[row][col]]) % MOD;\n        for (int j=col; j<=m; ++j)\n          a[i][j] = (a[i][j] - (a[row][j]*c % MOD) + MOD) % MOD;\n      }\n    ++row;\n  }\n\n  ans.assign (m, 0);\n  for (int i=0; i<m; ++i)\n    if (where[i] != -1)\n      ans[i] = (a[where[i]][m] * inv[a[where[i]][i]]) % MOD;\n  for (int i=0; i<n; ++i) {\n    int sum = 0;\n    for (int j=0; j<m; ++j)\n      sum = (MOD + sum + (ans[j] * a[i][j]) % MOD) % MOD;\n    if (abs (sum - a[i][m]) != 0)\n      return 0;\n  }\n  for (int i=0; i<m; ++i)\n    if (where[i] == -1) return INF;\n  return 1;\n}\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  string ns; getline(cin, ns); int n = stoi(ns);\n  string s1; getline(cin, s1); \n  string s2; getline(cin, s2);\n  vector<ll> inv(MOD);\n  inv[1]=1;\n  for(int i = 2; i < MOD; ++i) inv[i] = MOD - (MOD/i) * inv[MOD % i] % MOD;\n  vector< vector <int> > v1( n , vector <int> ()); \n  vector< vector <int> > v2( n , vector <int> ()); \n  for(int i = 0; i < s1.size(); i++) {\n    int num;\n    if(s1[i] >= 'A' && s1[i] <= 'Z') {\n      num = int(s1[i]) - 65;\n    }\n    else if(s1[i] == ' ') num = 36;\n    else num = (s1[i] - '0') + 26;\n    v1[i % n].push_back(num);\n  }  \n  for(int i = 0; i < s2.size(); i++) {\n    int num;\n    if(s2[i] >= 'A' && s2[i] <= 'Z') {\n      num = int(s2[i]) - 65;\n    }\n    else if(s2[i] == ' ') num = 36;\n    else num = (s2[i] - '0') + 26;\n    v2[i % n].push_back(num);\n  }\n  int consistent = 0;\n  int many = 0;\n  int no = 0;\n  vector <vector <int> > sol;\n  for(int i = 0; i < n; i++) {\n    vector<vector<int>>a(v1[0].size(), vector<int>(n + 1));\n    vector<int>b(n);\n    for(int j = 0; j < v1[0].size(); j++) {\n      for(int k = 0; k < n; k++) {\n        a[j][k] = v1[k][j];\n      }\n      a[j][n] = v2[i][j]; \n    }\n    vector<int>ans;\n    int num = gauss(a, ans, inv);\n    if(num == 0) no++;\n    else if(num == 1) {\n      consistent++;\n      sol.push_back(ans);\n    }\n    else many++;\n  }\n  if(consistent == n) print2d(sol, n, n);\n  else if(no >= 1)cout << \"No solution\" << endl;\n  else if(many >= 1) cout << \"Too many solutions\" << endl;\n  return 0;\n}G直接模拟即可#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin>>n>>m;\n    vector<int> a(n), rank(n);\n    iota(all(a), 0);\n    iota(all(rank), 0);\n    while (m--) {\n        char c;\n        int u, v;\n        cin>>c>>u>>c>>v;\n        u--, v--;\n        if (rank[u]>rank[v]) {\n            for (int i=rank[v]; i<rank[u]; i++) {\n                a[i]=a[i+1];\n                rank[a[i]]=i;\n            }\n            a[rank[u]+1]=v;\n            rank[v]=rank[u]+1;\n        }\n    }\n    for (auto i : a) cout<<\"T\"<<i+1<<' ';\n    return 0;\n}H根据deadline排序，然后维护有多少槽位可供不需要纸的和需要纸的人用（代码里的数组）,不需要纸的人也可以用需要纸的人的槽位。然后根据人数相应的更新数组。队友的赛时的源代码from collections import *\nfrom functools import *\nfrom math import *\nimport sys\n\ninput = sys.stdin.readline\nsys.setrecursionlimit(2147483647)\nml = lambda: map(int, input().split())\n\ns, n = ml()\npeople = defaultdict(lambda: [0, 0])\nfor _ in range(n):\n    deadline, need = input().split()\n    deadline = int(deadline)\n    people[deadline][need[0] == \"y\"] += 1\n\nhave = [0, 0]\nprev = 0\nfor deadline in sorted(people.keys()):\n    have[1] += deadline - prev\n    have[0] += (deadline - prev) * (s - 1)\n    prev = deadline\n\n    dont, need = people[deadline]\n\n    do = min(dont, have[0])\n    dont -= do\n    have[0] -= do\n\n    if dont + need > have[1]:\n        print(\"No\")\n        break\n    have[1] -= dont + need\nelse:\n    print(\"Yes\")我用C++又写了一遍:#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int s, n;\n    cin>>s>>n;\n    map<int, array<int, 2>> people;\n    for (int i=0; i<n; i++) {\n        int deadline;\n        char need;\n        cin>>deadline>>need;\n        people[deadline][need=='y']++;\n    }\n    ll have[2]{};\n    int prev=0;\n    for (auto& [deadline, v] : people) {\n        have[1]+=deadline-prev;\n        have[0]+=ll(deadline-prev)*(s-1);\n        prev=deadline;\n\n        auto [dont, need]=v;\n\n        int Do=min<ll>(dont, have[0]);\n        dont-=Do;\n        have[0]-=Do;\n        if (dont+need>have[1]) {\n            return cout<<\"No\\n\", 0;\n        }\n        have[1]-=dont+need;\n    }\n    cout<<\"Yes\\n\";\n    return 0;\n}I还没补J根据题意模拟即可#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    vector a(9, vector(9, 0));\n    for (auto& v: a) for (auto& i : v) cin>>i;\n    auto check_row=[&](int row, auto& cnt, int x) {\n        for (int i=0; i<9; i++) {\n            cnt[row][i][x]=0;\n        }\n    };\n    auto check_col=[&](int col, auto& cnt, int x) {\n        for (int i=0; i<9; i++) {\n            cnt[i][col][x]=0;\n        }\n    };\n    auto check_grid=[&](int r, int c, auto& cnt, int x) {\n        int num=r/3*3+c/3;\n        r=num/3*3, c=num%3*3;\n        for (int i=r; i<r+3; i++) {\n            for (int j=c; j<c+3; j++) {\n                cnt[i][j][x]=0;\n            }\n        }\n    };\n    auto count_row=[&](int row, auto& cnt, int x) {\n        int c=0;\n        for (int i=0; i<9; i++) {\n            if (a[row][i]) continue;\n            c+=cnt[row][i][x];\n        }\n        return c;\n    };\n    auto count_col=[&](int col, auto& cnt, int x) {\n        int c=0;\n        for (int i=0; i<9; i++) {\n            if (a[i][col]) continue;\n            c+=cnt[i][col][x];\n        }\n        return c;\n    };\n    auto count_grid=[&](int r, int c, auto& cnt, int x) {\n        int num=r/3*3+c/3;\n        r=num/3*3, c=num%3*3;\n        int cc=0;\n        for (int i=r; i<r+3; i++) {\n            for (int j=c; j<c+3; j++) {\n                if (a[i][j]) continue;\n                cc+=cnt[i][j][x];\n            }\n        }\n        return cc;\n    };\n    while (true) {\n        int found=0;\n        vector cnt(9, vector(9, vector(10, 1)));\n        for (int i=0; i<9; i++) {\n            for (int j=0; j<9; j++) {\n                cnt[i][j][0]=0;\n                if (a[i][j]!=0) {\n                    check_col(j, cnt, a[i][j]);\n                    check_row(i, cnt, a[i][j]);\n                    check_grid(i, j, cnt, a[i][j]);\n                }\n            }\n        }\n        for (int i=0; i<9; i++) {\n            for (int j=0; j<9; j++) {\n                if (a[i][j]==0) {\n                    if (count(all(cnt[i][j]), 1)==1) {\n                        found=1;\n                        auto it=find(all(cnt[i][j]), 1);\n                        a[i][j]=it-cnt[i][j].begin();\n                        goto next;\n                    }\n                    for (int v=1; v<=9; v++) {\n                        if ((count_col(j, cnt, v)==1 || count_row(i, cnt, v)==1 || count_grid(i, j, cnt, v)==1) && cnt[i][j][v]) {\n                            found=1;\n                            a[i][j]=v;\n                            goto next;\n                        }\n                    }\n                }\n            }\n        }\nnext:\n        if (found==0) break;\n    }\n    int cc=0;\n    for (auto& v : a) for (auto i : v) cc+=i==0;\n    if (cc) {\n        cout<<\"Not easy\\n\";\n        for (auto& v : a) {\n            for (auto& i : v) {\n                if (i==0) cout<<'.';\n                else cout<<i;\n                cout<<' ';\n            }\n            cout<<'\\n';\n        }\n    } else {\n        cout<<\"Easy\\n\";\n        for (auto& v : a) {\n            for (auto i : v) cout<<i<<' ';\n            cout<<'\\n';\n        }\n    }\n    return 0;\n}K我们可以用一次实验把当前问题变成两个更小的子问题，假设当前的最大高度是, 还剩个pallet，如果我们用个箱子试一次，如果pallet坏了的话那么问题就变成了：最大高度为, 还剩个pallet；如果没坏的话问题就变成了高度为，还剩个pallet。所以我们可以用dp。求范围的过程与dp类似。#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin>>n>>m;\n    vector need(n+1, vector(m+1, 0));\n    for (int i=0; i<=n; i++) need[i][1]=i;\n\n    for (int i=1; i<=n; i++) {\n        for (int pallet=2; pallet<=m; pallet++) {\n            int mn=n+1;\n            for (int j=1; j<=i; j++) {\n                int v1=need[j-1][pallet-1], v2=need[i-j][pallet];\n                mn=min(mn, max(v1, v2));\n            }\n            need[i][pallet]=mn+1;\n        }\n    }\n    int l=n, r=0;\n    int ans=need[n][m];\n    for (int i=1; i<=n; i++) {\n        if (max(need[i-1][m-1], need[n-i][m])+1==ans){\n            l=min(l, i);\n            r=max(r, i);\n        }\n    }\n    cout<<ans<<' ';\n    if (l==r) cout<<l;\n    else cout<<l<<'-'<<r;\n    return 0;\n}队友的二分做法：（和扔鸡蛋问题类似）from collections import *\nfrom functools import *\nfrom math import *\nimport sys\n\ninput = sys.stdin.readline\nsys.setrecursionlimit(2147483647)\nml = lambda: map(int, input().split())\n\ndef binomialCoeff(x, n, k):\n    sum = 0\n    term = 1\n    i = 1\n    while (i <= n and sum < k):\n        term *= x - i + 1\n        term /= i\n        sum += term\n        i += 1\n    return sum\n\ndef minTrials(eggs, floors):\n    if eggs == 0:\n        return floors and inf\n    low = 1\n    high = floors\n\n    while low < high:\n        mid = low + high >> 1\n        if binomialCoeff(mid, eggs, floors) < floors:\n            low = mid + 1\n        else:\n            high = mid\n\n    return low\n\ndef findX(eggs, floors):\n    low = 1\n    high = floors\n\n    while low < high:\n        mid = low + high >> 1\n        if minTrials(eggs, floors - mid) <= ans - 1:\n            high = mid\n        else:\n            low = mid + 1\n\n    return low\n\n\ndef findY(eggs, floors):\n    low = 1\n    high = floors\n\n    while low < high:\n        mid = low + high + 1 >> 1\n        if minTrials(eggs - 1, mid - 1) <= ans - 1:\n            low = mid\n        else:\n            high = mid - 1\n\n    return low\n\n# range: x to y\nfloors, eggs = ml()\nn = floors\nm = eggs\n# worst case: doesn't break on x and breaks on y\n# find smallest x s.t. minTrials(floors - x, eggs) <= ans - 1\n# find biggest y s.t. minTrials(y - 1, eggs - 1) <= ans - 1\n\nans = minTrials(eggs, floors)\nx = findX(eggs, floors)\ny = findY(eggs, floors)\n\nif x == y:\n    print(ans, x)\nelse:\n    print(ans, str(x) + \"-\" + str(y))L可以观察到一定是上面的几个门用A通道，剩下下面的用B通道，所以可以枚举A和B分界的位置，然后剩下的问题就是公寓匹配门、门匹配工作站了，跑两次二分图最大权匹配即可。之前做过匹配的题的话这题应该是很简单的，可以当时没人读到，但队友读了也不一定能反应过来是匹配问题233。#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...); cout<<'\\n';}\n\ntemplate<typename T>\nclass Hungarian {\npublic:\n    int n, m;\n    vector< vector<T> > a;\n    vector<T> u, v;\n    vector<int> pa, pb, way;\n    vector<T> minv;\n    vector<bool> used;\n    T inf;\n    Hungarian(int _n, int _m) : n(_n), m(_m), a(n, vector<T>(m)), u(n+1), v(m+1), pa(n+1, -1), pb(m+1, -1), way(m, -1), minv(m), used(m+1) {\n        assert(n <= m);\n        inf = numeric_limits<T>::max();\n    }\n    inline void add_row(int i) {\n        fill(minv.begin(), minv.end(), inf);\n        fill(used.begin(), used.end(), false);\n        pb[m] = i;\n        pa[i] = m;\n        int j0 = m;\n        do {\n            used[j0] = true;\n            int i0 = pb[j0];\n            T delta = inf;\n            int j1 = -1;\n            for (int j = 0; j < m; j++) {\n                if (!used[j]) {\n                    T cur = a[i0][j] - u[i0] - v[j];\n                    if (cur < minv[j]) {\n                        minv[j] = cur;\n                        way[j] = j0;\n                    }\n                    if (minv[j] < delta) {\n                        delta = minv[j];\n                        j1 = j;\n                    }\n                }\n            }\n            for (int j = 0; j <= m; j++) {\n                if (used[j]) {\n                    u[pb[j]] += delta;\n                    v[j] -= delta;\n                } else {\n                    minv[j] -= delta;\n                }\n            }\n            j0 = j1;\n        } while (pb[j0] != -1);\n        do {\n            int j1 = way[j0];\n            pb[j0] = pb[j1];\n            pa[pb[j0]] = j0;\n            j0 = j1;\n        } while (j0 != m);\n    }\n    inline T current_score() {\n        return -v[m];\n    }\n    inline T solve() {\n        for (int i = 0; i < n; i++) {\n            add_row(i);\n        }\n        return current_score();\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector g1(n, vector(2*n, 0));\n    auto g2=g1;\n    for (auto& v : g1)\n        for (auto& i : v) cin>>i;\n    for (auto& v : g2)\n        for (auto& i : v) cin>>i;\n    int mn_cost=1e9;\n    vector<array<int, 3>> ans(n);\n    for (int i=-1; i<n; i++) {\n        vector ng1(n, vector(n, 0));\n        auto ng2=ng1;\n        for (int j=0; j<n; j++) {\n            for (int u=0; u<n; u++) {\n                ng1[u][j]=g1[u][j*2+(j>i)];\n                ng2[u][j]=g2[u][j*2+(j>i)];\n            }\n        }\n        Hungarian<int> h1(n, n), h2(n, n);\n        h1.a=ng1, h2.a=ng2;\n        if (int cur=h1.solve() + h2.solve(); cur <mn_cost) {\n            mn_cost=cur;\n            for (int j=0; j<n; j++) {\n                ans[j]={j, h1.pa[j]*2+(h1.pa[j]>i),h2.pb[h1.pa[j]]};\n            }\n        }\n    }\n    cout<<mn_cost<<'\\n';\n    for (auto [x, y , z] : ans) {\n        cout<<x+1<<' '<<y/2+1<<char('A'+y%2)<<' '<<z+1<<'\\n';\n    }\n    return 0;\n}"},{"id":"2021-ECNA","title":"2021 ECNA区域赛总结与题解","content":"差不多最后一年了，明年队友估计就都毕业了，看看能不能找到其他人吧，或者solo也行？总结今年由于疫情依然不能去温莎线下比赛，但相比去年三人三机今天变成了更像线下的三人一机，不过是在各自学校比赛，但令人不能理解是的居然一点监控措施都没有，全凭自己自觉和教练监督。。。。可以理解为摆烂吧😂。我们队算是做到了遵循规则，除了多接了一个显示器用来看代码（自己电脑没法连机房的打印机），以及我还是用的自己的键盘（用40%配列太久了改不回来了）。排名有点出乎意料，考虑到队友忙于实习从不训练、我上了大三之后课程难度增加，只能靠每周cf维持一点做题量，这个排名已经很满意了，毕竟如果按NAC晋级规则按学校排名是第6，校排名要是第5的话总排名要第6，完全想peach😂。整场比赛还是比较流畅的，基本没有卡太长时间，A题作为比较简单的题卡了有点久，最后还是靠猜结论过的，F计算几何某队友到最后也没搞出来，不过没占用太多正常时间。时间再稍微多一点也许能搞搞I或者K，不过到最后也比有点累了，昨晚也只睡了5个半小时。题目题目整体难度适中？比去年难一点，（读了的题）以思维题为主。除了J题摆烂出了最大子矩形原题，题目质量还可以？A一开始wa是因为忘了考虑相加的转移。考虑加的话要遍历一遍整个dp数组，时间复杂度会变成，但其实也能过因为时间给了15s。。。（我tm写博客的时候才发现）。但貌似只要遍历前面一些数就行了，因为数大的时候乘肯定比加划算。\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> dp(n + 1, 1e9);\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        dp[i] = i;\n\n        for (int j = 1; j <= min(i / 2 + 1, 1000); j++)\n            dp[i] = min(dp[i], dp[j] + dp[i - j]);\n\n        string s = to_string(i);\n        for (int j = 1; j < (int)size(s); j++) {\n            string s1 = s.substr(0, j), s2 = s.substr(j);\n            if (s2[0] == '0') continue;\n            dp[i] = min(dp[i], dp[stoi(s1)] + dp[stoi(s2)]);\n        }\n\n        for (int f = 2; f * f <= i; f++) {\n            if (i % f == 0) { dp[i] = min(dp[i], dp[f] + dp[i / f]); }\n        }\n    }\n    cout << dp[n] << endl;\n}B赛时无脑敲了个lca，但其实稍微再想想就有更简单的做法：dfs时维护到根节点的距离以及最短的两条到叶子的路径的举例即可。#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n);\n    vector<int> a(n);\n    for (auto &x : a)\n        cin >> x;\n    vector<int> indeg(n), sum(n), color(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(v);\n        indeg[v]++;\n    }\n    int c = 0;\n    int ans = 1e9;\n    auto dfs = [&](auto &slf, int u, int s) -> int {\n        sum[u] = s + a[u];\n        color[u] = c;\n        int mn0 = 1e9, mn1 = 1e9;\n        for (auto v : g[u]) {\n            auto res = slf(slf, v, s + a[u]);\n            if (res < mn1) mn1 = res;\n            if (mn1 < mn0) swap(mn0, mn1);\n        }\n        ans = min(ans, mn0 + mn1 + sum[u]);\n        return (mn0 == 1e9 ? 0 : mn0) + a[u];\n    };\n    for (int i = 0; i < n; i++) {\n        if (indeg[i] == 0) {\n            dfs(dfs, i, 0);\n            c++;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (g[i].empty() && g[j].empty()) {\n                if (color[i] != color[j]) {\n                    ans = min(ans, sum[i] + sum[j]);\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}G签到题，枚举所有前缀以及交换顺序即可#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string a, b, c;\n    char op, _;\n    cin >> a >> op >> b >> _ >> c;\n    auto check = [&](string a_, string b_, string c_) {\n        __int128 a = stoll(a_), b=stoll(b_), c = stoll(c_);\n        if (op=='+') return a+b==c;\n        else return a*b==c;\n    };\n    for (int i=1; i<(int)size(a); i++) {\n        for (int j=1; j<(int)size(b); j++) {\n            for (int k=1; k<(int)size(c); k++) {\n                string a1=a.substr(0, i), a2=a.substr(0+i);\n                string b1=b.substr(0, j), b2=b.substr(0+j);\n                string c1=c.substr(0, k), c2=c.substr(0+k);\n                vector<string> s = {a1, b1, c1};\n                sort(begin(s), end(s));\n                do {\n                    if (check(s[0]+a2, s[1]+b2, s[2]+c2)) {\n                        cout << s[0]+a2 << ' ' << op << ' ' <<  s[1]+b2 << \" = \" << s[2]+c2;\n                        exit(0);\n                    }\n                } while (next_permutation(begin(s), end(s)));\n            }\n        }\n    }\n}J经典最大子矩阵，单调栈搞搞即可。其实我赛时已经基本忘了怎么做了，只记得是是单调栈，想了半天才想出来正解，这下应该以后忘不了了233#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; //}}}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    stack<pair<int, int>> stk;\n    ll ans = 0;\n    int s = 1e9, e = 0;\n\n    auto update = [&](ll cur, int curs, int cure) {\n        if (cur > ans || (cur == ans && curs < s)) {\n            ans = cur;\n            s = curs;\n            e = cure;\n        }\n    };\n    for (int i = 0; i < n; i++) {\n        int prev = i;\n        while (!stk.empty() && stk.top().first >= a[i]) {\n            prev = stk.top().second;\n            ll cur = ll(i - prev) * stk.top().first;\n            update(cur, prev, i - 1);\n            stk.pop();\n        }\n        ll cur = ll(i - prev + 1) * a[i];\n        update(cur, prev, i);\n        stk.push({a[i], prev});\n    }\n    while (!stk.empty()) {\n        auto [x, i] = stk.top();\n        stk.pop();\n        ll cur = ll(n - i) * x;\n        update(cur, i, n - 1);\n    }\n    cout << s + 1 << ' ' << e + 1 << ' ' << ans << endl;\n}L枚举四个角然后排序分层搞一搞，队友写的import collections\nimport itertools\nimport sys\nints = lambda: list(map(int, sys.stdin.readline().split()))\ngrid = []\ngy, gx = ints()\nfor y in range(gy):\n  grid.append(ints())\nstatues = []\nfor row in grid:\n  for cell in row:\n    if ~cell:\n      statues.append(cell)\nstatues.sort()\n\ndef levels(grid):\n  ret1 = collections.defaultdict(set)\n  ret2 = collections.defaultdict(set)\n  for y in range(gy):\n    for x in range(gx):\n      cell = grid[y][x]\n      if ~cell:\n        ret1[y+x].add(cell)\n        ret2[y-x].add(cell)\n  return ret1, ret2\n\nret1, ret2 = levels(grid)\n\nkeys1 = sorted(ret1.keys())\nkeys2 = sorted(ret2.keys())\n\nimport math\nmoved = math.inf\n\nfor keys, ret in (keys1, ret1), (reversed(keys1), ret1), (keys2, ret2), (reversed(keys2), ret2):\n  this = len(statues)\n  it = iter(statues)\n  for key in keys:\n    st = set()\n    for _ in range(len(ret[key])):\n      st.add(next(it))\n    this -= len(st & ret[key])\n  moved = min(moved, this)\n\nprint(moved)M最短路考虑用bfs，把所有字符串放入一个trie就可以很容易知道哪些方向可以走了，所以状态就是[x][y][trie中的节点的位置][上一步的方向]。除了状态复杂点其他就是正常bfs的套路，注意如果当前在单词结尾的位置，下一步即可以回到trie的根，又可以继续顺着trie走。#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Trie {\n    struct node {\n        map<char, int> ch;\n        bool term;\n    };\n    vector<node> t;\n    Trie() { new_node(); }\n    int new_node() {\n        t.emplace_back();\n        return t.size() - 1;\n    }\n    void insert(const string &s) {\n        int p = 0;\n        for (auto ch : s) {\n            if (!t[p].ch.count(ch)) { t[p].ch[ch] = new_node(); }\n            p = t[p].ch[ch];\n        }\n        t[p].term = true;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector s(n, vector<char>(m));\n    for (auto &v : s)\n        for (auto &c : v)\n            cin >> c;\n    Trie tr;\n    for (int i = 0; i < k; i++) {\n        string ss;\n        cin >> ss;\n        tr.insert(ss);\n    }\n    vector dis(n, vector(m, vector(size(tr.t), vector(3, -1))));\n    queue<array<int, 4>> q;\n    for (int i = 0; i < m; i++) {\n        if (tr.t[0].ch.count(s[0][i])) {\n            int st = tr.t[0].ch[s[0][i]];\n            dis[0][i][st][0] = 1;\n            q.push({0, i, st, 0});\n        }\n    }\n\n    const vector<pair<int, int>> dir{{1, 0}, {0, -1}, {0, 1}};\n    while (!q.empty()) {\n        auto [x, y, st, prev] = q.front();\n        int olddis = dis[x][y][st][prev];\n        q.pop();\n        for (int ii = 0; ii < (int)size(dir); ii++) {\n            auto [dx, dy] = dir[ii];\n            if ((prev == 1 && dy == 1) || (prev == 2 && dy == -1))\n                continue;\n            unsigned nx = x + dx, ny = y + dy;\n            if (nx < n && ny < m) {\n                auto go = [&](int st) {\n                    if (tr.t[st].ch.count(s[nx][ny])) {\n                        int nst = tr.t[st].ch[s[nx][ny]];\n                        if (dis[nx][ny][nst][ii] == -1) {\n                            dis[nx][ny][nst][ii] = olddis + 1;\n                            q.push({(int)nx, (int)ny, nst, ii});\n                        }\n                    }\n                };\n                go(st);\n                if (tr.t[st].term) {\n                    st = 0;\n                    go(st);\n                }\n            }\n        }\n    }\n    int ans = 1e9;\n    for (int i = 0; i < m; i++) {\n        for (int d = 0; d < 3; d++) {\n            for (int st = 0; st < (int)size(tr.t); st++) {\n                if (tr.t[st].term && dis[n - 1][i][st][d] != -1) {\n                    ans = min(ans, dis[n - 1][i][st][d]);\n                }\n            }\n        }\n    }\n    if (ans == 1e9) {\n        cout << \"impossible\\n\";\n    } else\n        cout << ans << endl;\n}"},{"id":"2x2-ortega","title":"二阶魔方面先法","content":"PBL0 Bar:R2 B2 R2R2' F2 R21 Bar:FU:R' F R' F2 R U' RR U' L U2' R' U L'BU: R' U R' F2 R F' RLU: L2 U R2 U' R2 U R2 U' R2RU: R2 U' L2 U L2 U' L2 U L2FD: R F' L U2 L' F R'BD: R U' R' U' R' F2 U' R U RLD: R2 U R2 U' R2 U R2 U' R2RD: L2 U' L2 U L2 U' L2 U L22Bar:B: R2 U' R2 U2' F2 U' R2F: R2 U' B2 U2' R2' U' R2L: F2 U' R2 U2' B2 U' R2R: F2 U' F2 U2' R2 U' R2Y:U: R U' R' U' F2 U' R U R' U F2D:R U' R' U' F2 U' R U R' U R2 B2F U2' R2 F R F' R U2 R' U R F'J:UL: R' F R F' R U2 R' U R U2 R'UR: R2 F2 R U R' F2 R F' RUB: R' F R' F2 R U' R' F2 R2UF: R' U R' F2 R F' R' F2 R2DB: x R U' R U2 R' F R U2 R2DL: R2 U' R' U L' U2 R U' R' U2 (先做auf)DF: R U' R' U' F R2 U' R' U R' F' RDR: R' F R U' R U R2 F' U R U R'"},{"id":"3*3pb9.8","title":"9.80无跳3阶pb复盘","content":"打乱B U2 R2 U2 L2 B' D2 R2 U2 R2 F2 R B' U R F U2 L2 R' B2解法：U' R2' F' //cross\ny U' R' U R//first pair\nU' L' U L U2 R U' R'//second pair\nU2 L' U' L2 U L'//third pair\ny' U R U2 R' U2 R U' R'//fourth pair\nU r U R' U R U2 r'//OLL\nU' R' U' F' R U R' U' R' F R2 U' R' U' R U R' U R//PLL"},{"id":"ABC159E","title":"AtCoder Beginner Contest 159E - Dividing Chocolate 题解","content":"看了一上午才看明白大佬的代码题解表示前i个数里面序列和是j的答案，也就是说把题目要求改成前i个数，和是j时的答案。当我们处理新的数的时候，假设这个数是x，当前在第i位。很明显前面的序列可以重复使用。现在我们再考虑新的数对答案的贡献：首先，新数自己就可以作为一个序列，所以我们有。其次，新的数还可以和前面的序列形成新的序列，所以对于所有，我们有。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n#define de(x) cout<<#x<<\" = \"<<(x)<<endl\n#define de2(x,y) cout<<#x<<\" = \"<<(x) <<' '<< #y<<\" = \"<<y<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\nll nxt(){ll x;cin>>x;return x;}\n\nconst int N=3e3+5;\nint dp[N][N];\nconst int mod=998244353;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,s;\n    cin>>n>>s;\n    ll ans=0;\n    for1(i,n){\n        int x;\n        cin>>x;\n        dp[i][x]=i;//self sequence\n        for(int j=0;j<=s;j++){\n            (dp[i][j]+=dp[i-1][j])%=mod;//reuse the previous answer\n            if(j-x>=0) (dp[i][j]+=dp[i-1][j-x])%=mod;//with previous sequences\n        }\n        ans=(ans+dp[i][s])%mod;\n    }\n    cout<<ans;\n    return 0;\n}"},{"id":"ABC161E","title":"AtCoder Beginner Contest 161E - Yutori 题解","content":"妙啊！题解我们可以构造一个数组使得第个工作日不早于第天，通过从前往后尽可能早的选择工作日。同样地，我们可以构造数组使得第个工作日不晚于天，通过从后往前选择。他必须在第天工作当且仅当存在使得。可以在的时间内解决。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n,k,c;\n    cin>>n>>k>>c;\n    string s;\n    cin>>s;\n    vector<int> a,b;\n    forn(i,n){\n        if(s[i]=='o'){\n            a.pb(i);\n            i+=c;\n        }\n    }\n    ford(i,n){\n        if(s[i]=='o'){\n            b.pb(i);\n            i-=c;\n        }\n    }\n    forn(i,k){\n        if(a[i]==b[k-i-1]) cout<<a[i]+1<<endl;\n    }\n\n    return 0;\n}"},{"id":"ABC162F","title":"Atcoder beginner contest 162F -  Select Half Select Half 题解","content":"yysy这种题想出来真的爽。题解这道题有很多不同的dp方法。这里我将描述一下我认为比较标准的方法。当然有更短的做法但是也看不懂啊QAQ。首先定义一下dp状态，设为前i个数的答案并且最后一个选的数的下标是。通过观察不难发现如果是奇数，那么j最大是2，否则j最大是1。这点可以通过取的数来验证。现在我们可以考虑状态转移了。如果是奇数，那么选的数的个数和是一样的。所以应该等于除了，因为在计算的时候并没有被考虑到，所以应该从转移过来。以下是状态转移方程:当为偶数，要比多选一个数，想法基本类似。状态转移如下：Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(random_device{}());\ntemplate<typename... Args> void write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> a(n+1);\n    for(int i=1;i<=n;++i) cin>>a[i];\n    vector<vector<ll>> dp(n+1,vector<ll>(3,-1e18));\n    dp[1]={0,0,0};\n    for(int i=2;i<=n;++i){\n        if(i&1){\n            dp[i][0]=max({dp[i-2][0],dp[i-2][1],dp[i-2][2]})+a[i];\n            dp[i][1]=dp[i-1][0];\n            dp[i][2]=dp[i-1][1];\n        }else{\n            dp[i][0]=max({dp[i-1][1]+a[i],dp[i-1][2]+a[i]});\n            dp[i][1]=dp[i-1][2]+a[i-1];\n        }\n    }\n    cout<<*max_element(all(dp[n]));\n    return 0;\n}"},{"id":"ABC171F","title":"题解 Atcoder Beginner Contest 171F - Strivore","content":"思考的角度很妙题解答案的个数等于有多少个长度为的字符串使得是他的一个子序列。设在中的下标为。 为了避免重复，我们在所有可能的中取最小的。不难看出，和之间的字符有25种选择，之后的有26种可能。所以我们可以枚举之后的字符的个数，这样在字符选择方面我们有种可能。然后再考虑如何分配个字符，根据插板模型，我们有种方式，所以对于每个x，答案增加。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n#define pb push_back\n\nusing namespace std;\nusing ll=long long;\nusing pii= pair<int, int>;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    // constructor\n    ModInt(ll v = 0) : val(int(v % MOD)) {\n        if (val < 0) val += MOD;\n    };\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = int(ll(val) * x.val % MOD);\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint=ModInt<int(1e9+7)>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int k;\n    string s;\n    cin>>k>>s;\n    int n=sz(s);\n    vector<mint> fac(2e6+5);\n    fac[0]=1;\n    for(int i=1;i<=2e6;i++) fac[i]=fac[i-1]*i;\n    mint ans=0;\n    auto C=[&](int n,int r)->mint{\n        if(r>n) return 0;\n        return fac[n]/fac[r]/fac[n-r];\n    };\n    for(int i=0;i<=k;i++){\n        ans+=mint(25).pow(k-i)*mint(26).pow(i)*C(n-1+k-i,n-1);\n    }\n    cout<<ans;\n    return 0;\n}"},{"id":"ABC203E","title":"AtCoder Beginner Contest (ABC) 203E 题解","content":"有点不知如何下手的题本文基本是照着这个翻译的。Pawn是国际象棋里的兵。由于只能往下走，我们从上到下一行一行的处理，维护本层能够到达 的位置。根据规则，有两种情况会使到达性发生改变：如果能到达上一行的i位置而本行的i位置有一个兵，那么本行的i位置就是不可达的。如果上一行的i-1或i+1能到达的话而本行的i位置有一个兵，本行的i位置就是可达的。由于第二种情况可以覆盖掉第一种情况（即如果i同时符合两种情况那他也是可达的），所以在我们记录不可达和可达的变化之后，先处理不可达的变化，再处理可达的变化。代码：#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, int>> p(m);\n    for (auto &[x, y] : p) {\n        cin >> x >> y;\n    }\n    sort(p.begin(), p.end());\n    set<int> s{n};\n    for (int l = 0, r = 0; l < m; l = r) {\n        while (r < m && p[l].first == p[r].first) r++;\n        vector<int> rem, ins;\n        for (int i = l; i < r; i++) {\n            int y = p[i].second;\n            rem.push_back(y);\n            if (s.count(y - 1) || s.count(y + 1)) ins.push_back(y);\n        }\n        for (auto x : rem) s.erase(x);\n        for (auto x : ins) s.insert(x);\n    }\n    cout << s.size();\n    return 0;\n}"},{"id":"ABC266G","title":"AtCoder Beginner Contest 266 G 题解","content":"直接利用组合数求解的做法比较简单，这里就不再赘述，着重讲利用二项式反演的做法。首先不难想到用  个 RG，个R，个G，个B排，得到看似是“至少有的RG”的字符串数量。但是这样计数会有重复，比如和其实是一样的串但计数的时候算了两次，准确地说，含个RG的串被重复记了次，用数学语言表示就是：设为恰好含个RG的字符串的数量，有\n这恰好是二项式反演的形式二，那么答案为\n#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) begin(x),end(x) //{{{\n#ifndef LOCAL // https://github.com/p-ranav/pprint\n#define de(...)\n#define de2(...)\n#endif\nusing ll = long long; //}}}\n\ntemplate <typename mint> struct Factorial {\n    std::vector<mint> fac, invfac;\n    Factorial(int n) : fac(n + 1), invfac(n + 1) {\n        fac[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fac[i] = fac[i - 1] * i;\n        }\n        invfac[n] = fac[n].inv();\n        for (int i = n - 1; i >= 0; i--) {\n            invfac[i] = invfac[i + 1] * (i + 1);\n        }\n    }\n    mint C(int n, int k) { // n choose m\n        if (k < 0 || k > n) return 0;\n        assert((int)size(fac) > n);\n        return fac[n] * invfac[n - k] * invfac[k];\n    }\n    mint P(int n, int m) { // n choose m with permutation\n        assert(!fac.empty());\n        return fac[n] * invfac[n - m];\n    }\n\n    // evaluate expressions consists of multiplication and division\n    // if the number is multiplied, pass the number as argument\n    // if divided, pass its negation\n    // Example: a! * b! / c! => eval(a, b, -c);\n    template<typename... Args>\n    constexpr mint eval(Args... args) {\n        return ((args > 0 ? fac[args] : invfac[-args]) * ...);\n    }\n};\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    ModInt(ll v = 0) : val(v % MOD) { if (val < 0) val += MOD; };\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const {\n        auto a = val, m = MOD, u = 0, v = 1;\n        while (a != 0) { auto t = m / a; m -= t * a; swap(a, m); u -= t * v; swap(u, v); }\n        assert(m == 1);\n        return u;\n    }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    friend ModInt operator+ (ModInt lhs, const ModInt& rhs) { return lhs += rhs; }\n    friend ModInt operator- (ModInt lhs, const ModInt& rhs) { return lhs -= rhs; }\n    friend ModInt operator* (ModInt lhs, const ModInt& rhs) { return lhs *= rhs; }\n    friend ModInt operator/ (ModInt lhs, const ModInt& rhs) { return lhs /= rhs; }\n    ModInt& operator+=(const ModInt& x) { if ((val += x.val) >= MOD) val -= MOD; return *this; }\n    ModInt& operator-=(const ModInt& x) { if ((val -= x.val) < 0) val += MOD; return *this; }\n    ModInt& operator*=(const ModInt& x) { val = int64_t(val) * x.val % MOD; return *this; }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<998244353>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int r, g, b, k;\n    cin >> r >> g >> b >> k;\n    int n = r + g + b;\n    Factorial<mint> fac(n);\n    mint ans = 0;\n    for (int i = k; i <= min(r, g); i++) {\n        ans += ((i - k) % 2 ? -1 : 1) * fac.C(i, k) * fac.eval(i + r - i + g - i + b, -i, -(r - i), -(g - i), -b);\n    }\n    cout << ans << endl;\n}"},{"id":"ABC_DP","title":"部分题解 Atcoder Educational DP Contest","content":"非常好的学习dp的比赛。M - CandiesSolutionLet  be the number of ways to distribute  candies to the first  kids. If we give  candies to the -th kid, we should add  to . Since  takes all the values from  to , so . Note that we take a segment of , so we can use prefix sum.There's one optimization: the first dimension of  is useless, we only need to store the latest  array.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n#define pb push_back\n\nusing namespace std;\nusing ll=long long;\nusing pii= pair<int, int>;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\n\nconst int mod=1e9+7;\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    // constructor\n    ModInt(ll v = 0) : val(int(v % MOD)) {\n        if (val < 0) val += MOD;\n    };\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = int(ll(val) * x.val % MOD);\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint=ModInt<mod>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,k;\n    cin>>n>>k;\n    vector<int> a(n);\n    for(auto& it:a) cin>>it;\n    vector<mint> dp(k+1);\n    dp[0]=1;\n    for(int i=0;i<n;i++){\n        vector<mint> sum(k+2),ndp(k+1);\n        partial_sum(all(dp),sum.begin()+1);\n        for(int j=0;j<=k;j++){\n            ndp[j]+=sum[j+1];\n            if(j>=a[i]) ndp[j]-=sum[j-a[i]];\n        }\n        dp=ndp;\n    }\n    cout<<dp[k];\n    return 0;\n}O - MatchingSolution means the number of way to pair all the girls with 1-bit in the mask with the first  boys.Code#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    const int mod=1e9+7;\n    int n;\n    cin>>n;\n    vector a(n,vector(n,0));\n    for(auto& v:a) for(auto& it:v) cin>>it;\n    vector<int> dp(1<<n);\n    dp[0]=1;\n    for(int mask=1;mask<(1<<n);mask++){\n        int ones=__builtin_popcount(mask);\n        for(int bit=0;bit<n;bit++){\n            if(mask>>bit&1 && a[ones-1][bit]){\n                (dp[mask]+=dp[mask^(1<<bit)])%=mod;\n            }\n        }\n    }\n    cout<<dp[(1<<n)-1];\n    return 0;\n}S - Digit SumSolutionVery basic digit dp problem, we will write it in a recursive way with memoization.  means how many ways we can choose a number for the first  digits, with  and the -th digit can take value from 0-9 if  and  if .Code#include <bits/stdc++.h>\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll=long long;\n\nstring s;\nint D;\nconst int N=1e5+5,mod=1e9+7;\nll dp[N][105][2];\n\nll dfs(int i,int sum,bool strict){\n    if(i==sz(s)) return sum==0;\n    if(dp[i][sum][strict]!=-1) return dp[i][sum][strict];\n    ll ret=0;\n    int mx=9;\n    if(strict) mx=s[i]-'0';\n    for(int j=0;j<=mx;j++){\n        (ret+=dfs(i+1,(sum+j)%D,j==mx&&strict))%=mod;\n    }\n    return dp[i][sum][strict]=ret;\n}\n    \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>s>>D;\n    memset(dp,-1,sizeof(dp));\n    cout<<(dfs(0,0,1)-1+mod)%mod;\n    return 0;\n}T - PermutationSolutionLet  denotes the number of permutations of  such that the last element is j and all the first i - 1 inequalities are fulfilled.Transition is:  This can be calculated in  using prefix sum.One way to interpret the transition is that we add  to the end of the previous permutation and increase all the values greater or equal than  by 1. What a trick!Code#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    const int mod=1e9+7;\n    int n;\n    string s;\n    cin>>n>>s;\n    vector dp(n,vector(n,0));\n    dp[0][0]=1;\n    for(int i=1;i<n;i++){\n        vector<int> sum(n+1);\n        for(int j=1;j<=n;j++) sum[j]=(sum[j-1]+dp[i-1][j-1])%mod;\n        for(int j=0;j<=i;j++){\n            if(s[i-1]=='<') dp[i][j]=(sum.back()-sum[j]+mod)%mod;\n            else dp[i][j]=sum[j];\n        }\n    }\n    int ans=0;\n    for(auto it:dp[n-1]) (ans+=it)%=mod;\n    cout<<ans;\n    return 0;\n}U - Grouping题解表示只考虑的二进制表示中是1的位置的兔子的答案。一开始假设所有兔子都在同一个组里。然后用遍历的所有子集然后更新答案。Code#include <bits/stdc++.h>\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nusing namespace std;\nusing ll=long long;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    int a[n][n];\n    forn(i,n) forn(j,n) cin>>a[i][j];\n    vector<ll> dp(1<<n);\n    forn(i,1<<n) forn(j,n) if(i>>j&1) forn(k,j) if(i>>k&1)\n        dp[i]+=a[j][k];\n    forn(i,1<<n){\n        for(int j=i;j;j=(j-1)&i){\n            dp[i]=max(dp[i],dp[j]+dp[j^i]);\n        }\n    }\n    cout<<dp[(1<<n)-1];\n    return 0;\n}"},{"id":"CF1027D","title":"CodeForces 1027D - Mouse Hunt","content":"我怎么连找环都不会题解不论从哪开始，最终都会陷入循环（包括自环），所以把陷阱放在环上永远是最优的。所以这个题就是要找到所有环然后找出每个环上的最小花费。找环应该算是比基础的技巧了，但我是第一次遇到这种题（太菜了）。可以在这学如何找环。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n#define de(x) cout<<#x<<\" = \"<<(x)<<endl\n#define de2(x,y) cout<<#x<<\" = \"<<(x) <<' '<< #y<<\" = \"<<y<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconstexpr int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nvector<int> a;\nvector<int> vis;\nvector<vector<int>> cycles;\nvector<int> fa;\nvoid dfs(int u){\n\tvis[u]=1;\n\tint to=a[u];\n\tif(vis[to]==1){\n\t\tcycles.pb({to});\n\t\tfor(int id=u;id!=to;id=fa[id]) cycles.back().pb(id);\n\t}else if(vis[to]==0){\n\t\tfa[to]=u;\n\t\tdfs(to);\n\t}\n\tvis[u]=2;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tcin>>n;\n\tvector<int> cost(n);\n\ta=vis=fa=vector<int>(n);\n\tfor(auto& it:cost ) cin>>it;\n\tfor(auto& it:a) cin>>it,it--;\n\tforn(i,n){\n\t\tif(vis[i]==0) dfs(i);\n\t}\n\tll ans=0;\n\tfor(auto& cycle:cycles){\n\t\tint mn=INF;\n\t\tfor(auto it:cycle) mn=min(mn,cost[it]);\n\t\tans+=mn;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"},{"id":"CF1037D","title":"CodeForces 1037D - Valid BFS? 题解","content":"题解我们可以先对邻接表的节点，根据节点在输入序列的出现顺序排序。然后就可以正常跑一遍BFS然后检查得到的序列和输入是否一样。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n#define de(x) cout<<#x<<\" = \"<<(x)<<endl\n#define de2(x,y) cout<<#x<<\" = \"<<(x) <<' '<< #y<<\" = \"<<y<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconstexpr int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst int N=2e5+5;\nvector<int> G[N];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        G[x].pb(y);\n        G[y].pb(x);\n    }\n    vector<int> input(n), a(n+1);\n    forn(i,n){\n        cin>>input[i];\n        a[input[i]]=i;\n    }\n    for1(i,n){\n        sort(all(G[i]),[&](int x,int y){return a[x]<a[y];});\n    }\n    queue<int> q;\n    q.push(1);\n    vector<bool> vis(n+1);\n    vector<int> ans;\n    while(!q.empty()){\n        int now=q.front();\n        q.pop();\n        ans.pb(now);\n        vis[now]=1;\n        for(auto it:G[now]) if(!vis[it]) q.push(it);\n    }\n    forn(i,n) if(ans[i]!=input[i]) return cout<<\"no\",0;\n    cout<<\"yes\";\n    return 0;\n}"},{"id":"CF1059C","title":"Codeforces 1059C - Sequence Transformation 题解","content":"题意：定义如下序列的变换（由一个已知序列生成另一个序列）：如果序列是空的则停止，否则在新序列的最后加上当前序列所有元素的gcd，然后从原序列中移除一个元素。重复上述操作直到停止，问能得到的最大字典序的序列。题很简单，相信聪明的你一定能做出来。思路很显然，前面几个数必然是1，所以要想让字典序尽量大就得尽快出现别的数，要想让一个数出现就得删掉全部不是它倍数的数，那么最快能出现的数就是2了，只要把所有奇数删掉就行了。然后就剩下了一堆偶数，是不是看起来似曾相识？没错他又变成了刚才的问题只不过所有数都乘了2（禁止套娃）。那啥时候停呢？当n小于3的时候，因为此时无法用刚才的规律。是不是很有意思呢？其实递归的题都挺有意思的。代码#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define _ <<' '<<\n#define de(x) cout<<#x<<\" = \"<<(x)<<endl\n#define de2(x,y) cout<<#x<<\" = \"<<(x) _ #y<<\" = \"<<y<<endl;\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nvoid solve(int x,int mul){\n    if(x==1) cout<<mul<<' ';\n    else if(x==2) cout<<mul<<' '<<2*mul<<' ';\n    else if(x==3) cout<<mul<<' '<<mul<<' '<<3*mul<<' ';\n    else{\n        for(int i=1;i<=x;i+=2) cout<<mul<<' ';\n        solve(x/2,mul*2);\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    solve(n,1);\n    return 0;\n}"},{"id":"CF1128C","title":"CodeForces 1128C - Primes and Multiplication 题解","content":"long long爆的好啊！！题目链接我们把要求的式子展开然后每次计算一列，由于是质数，当且仅当时，否则。由于同一列中都是相同的，所以只要计算指数之和就行了。直接分析代码：ll tmp = it;\r\nll cnt = 0;\r\nwhile (tmp <= n) {\r\n    cnt += (n / tmp);\r\n    if (n / tmp < it)\r\n    break;\r\n    tmp *= it;\r\n}\r\nif (cnt == 0)\r\n    continue;\r\nans = ans * binpow(it, cnt) % mod;的结果就是对于当前的tmp，中有几个可以整除tmp。\r\n对于每个数字都被筛过次，所以累加每一次的就是指数之和了。注意可能会爆long long所以乘之前要先检查一下（做的时候被卡了，直接自闭）。完整代码：#include<iostream>\r\n#include<vector>\r\n\r\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\r\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\r\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\r\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\r\n#define pb push_back\r\n#define ms(a, x) memset(a, x, sizeof(a))\r\n#define endl '\\n'\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nconst int INF = 0x3f3f3f3f;\r\ntypedef pair<int, int> pii;\r\n\r\nconst int mod = 1e9 + 7;\r\n\r\nlong long binpow(long long a, long long b) {\r\n  long long res = 1;\r\n  while (b > 0) {\r\n    if (b & 1)\r\n      res = (res * a) % mod;\r\n    a = (a * a) % mod;\r\n    b >>= 1;\r\n  }\r\n  return res;\r\n}\r\nint main() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(0);\r\n  vector<int> pr;\r\n  ll x, n;\r\n  cin >> x >> n;\r\n  if (x % 2 == 0) {\r\n    while (x % 2 == 0)\r\n      x /= 2;\r\n    pr.pb(2);\r\n  }\r\n  for (int i = 3; i * i <= x; i += 2) {\r\n    if (x % i == 0) {\r\n      pr.pb(i);\r\n      while (x % i == 0)\r\n        x /= i;\r\n    }\r\n  }\r\n  if (x > 1)\r\n    pr.pb(x);\r\n  ll ans = 1;\r\n  for (auto it : pr) {\r\n    ll tmp = it;\r\n    ll cnt = 0;\r\n    while (tmp <= n) {\r\n      cnt += (n / tmp);\r\n      if (n / tmp < it)\r\n        break;\r\n      tmp *= it;\r\n    }\r\n    if (cnt == 0) continue;\r\n    ans = ans * binpow(it, cnt) % mod;\r\n  }\r\n  cout << ans;\r\n  return 0;\r\n}"},{"id":"CF1128d","title":"CodeForces1228D - Complete Tripartite 题解","content":"这哈希长见识了。这个是在CF题解的评论区里看到的解法，非常震惊，不禁想到了学长和我们说过的话:\"哈希是一种思想\"。这次真的是体会到了。思路：定义给了这么多，其实就是把完全二分图的概念扩展成了完全三分图。有一点很重要的性质，就是如果两个点的直接连接的点是一样的话那么这两个点必定属于同一个集合，这样就可以用哈希的方法快速判断两个点是否具有相同的邻居: 通过给每个点一个值，那么一个点的哈希值就是该点邻居的点值的和，如果两个点的哈希值一样，那么就大概率肯定两个点的邻居是一样的。代码#include <iostream>\r\n#include <map>\r\n \r\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\r\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\r\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\r\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\r\n#define pb push_back\r\n#define ms(a, x) memset(a, x, sizeof(a))\r\n#define endl '\\n'\r\nusing namespace std;\r\n \r\ntypedef long long ll;\r\nconst int INF = 0x3f3f3f3f;\r\ntypedef pair<int, int> pii;\r\n \r\nconst int N=1e5+5;\r\nll po[N],ha[N];\r\nconst int mod=1e9+7; \r\nint main() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(0);\r\n    int n,m;\r\n    cin>>n>>m;\r\n    po[0]=1;\r\n    for1(i,n) po[i]=po[i-1]*29;\r\n    forn(i,m){\r\n        int x,y;\r\n        cin>>x>>y;\r\n        ha[x]+=po[y];\r\n        ha[y]+=po[x];\r\n    }\r\n    map<ll,ll> mp;\r\n    int idx=0;\r\n    for1(i,n){\r\n        if(ha[i]==0){\r\n            cout<<-1;\r\n            return 0;\r\n        }\r\n        if(mp[ha[i]]==0) mp[ha[i]]=++idx;\r\n    }\r\n    if(idx==3){\r\n        for1(i,n) cout<<mp[ha[i]]<<' ';\r\n    }else cout<<-1;\r\n  return 0;\r\n}"},{"id":"CF1131F","title":"Codeforces 1131F - Asya And Kittens 题解","content":"新年第一po！题解这个题我们用并查集来合并集合并用 或 来维护每个集合里面的元素。（理论上来说list应该快很多，但提交后的运行时间差不多）具体步骤就是：找到两个猫的祖先的id合并两个集合，并且拼接两个链表（或者数组）Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define _ <<' '<<\n#define de(x) cout<<#x<<\" = \"<<(x)<<endl\n#define de2(x,y) cout<<#x<<\" = \"<<(x) _ #y<<\" = \"<<y<<endl;\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst int N=15e4+5;\nint pre[N];\nint find(int x){\n    return pre[x]==x?x:pre[x]=find(pre[x]);\n}\nvoid join(int x,int y){\n    x=find(x),y=find(y);\n    pre[x]=y;\n}\nlist<int> v[N];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n    cin>>n;\n    for1(i,n) pre[i]=i,v[i].eb(i);\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        x=find(x),y=find(y);\n        v[x].splice(v[x].end(),v[y]);    \n        pre[y]=x;\n    }\n    for(auto it:v[find(1)]) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF1187D","title":"Codeforces 1187D - Subarray Sorting 题解","content":"题解我们可以做的最小的操作就是只排序相邻的两个元素，也就是说交换和如果。通过这种操作，我们可以把挪到位置，如果所有到的数都比小的话。明白了操作的本质之后我们就可以尝试从用a数组的数左往右构造b数组了。设当前的位置为:首先找到最左的位置使得，如果找不到那么答案是no。我们可以用set或者很多个vector维护位置。判断（最初的下标）中的最小值是否比小，我们可以用线段树实现这一操作。将设为无穷大。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(random_device{}());\ntemplate<typename... Args> void write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nstruct SegTree{\n    int n;\n    vector<int> t;\n    SegTree(int n_):n(n_){\n        t=vector<int>(2*n);\n    }\n    SegTree(vector<int> a){\n        n=a.size();\n        t=vector<int>(2*n);\n        for (int i=0;i<n;i++) t[n+i]=a[i];\n        for (int i = n - 1; i > 0; --i) t[i] = min(t[i<<1], t[i<<1|1]);\n    }\n\n    void update(int p, int value) {  // set value at position p\n        t[p += n] = value;\n        for (; p > 1; p >>= 1) t[p>>1] =min(t[p], t[p^1]);\n    }\n\n    int query(int l, int r) {  // sum on interval [l, r)\n        int res = 1e9;\n        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n            if (l&1) res =min(res, t[l++]);\n            if (r&1) res =min(res, t[--r]);\n        }\n        return res;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt;\n    cin>>tt;\n    while(tt--){\n        int n;\n        cin>>n;\n        vector<int> a(n),b(n);\n        set<pii> s;\n        forn(i,n){\n            cin>>a[i];\n            s.insert({a[i],i});\n        }\n        for(auto& it:b) cin>>it;\n        SegTree tr(a);\n        forn(i,n){\n            auto it=s.lower_bound({b[i],0});\n            if(it==s.end()||it->F!=b[i]||tr.query(0,it->S+1)<b[i]){\n                cout<<\"NO\\n\";\n                goto next;\n            }\n            tr.update(it->S,1e9);\n            s.erase(it);\n        }\n        cout<<\"YES\\n\";\nnext:;\n    }\n    return 0;\n}"},{"id":"CF1208D","title":"Codeforces 1208D- Restore Permutation 题解","content":"题目本身就很好，同时又能带来对树状数组的一些思考。题解我们要倒着处理，对于当前的，会存在一个，使得个还没有用过的最小的数的和为。那么当前的答案就是。可以用树状数组配二分找，也可以用树状数组配倍增黑科技求。Code二分#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate<typename... Args>\nvoid write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nstruct fenwick{\n    vector<ll> t;\n    int n;\n    fenwick(int n_):n(n_){\n        t=vector<ll>(n+1);\n    }\n    void update(int i,int x){\n        for(;i<=n;i+=i&-i){\n            t[i]+=x;\n        }\n    }\n    ll get(int i){\n        ll res=0;\n        for(;i>0;i-=i&-i) res+=t[i];\n        return res;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<ll> a(n);\n    for(auto& it:a) cin>>it;\n    fenwick tree(n);\n    for(int i=1;i<=n;i++) tree.update(i,i);\n    vector<int> ans(n);\n    for(int i=n-1;i>=0;i--){\n        int l=1,r=n;\n        while(l<=r){\n            int mid=(l+r)>>1;\n            if(tree.get(mid)<=a[i]) l=mid+1;\n            else r=mid-1;\n        }\n        ans[i]=l;\n        tree.update(l,-l);\n    }\n    for(auto it:ans) cout<<it<<' ';\n    return 0;\n}倍增#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate<typename... Args>\nvoid write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nstruct fenwick{\n    vector<ll> t;\n    int n;\n    fenwick(int n_):n(n_){\n        t=vector<ll>(n+1);\n    }\n    void update(int i,int x){\n        for(;i<=n;i+=i&-i){\n            t[i]+=x;\n        }\n    }\n    int search(ll prefix){\n        int pos=0;\n        ll sum=0;\n        for(int i=20;i>=0;i--){\n            if(pos+(1<<i)<=n&&(sum+t[pos+(1<<i)]<=prefix)){\n                pos+=(1<<i);\n                sum+=t[pos];\n            }\n        }\n        return pos+1;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<ll> a(n);\n    for(auto& it:a) cin>>it;\n    fenwick tree(n);\n    for(int i=1;i<=n;i++) tree.update(i,i);\n    vector<int> ans(n);\n    for(int i=n-1;i>=0;i--){\n        int x=tree.search(a[i]);\n        ans[i]=x;\n        tree.update(x,-x);\n    }\n    for(auto it:ans) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF1220D","title":"Codeforces 1220D - Alex and Julian 题解","content":"妈个唧看错题了SolutionIf there's only one element in the set, the graph is obvious bipartite. If there's more than two elements, the graph will contains some cycles due to each pair of elements.Suppose we have  and  in the set and the cycle will look like this:It easy to see that the length of the cycle is  which we want to be even. The length is even iff both  and  contains the same power of 2 in their factorizations. Otherwise  and  will have different parity, which means their sum is odd.(Try to prove by yourself)Finally we need to find the largest subset whose elements have the same power of two and remove the rest elements.题解一点中文不写也不太好，万一有人看呢……简单写一下要点吧，这题关键在于理解环是怎么形成的，环的长度是多少，以及为什么当且仅当两个数包含相同2的幂的时候环的长度是偶数。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate<typename... Args>\nvoid write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n    cin>>n;\n    vector<ll> cnt[60];\n    forn(i,n){\n        ll x;\n        cin>>x;\n        ll tmp=x;\n        int c=0;\n        while(x%2==0) x/=2,c++;\n        cnt[c].pb(tmp);\n    }\n    int mx=0,idx;\n    forn(i,60) if(size(cnt[i])>mx){\n        mx=size(cnt[i]);\n        idx=i;\n    }\n    cout<<n-size(cnt[idx])<<endl;\n    forn(i,60){\n        if(i!=idx){\n            for(auto it:cnt[i]) cout<<it<<' ';\n        }\n    }\n\n    return 0;\n}参考资料https://codeforces.com/blog/entry/69901https://codeforces.com/blog/entry/69899"},{"id":"CF1234E","title":"CodeForces1234E - Special Permutations 题解","content":"一开始做麻烦了，关键是写麻烦了还没过，好气哦。这题应该有很多不同的思路。我的想法是计算给出的数组中每一对相邻的数在之后的排列（Permutation）中距离的变化，然后只要以第一个排列的答案为基准，加上之后排列的距离变化就是后面排列的答案了。那么距离是如何变化的呢，我们设一对相邻的数中比较小的数是，比较大的数是 ，那么他们在第一个排列中的位置就是这样的:\n\n在第一个一直到第个排列中，和的位置都没有发生变化，自然距离也不变。但在第个排列中，成了第一个数：\n与的距离增加了。在第到个排列中，与中的某一个数会在最前面，所以与的距离比最开始少1。在第个排列中，r跑到了最前面：\n\n注意此时l的位置依然是，所以距离的变化是如果我们用一个数组a来保存所有排列中答案的变化，那么对于每一对,我们应该做如下三个操作：由于其中涉及到区间修改，所以我们可以用差分的思想来实现，并且由于只会查询一次，所以用最简单的数组就可以了，具体实现见代码:#include <iostream>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long ll;\nconst int INF = 0x3f3f3f3f;\ntypedef pair<int, int> pii;\n\nconst int N=2e5+5;\nll sum[N];\nint n,m;\nvoid rgadd(int l,int r,int x){\n    sum[l]+=x;\n    sum[r+1]-=x;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n    cin>>n>>m;\n    int x,last;\n    cin>>last;\n    ll ans=0;\n    forn(i,m-1){\n        cin>>x;\n        int mn=min(x,last),mx=max(x,last);\n        ans+=mx-mn;\n        last=x;\n        if(mx==mn) continue;\n        rgadd(mn,mn,mn-1);\n        rgadd(mx,mx,(mn-mx+mn));\n        if(mx-mn>1)\n        rgadd(mn+1,mx-1,-1);\n    }\n    for1(i,n){\n        ans+=sum[i];\n        cout<<an<<' ';\n    }\n  return 0;\n}"},{"id":"CF1249D2","title":"Codeforces 1249D2 - Too Many Segments (hard version) 题解","content":"越来越菜了题解贪心的策略是：遍历所有点，当我们发现有被超过条线段覆盖的点时，我们应该移除右端点最靠右的线段。为了实现我们的策略，我们需要一个数组 来存储以点开始的线段，和数组来存储以点结束的线段。我们同时还需要维护覆盖当前点的集合，以及一个优先队列来寻找右端点最右的线段。具体来说，就是对于每个点，我们先往集合里插入从这个点开始的线段，然后找出应该删除的线段并删除，最后从集合里移除以这个点结束的线段。Code#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N=2e5+5;\nvector<pii> open[N];\nvector<int> close[N];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n,k;\n    cin>>n>>k;\n    for(int i=1;i<=n;i++){\n        int l,r;\n        cin>>l>>r;\n        close[r].emplace_back(i);\n        open[l].emplace_back(r,i);\n    }\n    set<int> now;\n    vector<int> ans;\n    priority_queue<pii> pq;\n    for(int i=1;i<=N-1;i++){\n        for(auto it:open[i]){\n            now.insert(it.S);\n            pq.push(it);\n        }\n        while(now.size()>k){\n            pii tmp=pq.top();\n            pq.pop();\n            now.erase(tmp.S);\n            ans.emplace_back(tmp.S);\n        }\n        for(int x:close[i]){\n            now.erase(x);\n        }\n    }\n    cout<<ans.size()<<endl;\n    for(int it:ans) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF1263E","title":"Codeforces 1263E - Editor 题解","content":"解法首先，我们需要知道几点正确匹配的括号序列的性质：如果我们把左括号换成1，把右括号换成-1的话：序列的和为0任意前缀和不小于0前缀和中最大值就是嵌套最多的括号数根据这些性质，我们需要一个可以支持区间修改和查询最值的数据结构，很明显，就是线段树了。注意：整个序列的和可以通过查询最后一个元素的值来得到，query函数就是为了干这个的。Code#include <bits/stdc++.h>\n \n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define tr t[root]\nusing namespace std;\n \nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n \nconst int N=1e6;\nint n;\nstruct segt{\n    int l,r;\n    ll min,max,tag;\n}t[N<<2];\nvoid build(int root,int l,int r){\n    t[root].l=l;\n    t[root].r=r;\n    if(l==r) return;\n    int mid=(l+r)>>1;\n    build(root<<1,l,mid);\n    build(root<<1|1,mid+1,r);\n}\nvoid addtag(int p,int x){\n    t[p].max+=x;\n    t[p].min+=x;\n    t[p].tag+=x;\n}\nvoid spread(int p){\n    if(t[p].tag){\n        addtag(p<<1|1,t[p].tag);\n        addtag(p<<1,t[p].tag);\n        t[p].tag=0;\n    }\n}\nvoid update(int root,int l,int r,int x){\n    if(l<=t[root].l&&r>=t[root].r){\n        addtag(root,x);\n        return;\n    }\n    spread(root);\n    int mid=(t[root].l+t[root].r)>>1;\n    if(l<=mid) update(root<<1,l,r,x);\n    if(r>mid) update(root<<1|1,l,r,x);\n    tr.max=max(t[root<<1].max,t[root<<1|1].max);\n    tr.min=min(t[root<<1].min,t[root<<1|1].min);\n}\nint query(int root,int x){\n    if(tr.l==tr.r) return tr.max;\n    spread(root);\n    int mid=(tr.l+tr.r)>>1;\n    if(mid>=x) return query(root<<1,x);\n    else return query(root<<1|1,x);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n;\n    int pos=1;\n    vector<int> a(n+1);\n    build(1,1,n);\n    for1(i,n){\n        char ch;\n        cin>>ch;\n       int val=0;\n       if(ch=='L'){\n           pos=max(1,pos-1);\n           goto write;\n       }else if(ch=='R'){\n           pos++;\n           goto write;\n       }else if(ch=='(') val=1;\n       else if (ch==')') val=-1;\n       update(1,pos,n,val-a[pos]);\n       a[pos]=val;\n       write:\n       if(t[1].min<0||query(1,n)!=0) cout<<-1<<' ';\n       else cout<<t[1].max<<' ';\n    }\n    return 0;\n}"},{"id":"CF1265D","title":"Codeforces 1265D - Beautiful Sequence 题解","content":"比赛的时候太蠢了。题解这题的关键在于答案的第一个数要么是最小的数要么是第二小的数，两种情况都试一下。填某一位的时候，要么是上一位加一，要么是上一位减一，先试减1，如果没有减1可以用了就试加1，如果加一也没有了那就可以停止去尝试以另一个数开头的情况了。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tint a[5]={0},cnt[4],sum=0;\n    forn(i,4) cin>>cnt[i],a[i]=cnt[i],sum+=a[i];\n    int start;\n    forn(i,4){\n        if(a[i]){\n            start=i;\n            break;\n        }\n    }\n    vector<int> ans(sum);\n    bool flag=0;\n    for(int j=0;j<2&&!flag;j++){\n        forn(i,4) a[i]=cnt[i];\n        if(start+j>3||a[start+j]==0) break;\n        ans[0]=start+j;\n        a[start+j]--;\n        for(int i=1;i<sum;i++){\n            if(ans[i-1]==0){\n                if(a[1]){\n                    ans[i]=1;\n                    a[1]--;\n                }else break;\n            }else if(ans[i-1]==3){\n                if(a[2]){\n                    ans[i]=2;\n                    a[2]--;\n                }else break;\n            }else{\n                if(a[ans[i-1]-1]){\n                    ans[i]=ans[i-1]-1;\n                    a[ans[i-1]-1]--;\n                }else if(a[ans[i-1]+1]){\n                    ans[i]=ans[i-1]+1;\n                    a[ans[i-1]+1]--;\n                }else break;\n            }\n            if(i==sum-1) flag=1;\n        }\n        if(sum==1) flag=1;\n    }\n    if(flag){\n        cout<<\"YES\\n\";\n        for(int it:ans) cout<<it<<' ';\n    }else cout<<\"NO\";\n    return 0;\n}"},{"id":"CF1271C","title":"Codeforces 1271C - Shawarma Tent 题解","content":"题解很明显帐篷应该和学校挨着，所以我们可以用四个变量来记录学校的每一边有几个房子，最后输出最多的那一边即可。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tint n,x,y;\n    cin>>n>>x>>y;\n    int a=0,b=0,c=0,d=0;\n    forn(i,n){\n        int k,j;\n        cin>>j>>k;\n        if(j>x) a++;\n        else if(j<x) b++;\n        if(k>y) c++;\n        else if(k<y) d++;\n    }\n    int mx=max({a,b,d,c});\n    cout<<mx<<endl;\n    if(mx==a) cout<<x+1<<' '<<y;\n    else if(mx==b) cout<<x-1<<' '<<y;\n    else if(mx==c) cout<<x<<' '<<y+1;\n    else cout<<x<<' '<<y-1;\n    return 0;\n}"},{"id":"CF1271D","title":"Codeforces 1271D - Portals 题解","content":"题解首先我们要计算在每个城堡通关所需要的最少勇士的数量()， 这样我们就能知道在招募之后有多少自由支配的勇士()。这么计算。表示最后一个可以派勇士来守卫城堡的城堡。现在问题就转化成了如何分配勇士来守卫这些城堡。我们用贪心的思路：按照城堡的重要程度来守卫，对于城堡，如果我们能在前面找到有空闲的勇士那么我们就可以守护这个城堡。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tint n,m,k,tot;\n    cin>>n>>m>>k;\n    tot=k;\n    vector<int> a(n+1),b(n+1),last(n+1),fr(n+1),req(n+2);\n    vector<pii> c(n+1);\n    int flag=0;\n    for1(i,n){\n        cin>>a[i]>>b[i]>>c[i].F;\n        c[i].S=i;\n        if(tot<a[i]){\n            flag=1;\n        }else{\n            tot+=b[i];\n        }\n        last[i]=i;\n    }\n    forn(i,m){\n        int u,v;\n        cin>>u>>v;\n        last[v]=max(last[v],u);\n    }\n    if(flag) cout<<-1;\n    else{\n        for(int i=n;i>=1;i--){\n            if(i==n) req[i]=0;\n            else req[i]=max(a[i+1],req[i+1]-b[i+1]);\n        }\n        tot=k;\n        for1(i,n){\n            tot+=b[i];\n            fr[i]=tot-req[i];\n            tot=req[i];\n        }\n        sort(c.begin()+1,c.end(),[](pii a,pii b){\n            return a.F>b.F;\n        });\n        int ans=0;\n        for1(i,n){\n            int val=c[i].F,x=c[i].S;\n            int y=last[x];\n            while(!fr[y]&&y>0)y--;\n            if(y==0)continue;\n            fr[y]--;\n            ans+=val; \n        }\n        cout<<ans;\n    }\n    return 0;\n}"},{"id":"CF1278D","title":"Codeforces 1248D - Segment Tree 题解","content":"这跟暴力又有什么区别呢？题解我们先将所有线段的以的形式存到数组里，然后再将数组排序，然后遍历数组。同时我们还需要维护一个“开放的线段”的右端点的集合。当我们添加一条新的线段时，遍历集合，然后找到比新线段早结束的线段。这看起来是不是很像暴力？如果要是处理完所有线段是肯定超时的，但是如果交点的个数已经大于了，那么答案肯定是no，所以直接结束就行。最后还要检查一下图的连通性，用dfs或并查集都行。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N=5e5+5;\nvector<int> G[N];\nbool vis[N];\nvoid dfs(int v){\n    vis[v]=true;\n    for(auto it:G[v]){\n        if(!vis[it])\n            dfs(it);\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tint n;\n    cin>>n;\n    vector<pii> a(n),evs;\n    forn(i,n){\n        cin>>a[i].F>>a[i].S;\n        evs.eb(a[i].F,i);\n        evs.eb(a[i].S,i);\n    }\n    sort(evs.begin(),evs.end());\n    int cnt=0;\n    set<pii> cur;\n    for(auto it:evs){\n        if(cnt>=n) break;\n        if(cur.count(it)) cur.erase(it);\n        else{\n            int i=it.S;\n            int r=a[i].S;\n            for(auto j:cur){\n                if(j.F>r) break;\n                G[i].pb(j.S);\n                G[j.S].pb(i);\n                cnt++;\n                if(cnt>=n) break;\n            }\n            cur.insert({r,i});\n        }\n    }\n    dfs(0);\n    int tot=count(vis,vis+n,true);\n    cout<<(cnt==n-1&&tot==n?\"YES\":\"NO\");\n    return 0;\n}"},{"id":"CF1279D","title":"CodeForces 1279D - Santa's Bot 题解","content":"现在看来当时是真的菜，不过还是能学到一些奇怪的知识233题解最多有对，所以我们可以直接遍历所有的对。每一对有的概率被选中，所以一个合法的的概率是，其中是想要y礼物的孩子的个数。一个有意思的性质是，当与分母互质的时候成立，所以我们在遍历的时候可以直接把概率转换成然后加到答案上。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst int p=998244353;\nconst int N=1e6+5;\nvector<int> a[N];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n    cin>>n;\n    ll ans=0;\n    map<int,int> cnt;\n    vector<ll> inv(N+1);\n    inv[1]=1;\n    for(int i=2;i<=N;i++) inv[i]=ll(p-p/i)*inv[p%i]%p;\n    forn(i,n){\n        int k;\n        cin>>k;\n        a[i].resize(k);\n        for(auto& it:a[i]){\n            cin>>it;\n            cnt[it]++;\n        }\n    }\n    forn(i,n){\n        for(auto it:a[i]){\n            ll x=cnt[it]*inv[n]%p*inv[n]%p*inv[size(a[i])]%p;\n            ans=(ans+x)%p;\n        }\n    }\n    cout<<ans;\n    return 0;\n}"},{"id":"CF1282D","title":"Codeforces 1282D - Enchanted Artifact 题解","content":"InTerEStinG.题解首先我们可以用300个a和300个b来知道a和b的个数。同时答案的长度就是他们的和。然后假设答案都是a，如果我们把其中一位换成b那么答案要么是b个个数+1要么数b的个数-1，如果是-1那个那一位就是b否则是a。对所有位置重复上述操作就基本是答案了。注意此时我们用了次询问，超过了限制，但其实最后一位不用询问，用前面的信息就能算出来。"},{"id":"CF1284D","title":"Codeforces 1284D - New Year and Conference 题解","content":"题解题目本质是判断能否找到一对线段使得他们在一个维度上相交但不在另一维度上不相交。为了得到所有相交的线段，我们要知道对于所有时间点被哪些线段覆盖了。具体一点就是需要几个数组和，分别存的是以开头和结尾的线段。那么我们如何知道是否有一对线段不相交呢？我们还需要维护两个multiset，一个存当前线段的起点，另一个存终点。如果最右边的起点大于最左边的终点那么就说明有两个线段没重叠。最后别忘了离散化并且两个维度都要检查一下。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n\ntypedef vector<int> vi;\nbool check(vi& sa,vi& ea,vi& sb,vi& eb,int m){\n    vector<vector<int>> l(m),r(m);\n    int n=sa.size();\n    forn(i,n){\n        l[sa[i]].pb(i);\n        r[ea[i]].pb(i);\n    }\n    multiset<int,greater<int>> lmax;\n    multiset<int> rmin;\n    forn(i,m){\n        for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]);\n        if(!empty(lmax)&& *lmax.begin()> *rmin.begin()) return 0;\n        for(auto id:r[i]){\n            lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id]));\n        }\n    }\n    return 1;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> sa(n),sb(n),ea(n),eb(n);\n    forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]);\n    vector<int> time;time.reserve(4*n);\n    for(auto it:sa) time.pb(it);\n    for(auto it:ea) time.pb(it);\n    for(auto it:sb) time.pb(it);\n    for(auto it:eb) time.pb(it);\n    sort(all(time));\n    time.resize(unique(all(time))-time.begin());\n    forn(i,n){\n        sa[i]=lower_bound(all(time),sa[i])-time.begin();\n        ea[i]=lower_bound(all(time),ea[i])-time.begin();\n        sb[i]=lower_bound(all(time),sb[i])-time.begin();\n        eb[i]=lower_bound(all(time),eb[i])-time.begin();\n    }\n    if(check(sa,ea,sb,eb,time.size())&& check(sb,eb,sa,ea,time.size())) cout<<\"YES\";\n    else cout<<\"NO\";\n\n    return 0;\n}"},{"id":"CF1285C","title":"Codeforces 1285C - Fadi and LCM 题解","content":"long long开小了，血的教训。题解不难看出和必须是互质的，我们质因数分解X，最多有11个不同的质因数因为前12个质因数的积大于。我们可以暴力枚举所有的分配情况来得到最优的答案。另一种解法是遍历X的所有因数然后判断是否是1并更新答案。CodePrime factorization:#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e12;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tll x;\n    cin>>x;\n    vector<ll> vec;\n    for(ll f=2;f*f<=x;f++){\n        ll tmp=1;\n        while(x%f==0){\n            tmp*=f;\n            x/=f;\n        }\n        if(tmp!=1) vec.pb(tmp);\n    }\n    if(x>1)vec.pb(x);\n    ll aa=INF,ab=INF;\n    for(ll i=0;i<(1<<vec.size());i++){\n        ll a=1,b=1;\n        forn(j,vec.size()){\n            if((i&(1<<j))>0) a*=vec[j];\n            else b*=vec[j];\n        }\n        if(max(a,b)<max(aa,ab)){\n            aa=a;\n            ab=b;\n        }\n    }\n    cout<<ab<<' '<<aa;\n    return 0;\n}Looping factors:#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF=1e15;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tll x;\n    cin>>x;\n    ll ansa=INF,ansb=INF;\n    for(ll f=1;f*f<=x;f++){\n        if(x%f==0){\n            if(__gcd(f,x/f)==1){\n                if(x/f<ansb){\n                    ansa=f;\n                    ansb=x/f;\n                }\n            }\n        }\n    }\n    cout<<ansa<<' '<<ansb;\n    return 0;\n}"},{"id":"CF1285D","title":"Codeforces 1285D - Dr. Evil Underscores 题解","content":"Almost题解我们从最高位开始因为最高位对数的影响最大。我们需要把所有数分成两组，一组是当前位为1的数，另一组是当前位为0的数。如果其中一组是空的那么我们总是可以使这一位变成0然后到下一位。否则这一位总会有1，那么我们就需要对那两组解决同样的问题来知道这位是填1还是0，这很明显是个递归。设那两组的答案分别是和，当前在第位，那么答案就是。Code#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> a;\nint dfs(vector<int> v,int idx){\n    if(v.empty()) return 0;\n    if(idx==-1) return 0;\n    vector<int> a,b;\n    for(auto it:v){\n        if(it&(1<<idx)) a.pb(it);\n        else b.pb(it);\n    }\n    if(a.empty()) return dfs(b,idx-1);\n    if(b.empty()) return dfs(a,idx-1);\n    return min(dfs(a,idx-1),dfs(b,idx-1))+(1<<idx);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n    cin>>n;\n    a.resize(n);\n    for(int& it:a) cin>>it;\n    cout<<dfs(a,30);\n    return 0;\n}"},{"id":"CF1286B","title":"CodeForces 1286B/1287D - Numbers on Tree 题解","content":"想明白了以后其实很简单题解首先，如果大于的子树的大小，那么答案不存在。对于每个节点，我们建立一个数组，这个数组包含这个节点所有子树的节点，按照的大小排序（虽然我们现在还不知道的具体数值，我们只关心相对大小关系）。下一个问题就是如何组合子节点的数组，答案其实很简单：直接拼起来就可以了，因为每个子树是互相独立的。最后一步就是把当前的节点放进去，因为是已知的所以数组的第个数应该是.现在我们有了包含所有节点的数组，我们把 赋给 就行了。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n\nvector<vector<int>> G;\nvector<int> c;\nvector<int> dfs(int u){\n    vector<int> order;\n    for(auto it:G[u]){\n        auto child_order=dfs(it);\n        order.insert(order.end(),all(child_order));\n    }\n    if(size(order)<c[u]){\n        cout<<\"NO\";\n        exit(0);\n    }\n    order.insert(order.begin()+c[u],u);\n    return order;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    G.resize(n+1);\n    c.resize(n+1);\n    int R;\n    for1(i,n){\n        int pa;\n        cin>>pa>>c[i];\n        if(pa==0) R=i;\n        G[pa].push_back(i);\n    }\n    auto order=dfs(R);\n    vector<int> ans(n+1);\n    forn(i,n) ans[order[i]]=i+1;\n    cout<<\"YES\\n\";\n    for1(i,n) cout<<ans[i]<<' ';\n    return 0;\n}"},{"id":"CF1294D","title":"Codeforces 1294D - MEX maximizing 题解","content":"还是大佬的思路强啊。题解我们可以得到所有模相同的数通过加或减所以我们只关注。为了使mex最大化，我们需要从0开始尽可能长的连续的数。在模的意义下，也就是说。所以我们只需要保存同余类里的数的个数然后每次询问后尝试增加答案就行了。Code#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int q, x;\n    cin >> q >> x;\n    vector<int> cnt(x);\n    int ans = 0;\n    while (q--) {\n        int n;\n        cin >> n;\n        cnt[n % x]++;\n        while (cnt[ans % x]) {\n            cnt[ans % x]--;\n            ans++;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"},{"id":"CF1295D","title":"Codeforces 1295D - Same GCDs 题解","content":"FML题解让，所以我们有，不难发现，如果我们想要使， 必须是的倍数，设。 而且，和必须要互质，所以我们要找到从到中与互质的数的个数。对于那些大于的数，如果 那么。又因为，所以我们真正要算的是比小并且与互质的数的个数, 也就是。Code#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll Phi(ll m){\n\tll ans=m;\n\tfor(ll i=2;i*i<=m;i++){\n\t\tif(m%i==0){\n\t\t\tans-=ans/i;\n\t\t\twhile(m%i==0) m/=i;\n\t\t}\n\t}\n\tif(m>1) ans-=ans/m;\n\treturn ans;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint tt;\n\tcin>>tt;\n\twhile(tt--){\n\t\tll a,m;\n\t\tcin>>a>>m;\n\t\tcout<<Phi(m/gcd(a,m))<<endl;\n\n\t}\n    return 0;\n}"},{"id":"CF1300E","title":"Codeforces 1300E - Water Balance 题解","content":"题解这个题有点贪心的意思，我们可以把每一个水箱看作是一些由连续水箱组成的组，每个组一开始的大小都是1。如果当前的组的平均值比左边的组的平均值小的话，就合并这两个组。用栈存储之前组的大小和水量的和。Code#include <bits/stdc++.h>\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<ll> a(n);\n\tfor(auto& it:a) scanf(\"%lld\",&it);\n\tvector<double> ans(n);\n\tstack<pair<ll,ll>> st;\n\tforn(i,n){\n\t\tll sum=a[i],num=1;\n\t\twhile(!st.empty()&&(1.0*sum/num)<=(1.0*st.top().F/st.top().S)){\n\t\t\tsum+=st.top().F;\n\t\t\tnum+=st.top().S;\n\t\t\tst.pop();\n\t\t}\n\t\tst.push({sum,num});\n\t}\n\tint cnt=n-1;\n\twhile(!st.empty()){\n\t\tfor(int i=0;i<st.top().S;i++,cnt--){\n\t\t\tans[cnt]=1.0*st.top().F/st.top().S;\n\t\t}\n\t\tst.pop();\n\t}\n\tfor(auto it:ans) printf(\"%.9lf\\n\",it);\n\treturn 0;\n}"},{"id":"CF1324F","title":"CodeForces 1324F - Maximum White Subtree 题解","content":"好题！题解答案分两步dfs，第一个dfs用来计算： 的子树中的的子图的最大差值。稍微有点绕，其实题目中的“子树”应该叫子图比较合适，因为是无根树，说子图没什么意义。但我们dfs的时候其实是把图当成有根树，所以第一次dfs得到的答案只考虑了子树的贡献，剩余部分的贡献由第二个dfs算。其他部分的贡献看英文吧……懒得再写一遍了（逃）。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=2e5+5;\nvector<int> G[N];\nint ans[N],a[N],dp[N];\nvoid dfs1(int u,int fa){\n\tdp[u]=a[u];\n\tfor(auto it:G[u]){\n\t\tif(it!=fa){\n\t\t\tdfs1(it,u);\n\t\t\tdp[u]+=max(0,dp[it]);\n\t\t}\n\t}\n}\nvoid dfs2(int u,int fa,int pd){\n\tans[u]=dp[u]+pd;\n\tfor(auto v:G[u]){\n\t\tif(v!=fa){\n\t\t\tdfs2(v,u,max(ans[u]-max(dp[v],0),0));\n\t\t}\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tcin>>n;\n\tfor1(i,n) {\n\t\tcin>>a[i];\n\t\tif(!a[i]) a[i]=-1;\n\t}\n\tforn(i,n-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tdfs1(1,-1);\n\tdfs2(1,-1,0);\n\tfor1(i,n) cout<<ans[i]<<' ';\n\treturn 0;\n}"},{"id":"CF1358E","title":"Codeforces 1358E - Are You Fired? 题解","content":"好几天没更新了题解首先，先定义这个函数，也就是从开始往后连续个数的和。然后我们证明如果k和一个答案那么2k也是一个答案：。因此我们从能找到一个大于的答案。然后我们分类讨论，先考虑的情况。如果k是答案，因为，所以k+1也是一个答案，因此我们只要判断是不是答案就行了。最后，考虑，我们需要借助以下前缀和，定义 并且 . 我们需要找到  使得对于所有:因为，“窗口”之后的所有数字都是，所以上面的不等式可以写成这样：对于每一个，对应的k是，也就是说不等式左边的最大值如果小于，那么是一个答案。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    forn(i, (n + 1) / 2) {\n        cin >> a[i];\n    }\n    int x;\n    cin >> x;\n    for (int i = (n + 1) / 2; i < n; i++) a[i] = x;\n    vector<ll> ps(n + 1);\n    partial_sum(all(a), ps.begin() + 1);\n    if (ps.back() > 0) return cout << n, 0;\n    if (x >= 0) return cout << -1, 0;\n    ll N2 = n / 2, N1 = n - N2, sum = ps.back();\n    ll mx = -1e18;\n    for (int i = 0; i <= N1; i++) {\n        mx = max(mx, ps[i] + x * ll(n - i));\n        if (mx < sum + x * ll(n - i)) {\n            cout << n - i;\n            return 0;\n        }\n    }\n    cout << -1;\n    return 0;\n}"},{"id":"CF1367F2","title":"Codeforces 1367F2 - Flying Sort (Hard Version) 题解","content":"其实并不难，官方题解给的dp做法太吓人了题解首先定义一下“排了序的子序列”：它是一个原数组的子序列并且在排序之后的数组中是一个子数组。不难看出没用被移动过的元素会形成一个排了序的子序列。所以说如果我们找到最长的排了序的子序列那么答案就是最小的。因为我们只关注数字的相对大小，我们可以压缩一下数字，这样写起来会简单一些。然后每个数组开一个数组存改数字的所有下标。然后遍历所有数字，如果当前数字的最小下标大于之前数字的最大下标，那么这个数字的所有下标都可以加到当前的子序列里。否则我们需要重新开始一个子序列，以下两点需要注意：当前数字的一部分也是可以被加到刚才的子序列里的，比如说，第二个2就可以加进去变成。之前的数的一部分也可以被加到新的子序列里，比如，我们可以把第一个1加进来变成。但是还有一种特殊的情况：这个子序列只包含两个数的下标，并且这两个数的下标都是不完整的，比如。不难看出我们要取第一个数的一个前缀，取第二个数的一个后缀，那么我们就可以枚举前缀的位置然后找到对应的后缀。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define size(x) int(x.size())\n#define pb push_back\n\nusing namespace std;\nusing ll=long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt;\n    cin>>tt;\n    for1(T,tt){\n        int n;\n        cin>>n;\n        vector<int> a(n),d(n);\n        forn(i,n){\n            cin>>a[i];\n            d[i]=a[i];\n        }\n        //coord compression \n        sort(all(d));\n        d.resize(unique(all(d))-d.begin());\n        vector<vector<int>> pos(size(d));\n        forn(i,n){\n            a[i]=lower_bound(all(d),a[i])-d.begin();\n            pos[a[i]].push_back(i);\n        }\n\n        int r=-1,mxlen=0,curlen=0;\n        forn(i,size(d)){\n            if(pos[i][0]>r){\n                curlen+=size(pos[i]);\n            }else{\n                //extend to the right for the old sequence\n                auto j=lower_bound(all(pos[i]),r);\n                mxlen=max(mxlen,curlen+int(pos[i].end()-j));\n                //extend to the left for the new sequence\n                auto it=lower_bound(all(pos[i-1]),pos[i][0]);\n                curlen=int(it-pos[i-1].begin())+size(pos[i]);\n            }\n            mxlen=max(mxlen,curlen);\n            r=pos[i].back();\n        }\n        //check the special case: sequence containing only two numbers\n        forn(i,size(d)-1){\n            forn(j,size(pos[i])){\n                auto it=lower_bound(all(pos[i+1]),pos[i][j]);\n                mxlen=max(mxlen,j+1+int(pos[i+1].end()-it));\n            }\n        }\n        cout<<n-mxlen<<endl;\n    }\n    return 0;\n}"},{"id":"CF1369E","title":"题解Codeforces 1369E - DeadLee","content":"贪就完事了题解首先先算出：喜欢食物的人的个数。对于食物，如果，我们可以看出这些人无论你以什么顺序叫他们都有食物吃。所以我们尽可能的晚叫他们。整个过程有点像拓扑排序或者说是BFS：从所有满足的点开始，当访问新的点u时，减1，如果的话，就把u加进队列并把u加到叫人的名单里。最后反转名单就得到答案了。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define pb push_back\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,m;\n    cin>>n>>m;\n    vector<int> a(n),deg(n);\n    for(auto& i:a) cin>>i;\n    vector<vector<pii>> G(n);\n    forn(i,m){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        deg[x]++,deg[y]++;\n        G[x].pb({y,i});\n        G[y].pb({x,i});\n    }\n    vector<int> ans;\n    vector<int> vis(m);\n    queue<int> q;\n    forn(i,n){\n        if(deg[i]<=a[i]){\n            q.push(i);\n        }\n    }\n    while(!q.empty()){\n        int u=q.front();\n        q.pop();\n        for(auto [to,i]:G[u]){\n            if(!vis[i]){\n                ans.pb(i+1);\n                vis[i]=1;\n                deg[to]--;\n                if(deg[to]<=a[to]) q.push(to);\n            }\n        }\n    }\n    if(sz(ans)!=m) return cout<<\"DEAD\",0;\n    reverse(all(ans));\n    cout<<\"ALIVE\\n\";\n    for(auto it:ans) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF1432recap","title":"Recap of Educational Codeforces round 86","content":"数学太垃圾a写错了一个地方但样例过了也就没多想就交了，上来就吃一发wa……b题也差不多，简单想了想就开始写，也没考虑一些更复杂的情况，又吃一发wa。c题应该早点打表的，手动枚举还是费时间，而且还算错了一个，更加阻碍了发现规律。然后就是计数问题，算相等的情况确实没错，但有点过于想把公式一般化了，就应该按照自己的想法来，哪怕公式长一些，毕竟比赛追求的还是速度。d题贪心策略想错了，貌似经常犯这样的错误，一种策略是从大往小填。总结：还是应该即时决定取舍，重写往往比修改好（在卡题的时候），还有心态的问题。"},{"id":"CF1537E","title":"CodeForces 1537E - Erase and Extend 题解","content":"当时有个细节没想到，直接fst首先不难证明最终的字符串一定是由s的一个前缀不断重复得到的。所以我们可以枚举前缀的位置i,如果从i开始重复能使得新字符串比原字符串小的话这个位置就是有利的，同时根据字典序的规则，i肯定是越靠前越好，于是我们就得到了策略：将与比较，从比大的中找出i最小的那个。我比赛的时候一看这不就是后缀数组嘛，过了pretest心里美滋滋，结果system test的时候：那么问题出在哪了呢？我们来看这个例子。当时，是的一个前缀，看似比较小，但由于字符串是循环的所以补上一个之后变为就比s大了。所以这种情况也就是说的某个后缀等于前缀，我们接下来说明扔掉这个后缀可以获得更好的答案：假设这个后缀的长度是，与循环一次后会在与对应的位置发生不同，比如说循环之后是这样的其中竖线用来分隔循环，下划线是两个字符串开始不同的位置。可以证明,因为如果小于的话，由于，所以就是更好的位置，也就用不到考虑后缀的情况了，因此我们说明了扔掉后缀一定是更好的选择，所以我们要想办法让后缀在后缀数组中排在后面，于是我们可以在后面加一个大于所有字母的字符，这样就保证了如果有后缀是s的前缀的情况，后缀一定排在s后面。这样我们就得到了用比较无脑的用后缀数组的做法：#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> suffix_array(string s) {\n    s += \"#\";\n    int n = s.size(), N = n + 256;\n    vector<int> sa(n), ra(n);\n    for (int i = 0; i < n; i++)\n        sa[i] = i, ra[i] = s[i];\n    for (int k = 0; k < n; k ? k *= 2 : k++) {\n        vector<int> nsa(sa), nra(n), cnt(N);\n        for (int i = 0; i < n; i++) nsa[i] = (nsa[i] - k + n) % n;\n        for (int i = 0; i < n; i++) cnt[ra[i]]++;\n        for (int i = 1; i < N; i++) cnt[i] += cnt[i - 1];\n        for (int i = n - 1; i >= 0; i--) sa[--cnt[ra[nsa[i]]]] = nsa[i];\n\n        int r = 0;\n        for (int i = 1; i < n; i++) {\n            if (ra[sa[i]] != ra[sa[i - 1]]) r++;\n            else if (ra[(sa[i] + k) % n] != ra[(sa[i - 1] + k) % n])\n                r++;\n            nra[sa[i]] = r;\n        }\n        ra = nra;\n    }\n    sa.erase(sa.begin());\n    return sa;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    string s;\n    cin >> n >> k >> s;\n    s += '|';\n    auto sa = suffix_array(s);\n    int ii = find(sa.begin(), sa.end(), 0) - sa.begin();\n    int mn = *min_element(sa.begin() + ii + 1, sa.end());\n    for (int i = 0; i < k; i++)\n        cout << s[i % mn];\n    return 0;\n}但是后缀数组有点杀鸡用牛刀了，我们其实只用和做比较，所以另一种更简单的做法是用z函数，因为z函数求的是与整个字符串的最长公共前缀，所以比较前缀后下一个字符就能知道大小关系了。对于后缀的特殊情况，如果下一个字符的位置是也就说明 是的前缀，所以此时i的位置就是最佳位置。代码如下：#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> z_function(const string &s) {\n    int n = (int)s.size();\n    vector<int> z(n);\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\n        if (i <= r) z[i] = min(r - i + 1, z[i - l]);\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n            ++z[i];\n        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;\n    }\n    return z;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    string s;\n    cin >> n >> k >> s;\n    auto z = z_function(s);\n    for (int i = 1; i < n; i++) {\n        int f = z[i];\n        if (f + i >= n || s[f] < s[f + i]) {\n            s.erase(s.begin() + i, s.end());\n            break;\n        }\n    }\n    for (int i = 0; i < k; i++)\n        cout << s[i % s.size()];\n    return 0;\n}"},{"id":"CF1539F","title":"CodeForces 1539F - Strange Array 题解","content":"题目链接思路不难但线段树维护的内容需要一定的技巧。题解首先我们看如何取l和r才能使得答案最大。如果的话，在正中间，如果加入一个小于等于的数会让往右偏，反之，加入大于等于的数会往左偏，所以设[l, r]中大于  的数的个数为，小于的数的个数为，（等于的数可以算入或其中之一）我们要调整找到 的最大和最小值（分别对应在最左和最右）, 此时的答案为。由于互相独立，所以我们可以分别看两个区间，找到, 使得中的最大或最小。如果只找一个的答案的话，可以非常轻松的用线段树解决。但是对于整个数组的答案就行不通了，对于处理大小关系的题目一种常用的技巧是将整个数组排序，从小到大进行处理，这样就能保证之前的数都比当前数小，处理起来就会简单很多。对于本题我们需要一个数组，其中大于的位置设为，小于 的位置设为 ，对于每个位置 ，我们只要找到与的最大值与最小值。由于我们是从小到大处理的所以每次只改动一个位置(将1变成-1)，这样数组就变得非常易于维护。维护数组的题我们很容易想到用线段树，但这题的询问比较特别，看似是区间最值但函数对于不同的i也会有不同的值。这里我们用到一种在最大子段和的递归实现中用到的技巧，即对于线段树中的每个区间，维护区间和，从左/右端点开始的最大/最小子段和，用数学语言描述就是:令当前维护的区间是了解了定义之后，如何合并区间也就很容易想到了（具体看代码），此外为了方便实现，我们在代码中允许最大/最小子段不包含任何数。还有，由于相等的数可以随意排列，所以既可以算作大的数又可以算作小的数，所以要询问两遍一次当作小的数，一次当作大的数。代码：#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T> struct SegTree {\n    int n;\n    vector<T> t;\n\n    SegTree(int n_) : n(n_), t(4 * n) { build(1, 0, n - 1, vector(n, T())); }\n\n    template <typename U> SegTree(const vector<T> &v) : SegTree((int)v.size()) {\n        build(1, 0, n - 1, v);\n    }\n\n    void pull(int node) { t[node] = t[node << 1] + t[node << 1 | 1]; }\n\n    template <typename U>\n    void build(int node, int l, int r, const vector<U> &v) {\n        if (l == r) {\n            t[node] = T(v[l]);\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(node << 1, l, mid, v);\n        build(node << 1 | 1, mid + 1, r, v);\n        pull(node);\n    }\n\n    void set(int node, int i, T x, int l, int r) {\n        if (l == r) {\n            t[node] = x;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (i <= mid) set(node << 1, i, x, l, mid);\n        else\n            set(node << 1 | 1, i, x, mid + 1, r);\n        pull(node);\n    }\n\n    T get(int node, int ql, int qr, int l, int r) {\n        if (ql <= l && qr >= r) return t[node];\n\n        int mid = (l + r) >> 1;\n        if (qr <= mid) return get(node << 1, ql, qr, l, mid);\n        if (ql > mid) return get(node << 1 | 1, ql, qr, mid + 1, r);\n        return get(node << 1, ql, qr, l, mid) +\n               get(node << 1 | 1, ql, qr, mid + 1, r);\n    }\n    // wrapper\n    void set(int i, T x) {\n        assert(i >= 0 && i < n);\n        set(1, i, x, 0, n - 1);\n    }\n\n    T get(int l, int r) {\n        // assert(l >= 0 && l <= r && r < n);\n        if (l > r) return T();\n        return get(1, l, r, 0, n - 1);\n    }\n};\nstruct node {\n    int sum = 0;\n    int mxl = 0, mxr = 0, mnl = 0, mnr = 0;\n\n    node(int x = 0)\n        : sum(x), mxl(max(0, x)), mxr(mxl), mnl(min(0, x)), mnr(mnl) {}\n    node(int a, int b, int c, int d, int e)\n        : sum(a), mxl(b), mxr(c), mnl(d), mnr(e) {}\n\n    node operator+(const node &b) const {\n        return {\n            sum + b.sum,\n            max(mxl, sum + b.mxl),\n            max(b.mxr, b.sum + mxr),\n            min(mnl, sum + b.mnl),\n            min(b.mnr, b.sum + mnr),\n        };\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> pos(n + 1);\n    SegTree<node> st(n);\n    for (int i = 0; i < n; i++) {\n        st.set(i, node(1));\n    }\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        pos[x].push_back(i);\n    }\n    vector<int> ans(n);\n    for (int i = 1; i <= n; i++) {\n        for (auto p : pos[i]) {\n            auto r = st.get(p + 1, n - 1);\n            auto l = st.get(0, p - 1);\n            ans[p] = max(ans[p], (r.mxl + l.mxr + 1) / 2);\n        }\n        for (auto p : pos[i])\n            st.set(p, node(-1));\n        for (auto p : pos[i]) {\n            auto r = st.get(p + 1, n - 1);\n            auto l = st.get(0, p - 1);\n            ans[p] = max(ans[p], (-r.mnl - l.mnr) / 2);\n        }\n    }\n    for (auto x : ans)\n        cout << x << ' ';\n    return 0;\n}"},{"id":"CF1562D2","title":"Codeforces Round #741 D2(1562D2) - Two Hundred Twenty One (hard version) 题解","content":"一种比官方题解简单一点的做法前置知识确保你已经知道D1的做法题解由于我们已经知道了区间长度为偶数的时候最多只用去掉两个数而长度为奇数的时候要去掉一个数，所以对于区间长度为偶数的询问，我们可以去掉最后一个数从而将其转化为长度为奇数的询问，所以我们只要考虑如何求长度为奇数的询问即可。首先还是像D1一样求出前缀和，将的区间和记作 。不难得出去掉一个数之后区间和会变成。 我们想使其为0，所以要找到一个使得。将等式做如下变换：所以我们可以提用所有的 的值构建反查表（即给出的值查询符合条件的）。这样就可以做到 回答询问了（log来自于在反查表中二分）。代码#include <bits/stdc++.h>\nusing namespace std;\n\nvoid test_case() {\n    int n, q;\n    string s;\n    cin >> n >> q >> s;\n    vector<int> ps(n + 1);\n    vector<vector<int>> pos(4 * n + 1);\n    for (int i = 0; i < n; i++) {\n        int x = (s[i] == '+' ? 1 : -1);\n        ps[i + 1] = ps[i] + (i % 2 ? -x : x);\n    }\n    const int OFFSET = 2 * n;\n    for (int i = 1; i <= n; i++) {\n        pos[ps[i] + ps[i - 1] + OFFSET].push_back(i);\n    }\n\n    auto solve = [&](int l, int r) {\n        int x = ps[l] + ps[r] + OFFSET;\n        auto it = lower_bound(pos[x].begin(), pos[x].end(), l + 1);\n        assert(it != end(pos[x]) && *it <= r);\n        return *it;\n    };\n    while (q--) {\n        int l, r;\n        cin >> l >> r;\n        l--;\n        if (ps[r] - ps[l] == 0) {\n            cout << \"0\\n\";\n        } else {\n            if ((r - l) % 2) cout << \"1\\n\";\n            else cout << \"2\\n\" << r-- << ' ';\n            cout << solve(l, r) << '\\n';\n        }\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt = 1;\n    cin >> tt;\n    while (tt--) {\n        test_case();\n    }\n}"},{"id":"CF1575H","title":"COMPFEST 13 - Finals H. Holiday Wall Ornaments 题解","content":"从动态规划的角度考虑，很容易想到的一种状态是当前位置前的字符的状态，但这样的状态数为，显然不可行。不妨进一步想，当前字符串能对后面产生影响的只有与字符串 的前缀匹配的部分， 所以状态可以被优化为当前字符串的后缀与的前缀最大匹配长度。整个dp的状态为当前位置 , 作为子串已经出现了 次， 最长公共前后缀的长度为。为了实现转移，我们还需要预处理对于的所有后缀，在后面加0或者加1之后其后缀与的前缀的最大匹配状态。代码#include <bits/stdc++.h>\nusing namespace std;\nconst int N=500;\nshort dp[N+1][N+1][N+1], nxt[N+1][2];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    string a, b;\n    cin >> a >> b;\n    a=' '+a, b=' '+b;\n    for (int i=0; i<=m; i++) {\n        for (int x : {0, 1}) {\n            string s=b.substr(1, i)+char('0'+x);\n            for (int j=min(m, (int)size(s)); j>=1; j--) {\n                if (b.substr(1, j) == s.substr(size(s)-j)) {\n                    nxt[i][x]=j;\n                    break;\n                }\n            }\n        }\n    }\n    auto ckmin=[](auto& a, auto b) { if (b<a) a=b; };\n    for (int i=0; i<=n; i++)\n        for (int j=0; j<=n; j++)\n            for (int k=0; k<=m; k++) dp[i][j][k]=20000;\n    dp[0][0][0]=0;\n    for (int i=0; i<n; i++)\n        for (int j=0; j<=n; j++)\n            for (int k=0; k<=m; k++)\n                for (int x : {0, 1})\n                    ckmin(dp[i+1][j+(nxt[k][x]==m)][nxt[k][x]],\n                          dp[i][j][k]+(a[i+1]!='0'+x));\n    for (int i=0; i<=n-m+1; i++) {\n        auto ans=*min_element(dp[n][i], dp[n][i]+m+1);\n        cout << (ans==20000 ? -1 : ans) << \" \\n\"[i==n-m+1];\n    }\n}"},{"id":"CF1630C","title":"Codeforces Round #768 Div1C/Div2E Paint the Middle题解","content":"有段时间没做难一点的思维题了思路首先不难发现对于每个数来说，它的第一次和最后一次出现的位置是最重要的，因为使用其他位置的操作都可以使用两端的位置完成而且中间的位置的c值可以被两端变成1。我们将每个数的第一次和最后一次位置记作，于是我们就可以将每个数表示成一个线段 。对于一个线段的集合，如果这些线段的并集等于线段，我们称是连通的。 对于所有线段我们可以将其划分为极大连通子集对于每个子集其互不影响所以最终的答案就是每个子集的答案之和。对于每个极大子集，我们可能找到其最小子集使得中的线段的并等于 中线段的并，这样我们可以将尽量多的线段的端点的c值变成1.对于 中的线段我们可以证明最多可以将 个位置的c值变成1。代码#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> l(n, n), r(n, -1);\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        x--;\n        l[x] = min(l[x], i);\n        r[x] = max(r[x], i);\n    }\n    vector<pair<int, int>> b, c;\n    for (int i = 0; i < n; i++) {\n        if (l[i] < r[i]) b.emplace_back(l[i], r[i]);\n    }\n    sort(begin(b), end(b));\n    for (auto [l, r] : b) {\n        // 去除在包含在其他线段之内的线段\n        if (c.empty() || r > c.back().second) c.emplace_back(l, r);\n    }\n    int ans = 0, last = -1;\n    int m = size(c);\n    for (int i = 0; i < m; i++) {\n        if (c[i].first > last) { // 新的子集的第一个线段，端点的c值无法变成1\n            ans += c[i].second - c[i].first - 1;\n            last = c[i].second;\n        } else if (i == m - 1 || c[i + 1].first > last) { // 子集中的其他线段，左端点c值会变成1，会在之前被记入答案\n            ans += c[i].second - last - 1;\n            last = c[i].second;\n        }\n    }\n    cout << ans << endl;\n}"},{"id":"CF1646","title":"Codeforces Round #774 (Div. 2) A-E 题解","content":"A输出即可。代码B红色的和要尽量大而且个数要尽量小，所以排序之后红色的是一段后缀、蓝色是一段前缀而且长度比红色大1。枚举红色的个数即可。代码C由于，所以最多有15个阶乘数，我们可以枚举每个阶乘是否被用，然后剩下的数计算其二进制表示中1的个数。记得n是，所以要用。代码D除了n=2的情况，两个good节点就不能相邻的，所以问题就转化成了树上最大独立集问题，用树上dp可以轻松解决： 代表 的子树中最大独立集，其中choose为0或1代表u是否在独立集当中，转移为:"},{"id":"CF1713E","title":"Codeforces Round #812 E - Cross Swapping题解","content":"首先发现无论如何操作，只有关于对角线对称的两个位置（）会被交换，而且只有和的操作会影响这两个位置的交换。\n我们用来表示操作是否被执行，如果，我们不希望他们被交换所以我们希望，反之如果，我们希望他们交换所以我们希望。（代表按位异或）对于字典序的问题，往往采用从前往后贪心的策略。对于当前的我们要看之前的限制是否允许我们希望的值。那么如何判断呢？我们用一种让并查集的边带权的技巧，即边的权值代表，那么一个分量中任意两点的异或值即为路径上边的异或值。为了方便实现我们用节点代表到其父节点的边。在和时要更新边权（见代码）。条件就相当于给和中间连一条权值为的边，对应并查集的操作，如果加边之前两个点不在同一个连通分量，那么条件一定是可以满足的。如果在同一个分量中，那么说明已经是确定的，如果说明当前条件不能满足，我们就跳过它。其他实现细节见代码：#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UF {\n    vector<int> fa, sz, parity;\n    UF(int n) : fa(n), sz(n, 1), parity(n) { iota(fa.begin(), fa.end(), 0); }\n\n    array<int, 2> find(int x) {\n        if (fa[x] == x) {\n            return {x, 0};\n        }\n        auto [f, z] = find(fa[x]);\n        fa[x] = f;\n        parity[x] ^= z;\n        return {fa[x], parity[x]};\n    }\n\n    bool same(int x, int y) { return find(x) == find(y); }\n\n    bool join(int x, int y, int p) {\n        auto [fx, px] = find(x);\n        auto [fy, py] = find(y);\n        if (fx == fy) \n            return (px ^ py ^ p) == 0;\n        if (sz[fx] > sz[fy]) swap(fx, fy);\n        fa[fx] = fy;\n        parity[fx] = px ^ py ^ p;\n        sz[y] += sz[x];\n        return true;\n    }\n};\n\nvoid test_case() {\n    int n;\n    cin >> n;\n    vector a(n, vector(n, 0));\n    for (auto& v : a) {\n        for (auto& x : v) {\n            cin >> x;\n        }\n    }\n    UF uf(n);\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (a[i][j] == a[j][i]) {\n                continue;\n            }\n            if (uf.join(i, j, a[i][j] > a[j][i]) ^ (a[i][j] < a[j][i])) {\n                swap(a[i][j], a[j][i]);\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << a[i][j] << \" \\n\"[j == n - 1];\n        }\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt = 1;\n    cin >> tt;\n    while (tt--) {\n        test_case();\n    }\n}"},{"id":"CF1729G","title":"Codeforces Round #820 G. Cut Substrings 题解","content":"这是一道很直接的DP题但难点在于知道从哪转移。首先我们找到  在  中的所有出现位置并记为 。定义  为消除前  次出现所需要的最小次数，且第  个出现是完整消除的（这样可以避免数重），定义  为所对应的不同方法的次数。当考虑第  个出现时，首先找到  左边第一个不与  重叠的出现 ，也就是说  是最大的使  成立的数，我们不需要考虑  与  之间的位置转移，因为  到  之间的操作会使  位置的出现被部分消除。然后我们再找到最左边与  重叠的出现 ，也就是说  是最小是使  成立的数。  左边的出现就不能考虑了因为  出现就无法被消除，所以我们考虑从  到  位置的转移，最终的答案就是所有满足  且  为最小值的  的  的和，其中  为最后一个出现的位置，具体实现详见代码：#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    ModInt(long long v = 0) : val(v % MOD) { if (val < 0) val += MOD; };\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const {\n        auto a = val, m = MOD, u = 0, v = 1;\n        while (a != 0) { auto t = m / a; m -= t * a; swap(a, m); u -= t * v; swap(u, v); }\n        assert(m == 1);\n        return u;\n    }\n    ModInt pow(long long n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    friend ModInt operator+ (ModInt lhs, const ModInt& rhs) { return lhs += rhs; }\n    friend ModInt operator- (ModInt lhs, const ModInt& rhs) { return lhs -= rhs; }\n    friend ModInt operator* (ModInt lhs, const ModInt& rhs) { return lhs *= rhs; }\n    friend ModInt operator/ (ModInt lhs, const ModInt& rhs) { return lhs /= rhs; }\n    ModInt& operator+=(const ModInt& x) { if ((val += x.val) >= MOD) val -= MOD; return *this; }\n    ModInt& operator-=(const ModInt& x) { if ((val -= x.val) < 0) val += MOD; return *this; }\n    ModInt& operator*=(const ModInt& x) { val = int64_t(val) * x.val % MOD; return *this; }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<1'000'000'007>;\n\nvoid test_case() {\n    string s, t;\n    cin >> s >> t;\n    int n = s.size(), m = t.size();\n\n    vector<int> pos;\n    for (int i = 0; i + m <= n; i++) {\n        if (s.substr(i, m) == t) {\n            pos.push_back(i);\n        }\n    }\n    if (pos.empty()) {\n        cout << \"0 1\\n\";\n        return;\n    }\n\n    int sz = pos.size();\n    vector<int> f(sz, n);\n    vector<mint> g(sz);\n    for (int i = 0; i < sz; i++) {\n        int j = i - 1;\n        while (j >= 0 && pos[i] <= pos[j] + m - 1) {\n            j--;\n        }\n        if (j == -1) {\n            f[i] = 1;\n            g[i] = 1;\n        } else {\n            for (int k = j; k >= 0 && pos[j] <= pos[k] + m - 1; k--) {\n                if (f[k] + 1 < f[i]) {\n                    f[i] = f[k] + 1;\n                    g[i] = g[k];\n                } else if (f[k] + 1 == f[i]) {\n                    g[i] += g[k];\n                }\n            }\n        }\n    }\n    mint ans = 0;\n    int mn = f.back();\n    for (int i = sz - 1; i >= 0 && pos.back() <= pos[i] + m - 1; i--) {\n        if (f[i] < mn) {\n            mn = f[i];\n            ans = g[i];\n        } else if (f[i] == mn) {\n            ans += g[i];\n        }\n    }\n    cout << mn << ' ' << ans << '\\n';\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt = 1;\n    cin >> tt;\n    while (tt--) {\n        test_case();\n    }\n}"},{"id":"CF205C","title":"Codeforces 205D - Little Elephant and Interval 题解","content":"题解这种题常见套路就是写一个求1到x答案的函数然后最终答案就是。一种很妙的方法是我们可以通过在任意数字之后加一个第一位的数字从而得到题目要求的数字。所以如果x小于10那么答案就是x，否则答案就是去掉最后一位的x+9。如果最后一位小于第一位我们还要把答案减1。Code#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll cal(ll x){\n\tif(x<10) return x;\n\tstring st=to_string(x);\n\tll ans=9;\n\tif(st[0]>st.back()) ans--;\n\tans+=x/10;\n\treturn ans;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tll l,r;\n\tcin>>l>>r;\n\tcout<<cal(r)-cal(l-1);\n    return 0;\n}"},{"id":"CF208B","title":"Codeforces 208B - Solitaire 题解","content":"题解我们可以用记忆化dfs，dp状态是以下4个数：剩余的堆数、最右边三堆里顶端的牌。如果我们最后能剩下一堆的话答案就是yes。这题也可以用bfs，状态是dp是一样的，可能更好理解。Code#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=60;\nstring s[N];\nint dp[N][N][N][N];\nbool dfs(int n,int i,int j,int k){\n\tif(n==0) return true;\n\tint& d=dp[n][i][j][k];\n\tif(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false;\n\tif(s[i][0]==s[j][0]||s[i][1]==s[j][1]){\n\t\tif(dfs(n-1,i,k,n-3)){\n\t\t\treturn d=1;\n\t\t}\n\t}\n\tif(n>=3&&(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){\n\t\tif(dfs(n-1,j,k,i)){\n\t\t\treturn d=1;\n\t\t}\n\t}\n\td=-1;\n\treturn false;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n\tcin>>n;\n\tforn(i,n) cin>>s[i];\n\tcout<<(dfs(n-1,n-1,n-2,n-3)?\"YES\":\"NO\");\n    return 0;\n}"},{"id":"CF220B","title":"Little Elephant and Array - CodeForces220B 题解","content":"据说莫队更简单，然而不会啊题目链接考虑维护一个数组 ，使得  的和为询问  的答案。用线段树或树状数组都行（显然树状数组比较好写）。从左边开始遍历数组，当下标为  时，我们应该处理完所有  的询问。下面我们用一个最简单的例子来说明这个思路（下标从1开始）:"},{"id":"CF56E","title":"题解 Codeforces 56E - Domino Principle","content":"单调栈好题，非常独特的视角。题解栈中的每一个元素代表的是一组连续的多米诺，使得如果我们如果推倒x处的多米诺，从第i个开始一直到下一组的多米诺都会被推掉。所以我们处理新的多米诺的时候，要先把当前多米诺够得到的多米诺组弹出，最后栈顶的元素就是最近的够不着的多米诺，也就是当前多米诺的答案。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\nusing pii= pair<int, int>;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> x(n),h(n),id(n);\n    iota(all(id),0);\n    forn(i,n){\n        cin>>x[i]>>h[i];\n    }\n    sort(all(id),[&](int a,int b){return x[a]<x[b];});\n    vector<int> ans(n);\n    stack<pii> stk;\n    stk.push({1e9,n});\n    for(int i=n-1;i>=0;i--){\n        int ii=id[i];\n        while(!stk.empty()&&x[ii]+h[ii]>stk.top().F) stk.pop();\n        ans[ii]=(stk.empty()?1:stk.top().S-i);\n        stk.push({x[ii],i});\n    }\n    for(auto it:ans) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF5C","title":"CodeForces 5C - Longest Regular Bracket Sequence 题解","content":"注：下文的regular bracket sequence 简写为RBS首先对于每个右括号，我们找到与其配对的左括号（也就是该右括号往左最短的RBS）的位置（如果没有配对的就是-1），比如样例对应的位置就是下标012345678910111213括号)((())))(()())-1321-19118数组可以很容易的用一个栈求得。那么如何求最长的RBS呢？如果两个RBS相邻的话我们可以将他们合并为一个更长的RBS，于是我们可以再遍历一遍数组并尝试扩展RBS的长度，我们便得到了以结尾的最长的RBS，相应地更新答案即可。更新完之后的数组如下：(好吧其实没什么变化)下标012345678910111213括号)((())))(()())-1321-1998完整代码：#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin >> s;\n    int n = (int)s.size();\n    vector<int> l(n, -1);\n    vector<int> stk;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '(') stk.push_back(i); // 如果是左括号就入栈\n        else if (!stk.empty()) { // 否则就是右括号，如果栈非空就说明有对应的左括号\n            l[i] = stk.back();\n            stk.pop_back();\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        //如果当前RBS左边也有一个RBS就更新左端点\n        if (l[i] > 0 && l[l[i] - 1] != -1) l[i] = l[l[i] - 1];\n    }\n    int ans = 0, cnt = 1;\n    for (int i = 0; i < n; i++) {\n        if (l[i] == -1) continue;\n        int len = i - l[i] + 1;\n        if (len > ans) {\n            ans = len;\n            cnt = 1;\n        } else if (len == ans)\n            cnt++;\n    }\n    cout << ans << ' ' << cnt << '\\n';\n}"},{"id":"CF650B","title":"题解 Codeforces 650B/651D Image Preview","content":"有时候双指针会很简单题解不难看出所有打开的图片是所有图片的一个子段。我们可以枚举所有左端点然后用双指针找到最右的端点。Code#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,a,b,T;\n    string s;\n    rd( n,a,b,T,s);\n    int ans=0;\n    vector<ll> t(2*n);\n    forn(i,n){\n        t[i]=t[i+n]=(s[i]=='w'?b+1:1);\n    }\n    for(int i=1;i<2*n;i++) t[i]+=t[i-1];\n    int r=n;\n    auto f=[&](int l,int r){\n        ll res=t[r]-t[l-1];\n        ll di=r-l+min(r-n,n-l);\n        return res+di*a;\n    };\n    for(int l=1;l<=n;l++){\n        while(r+1<l+n&&f(l,r+1)<=T) r++;\n        if(f(l,r)<=T) ans=max(ans,r-l+1);\n    }\n    cout<<ans;\n    return 0;\n}"},{"id":"CF743D","title":"Codeforces 743D - Chloe and pleasant prizes 题解","content":"Good DFS problem.题解我们需要用DFS计算——的子树里所有数的和，以及 和 ——v的子树里所有的里的最大和次大值(不包括). 计算完之后更新答案。具体实现可以看代码，挺好理解的。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e18+1;\ntypedef pair<int, int> pii;\n\nconst int N=2e5+5;\nvector<int> G[N];\nll a[N],sum[N],mx[N];\n\nll ans=-INF;\nvoid dfs1(int v,int p){\n    sum[v]=a[v];\n    mx[v]=-INF;\n    ll m1=-INF,m2=-INF;\n    for(auto it:G[v]){\n        if(it==p) continue;\n        dfs1(it,v);\n        sum[v]+=sum[it];\n        mx[v]=max(mx[v],mx[it]);\n        ll val=mx[it];\n        if(val>m1) swap(m1,val);\n        if(val>m2) swap(m2,val);\n    }\n    if(m2> -INF) ans=max(ans,m1+m2);\n    mx[v]=max(mx[v],sum[v]);\n    return;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tint n;\n    cin>>n;\n    for1(i,n){\n        cin>>a[i];\n    }\n    forn(i,n-1){\n        int u,v;\n        cin>>u>>v;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    dfs1(1,1);\n    if(ans==-INF) cout<<\"Impossible\";\n    else cout<<ans;\n    return 0;\n}"},{"id":"CF762D","title":"Codeforces 762D - Maximum Path 题解","content":"题解这题如果不能往左走的话就是一个标准的dp题。所以我们要处理一下额外的情况。但是经观察我们可以发现我们不需要往左走超过两格，下面是一个简单的证明：所以我们只要额外考虑两种状态转移就行了，所有的状态转移如下：Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\nvoid inline cmax(ll& a,ll b){\n    if(b>a) a=b;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<vector<ll>> a(n+2,vector<ll>(3)),dp(n+2,vector<ll>(3,-1e18));\n    forn(j,3) for1(i,n) cin>>a[i][j];\n    dp[0][0]=0;\n    for(int i=1;i<=n;i++){\n        cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]);\n        cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]);\n        cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]);\n        cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]);\n        cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]);\n    }\n    cout<<dp[n][2];\n    return 0;\n}"},{"id":"CF813E","title":"CodeForces 813E - Army Creation题解","content":"很神奇的技巧题解我们创建一个辅助数组其中是后第个的下标，或者是如果后面没有个了。比如说，样例的辅助数组是.考虑询问，对于，如果，说明后出现了多于次，所以不应该在军队里。 所以答案是。找区间里小于的数的个数可以用主席树或者wavelet树解决。Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct PST {\n    int n, tot=0;\n    vector<int> lc, rc, sum, roots; // left child, right child\n    PST(int n_) : n(n_), lc(n<<5), rc(n<<5), sum(n<<5), roots(1) {\n        build(0, n-1, roots[0]);\n    }\n    void pushup(int rt) {\n        sum[rt] = sum[lc[rt]] + sum[rc[rt]];\n    }\n    void build(int l, int r, int& rt) {\n        rt = ++tot;\n        if (l == r) return;\n        int mid = (l + r) >> 1;\n        build(l, mid, lc[rt]);\n        build(mid + 1, r, rc[rt]);\n        pushup(rt);\n    }\n    void update(int pos, int val, int l, int r, int old, int& rt) {\n        rt = ++tot;\n        lc[rt] = lc[old];\n        rc[rt] = rc[old];\n        if (l == r) {\n            sum[rt] = sum[old] + val;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        if (pos <= mid) update(pos, val, l, mid, lc[old], lc[rt]);\n        else update(pos, val, mid + 1, r, rc[old], rc[rt]);\n        pushup(rt);\n    }\n    int update(int pos, int val) { // return the root of the new version\n        int new_root;\n        update(pos, val, 0, n-1, roots.back(), new_root);\n        roots.push_back(new_root);\n        return new_root;\n    }\n    int query(int u, int v, int l, int r, int k) {\n        if (l==r) return sum[v]-sum[u];\n        int mid=(l+r)/2, x=sum[lc[v]]-sum[lc[u]];\n        if (mid<k) return x+query(rc[u], rc[v], mid+1, r, k);\n        return query(lc[u], lc[v], l, mid, k);\n    }\n    int query(int u, int v, int k) {\n        return query(u, v, 0, n-1, k);\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin>>n>>k;\n    constexpr int M=1e5;\n    vector<vector<int>> pos(M);\n    vector<int> a(n, n);\n    for (int i=0; i<n; i++) {\n        int x;\n        cin>>x;\n        pos[x].push_back(i);\n        if (pos[x].size()>k) {\n            a[*(pos[x].rbegin()+k)]=i;\n        }\n    }\n    int last=0;\n    vector<int> roots(n+1);\n    roots[0]=1;\n    PST tr(n+1);\n    for (int i=0; i<n; i++) {\n        roots[i+1]=tr.update(a[i], 1);\n    }\n    int q;\n    cin>>q;\n    while (q--) {\n        int x, y;\n        cin>>x>>y;\n        int l=(x+last)%n, r=(y+last)%n;\n        if (l>r) swap(l, r);\n        last=(r-l+1)-tr.query(roots[l], roots[r+1], r);\n        cout<<last<<'\\n';\n    }\n    return 0;\n}"},{"id":"COMPFEST14","title":"COMPFEST 14部分题解（ABCEFGHKLM）","content":"A. Accumulation of Dominoes签到题，如果  输出 ，否则输出 。B. Basketball Together贪心，排序后用大的数配小的数。C. Circular Mirror直径所对圆周角为90度，所以当直径上两个点颜色相同时，其他的点不能与直径的颜色相同。设直径的条数为 ，于是我们可以枚举直径颜色相同的条数 ，首先选 条直径，然后为每条直径选一个颜色，然后从剩下的  个颜色中给剩下的每条直径选两个颜色，再从剩下的 个颜色中给每个剩下的非直径的点选一个颜色，所以答案为:\nE. Electrical Efficiency考虑每条边对答案的贡献，遍历所有质数，设当前的质数为 ，令  为因子含  的点的集合，当  中任意两点的路径经过某条边时，该边会对答案产生1的贡献。以任意点为根，对边  （ 为  的父亲）来说，有（ 为  子树的大小）个三元组经过这条边，用树型dp就能求解，但要是对于每个质数都遍历一遍整个树的话必然要超时所以我们以  中的点构造虚树，在虚树上跑dp，由于  最多有  个不重复的质因子，所以所有  的和是  的。#include <bits/stdc++.h>\n\nconstexpr unsigned lg(int x) {\n    return sizeof(int) * 8 - 1 - __builtin_clz(x);\n}\nconstexpr unsigned lg(unsigned int x) {\n    return sizeof(unsigned) * 8 - 1 - __builtin_clz(x);\n}\nconstexpr unsigned lg(long x) {\n    return sizeof(long) * 8 - 1 - __builtin_clzl(x);\n}\nconstexpr unsigned lg(unsigned long x) {\n    return sizeof(unsigned long) * 8 - 1 - __builtin_clzl(x);\n}\nconstexpr unsigned lg(long long x) {\n    return sizeof(long long) * 8 - 1 - __builtin_clzll(x);\n}\nconstexpr unsigned lg(unsigned long long x) {\n    return sizeof(unsigned long long) * 8 - 1 - __builtin_clzll(x);\n}\nconstexpr unsigned ceil_lg(int n) {\n    return n == 0 ? 0 : 32 - __builtin_clz(n - 1);\n}\n\ntemplate <typename T> struct SparseTable {\n    size_t n, logn;\n    std::vector<std::vector<T>> v;\n    std::function<T(T, T)> F;\n    SparseTable() = default;\n    SparseTable(const std::vector<T> &a, std::function<T(T, T)> func)\n        : n(a.size()), logn(lg(n)), v(logn + 1, std::vector<T>(n + 1)), F(func) {\n        v[0] = a;\n        for (size_t i = 1; i <= logn; i++)\n            for (size_t j = 0; j + (1 << i) - 1 < n; j++)\n                v[i][j] = F(v[i - 1][j], v[i - 1][j + (1 << (i - 1))]);\n    }\n    T query(size_t l, size_t r) {\n        assert(l < r);\n        assert(l < n);\n        assert(r <= n);\n        int s = lg(r - l);\n        return F(v[s][l], v[s][r - (1 << s)]);\n    }\n};\n\nstruct EulerLCA {\n    int n;\n    std::vector<int> pos, seq, dep;\n    SparseTable<int> st;\n    EulerLCA(const std::vector<std::vector<int>>& g, int root) : n(g.size()), pos(n), dep(n) {\n        seq.reserve(2 * n);\n        dfs(root, root, g);\n        st = SparseTable<int>(seq, [&](int u, int v) { return pos[u] < pos[v] ? u : v; });\n    }\n    void dfs(int u, int p, const std::vector<std::vector<int>>& g) {\n        pos[u] = seq.size();\n        seq.push_back(u);\n        for (auto v : g[u]) {\n            if (v == p) continue;\n            dep[v] = dep[u] + 1;\n            dfs(v, u, g);\n            seq.push_back(u);\n        }\n    }\n    int lca(int u, int v) {\n        if (pos[u] > pos[v]) std::swap(u, v);\n        return st.query(pos[u], pos[v] + 1);\n    }\n};\nstruct VirtualTree {\n    int n;\n    EulerLCA lca;\n    std::vector<std::vector<int>> tree;\n    VirtualTree(const std::vector<std::vector<int>> &g, int root)\n        : n(g.size()), lca(g, root), tree(n) {}\n    auto build_tree(const std::vector<int> &vertices)\n        -> std::pair<int, const std::vector<std::vector<int>> &> {\n        auto v(vertices);\n        std::sort(v.begin(), v.end(), [&](int u, int v) { return lca.pos[u] < lca.pos[v]; });\n        int len = v.size();\n        for (int i = 1; i < len; i++) {\n            v.push_back(lca.lca(v[i - 1], v[i]));\n        }\n        std::sort(v.begin(), v.end(), [&](int u, int v) { return lca.pos[u] < lca.pos[v]; });\n        v.erase(std::unique(v.begin(), v.end()), v.end());\n        for (int i = 1; i < (int)v.size(); i++) {\n            tree[lca.lca(v[i - 1], v[i])].push_back(v[i]);\n        }\n        return {v[0], tree};\n    }\n    void clear(const std::vector<int> v) {\n        for (auto u : v) {\n            tree[u].clear();\n        }\n    }\n    void clear(int root) {\n        for (auto v : tree[root]) {\n            clear(v);\n        }\n        tree[root].clear();\n    }\n};\ntemplate <typename mint> struct Factorial {\n    std::vector<mint> fac, invfac;\n    Factorial(int n) : fac(n + 1), invfac(n + 1) {\n        fac[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fac[i] = fac[i - 1] * i;\n        }\n        invfac[n] = fac[n].inv();\n        for (int i = n - 1; i >= 0; i--) {\n            invfac[i] = invfac[i + 1] * (i + 1);\n        }\n    }\n    mint C(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        assert((int)size(fac) > n);\n        return fac[n] * invfac[n - k] * invfac[k];\n    }\n    mint P(int n, int m) {\n        assert(!fac.empty());\n        return fac[n] * invfac[n - m];\n    }\n    template<typename... Args>\n    constexpr mint eval(Args... args) {\n        return ((args > 0 ? fac[args] : invfac[-args]) * ...);\n    }\n};\nusing namespace std;\nusing ll = long long;\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    ModInt(ll v = 0) : val(v % MOD) { if (val < 0) val += MOD; };\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const {\n        auto a = val, m = MOD, u = 0, v = 1;\n        while (a != 0) { auto t = m / a; m -= t * a; swap(a, m); u -= t * v; swap(u, v); }\n        assert(m == 1);\n        return u;\n    }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    friend ModInt operator+ (ModInt lhs, const ModInt& rhs) { return lhs += rhs; }\n    friend ModInt operator- (ModInt lhs, const ModInt& rhs) { return lhs -= rhs; }\n    friend ModInt operator* (ModInt lhs, const ModInt& rhs) { return lhs *= rhs; }\n    friend ModInt operator/ (ModInt lhs, const ModInt& rhs) { return lhs /= rhs; }\n    ModInt& operator+=(const ModInt& x) { if ((val += x.val) >= MOD) val -= MOD; return *this; }\n    ModInt& operator-=(const ModInt& x) { if ((val -= x.val) < 0) val += MOD; return *this; }\n    ModInt& operator*=(const ModInt& x) { val = int64_t(val) * x.val % MOD; return *this; }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<998244353>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    int mx = 0;\n    for (auto& x : a) {\n        cin >> x;\n        mx = max(mx, x);\n    }\n    vector<int> minp(mx + 1), primes;\n    for (int i = 2; i <= mx; i++) {\n        if (minp[i] == 0) {\n            minp[i] = i;\n            primes.push_back(i);\n        }\n        for (auto p : primes) {\n            if (i * p > mx) {\n                break;\n            }\n            minp[i * p] = p;\n            if (i % p == 0) {\n                break;\n            }\n        }\n    }\n    vector<vector<int>> p(mx + 1);\n    for (int i = 0; i < n; i++) {\n        int x = a[i];\n        while (x > 1) {\n            int f = minp[x];\n            p[f].push_back(i);\n            while (x % f == 0) {\n                x /= f;\n            }\n        }\n    }\n    vector<vector<int>> g(n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    VirtualTree tr(g, 0);\n    Factorial<mint> f(n);\n    mint ans = 0;\n    for (int fac = 1; fac <= mx; fac++) {\n        if (p[fac].size() < 3) {\n            continue;\n        }\n        auto res = tr.build_tree(p[fac]);\n        auto root = res.first;\n        const auto& tree = res.second;\n        auto dfs = [&](auto& slf, int u) -> int {\n            int size = a[u] % fac == 0;\n            for (auto v : tree[u]) {\n                int sz = slf(slf, v);\n                size += sz;\n                ans += (tr.lca.dep[v] - tr.lca.dep[u]) * (f.C(p[fac].size(), 3) - f.C(sz, 3) - f.C(p[fac].size() - sz, 3));\n            }\n            return size;\n        };\n        dfs(dfs, root);\n        tr.clear(root);\n    }\n    cout << ans << '\\n';\n}F. Field PhotographyOR的条件很好满足：只要先都往右移动若干个  就可以了，不难看出最小的移动单位为（Least Significant Bit，最低位），所以线段覆盖的点的位置模是不变的，于是这个问题就变成了模意义下的线段覆盖问题。由于只有31种情况，可以预处理然后回答询问。#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<int> ans(30);\n\n    vector<int> l(n), r(n);\n    for (int i = 0; i < n; i++) {\n        cin >> l[i] >> r[i];\n        l[i]--;\n    }\n\n    for (int j = 0; j < 30; j++) {\n        vector<array<int, 2>> events;\n        for (int i = 0; i < n; i++) {\n            if (r[i] - l[i] >= (1 << j)) {\n                events.push_back({0, 1});\n            } else {\n                int L = l[i] % (1 << j);\n                int R = r[i] % (1 << j);\n                if (L < R) {\n                    events.push_back({L, 1});\n                    events.push_back({R, -1});\n                } else {\n                    events.push_back({0, 1});\n                    events.push_back({L, 1});\n                    events.push_back({R, -1});\n                }\n            }\n        }\n\n        int cur = 0;\n        sort(events.begin(), events.end());\n        for (auto [_, v] : events) {\n            cur += v;\n            ans[j] = max(ans[j], cur);\n        }\n    }\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int x;\n        cin >> x;\n        cout << ans[__builtin_ctz(x)] << \"\\n\";\n    }\n}G. Garage不会数学，打表+OEIS查的。。。H. Hot Black Hot White首先不难证明 。于是题目中的等式就变成了:然后可以发现  只可能是0或者1。于是我们得到两种情况：如果  的石头的个数小于等于的话，将所有  的时候分到一组并取就可以避免上述等式成立。否则  的石头的个数小于等于，类似地我们将 的石头分到一组并取。#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> a(2);\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        if (x % 3 == 0) {\n            a[0].push_back(i);\n        } else {\n            a[1].push_back(i);\n        }\n    }\n    string ans(n, '0');\n    if (a[0].size() <= n / 2) {\n        cout << \"0\\n\";\n        for (auto& x : a[0]) ans[x] = '1';\n        for (int i = 0; i < n / 2 - a[0].size(); i++){\n            ans[a[1][i]] = '1';\n        }\n    } else {\n        cout << \"2\\n\";\n        for (auto& x : a[1]) ans[x] = '1';\n        for (int i = 0; i < n / 2 - a[1].size(); i++){\n            ans[a[0][i]] = '1';\n        }\n    }\n    cout << ans << endl;\n}K. Kingdom of Criticism由于第三种询问会使高度的种类减小2到若干种而第一种询问只会使高度的种类增加1，所以所有第三种操作减少的高度的种类不超过  (为初初始的高度的种类)。所以可以将高度相同的建筑归为一组，第三种操作也就相当于把高度在  中的建筑与高度为  的建筑或高度为  的建筑合并（根据离哪个端点近）。于是我们想到可以使用并查集来实现合并操作，同时记录每个高度的组在并查集中所对应的树的根,这样可以快速知道高度在并查集中所对应的树。但第一种询问对应的却是一种删除的操作，但并查集不支持删除操作，所以我们直接给建筑  赋予一个新的编号，这样就变相实现了删除的效果。#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UF {\n    vector<int> fa, sz;\n    UF(int n) : fa(n), sz(n, 1) { iota(fa.begin(), fa.end(), 0); }\n\n    int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\n    bool same(int x, int y) { return find(x) == find(y); }\n\n    bool join(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return false;\n        // if (sz[x] > sz[y]) swap(x, y);\n        fa[x] = y;\n        sz[y] += sz[x];\n        return true;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    map<int, int> leader;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    int q;\n    cin >> q;\n    UF uf(n + q);\n    vector<int> value(n + q), cur(n);\n    for (int i = 0; i < n; i++) {\n        value[i] = a[i];\n        cur[i] = i;\n        if (leader.count(a[i])) {\n            uf.join(i, leader[a[i]]);\n        } else {\n            leader[a[i]] = i;\n        }\n    }\n    int cnt = n;\n    while (q--) {\n        int op;\n        cin >> op;\n        if (op == 1) {\n            int k, w;\n            cin >> k >> w;\n            k--;\n            cur[k] = cnt++;\n            value[cur[k]] = w;\n            if (leader.count(w)) {\n                uf.join(cur[k], leader[w]);\n            } else {\n                leader[w] = cur[k];\n            }\n        } else if (op == 2) {\n            int k;\n            cin >> k;\n            k--;\n            cout << value[uf.find(cur[k])] << '\\n';\n        } else {\n            int l, r;\n            cin >> l >> r;\n            auto it = leader.lower_bound(l);\n            while (it != end(leader) && it->first <= r) {\n                int change_to = it->first <= (l + r) / 2 ? l - 1 : r + 1;\n                if (leader.contains(change_to)) {\n                    uf.join(it->second, leader[change_to]);\n                } else {\n                    leader[change_to] = it->second;\n                    value[it->second] = change_to;\n                }\n                it = leader.erase(it);\n            }\n        }\n    }\n}L. Lemper Cooking Competition观察到操作对于前缀和数组的影响就是交换位置  与位置 ，由于最后要求  为非负，那么最终的前缀和数组便是非降的，于是问题就变成了数逆序对，但要注意位置  与位置  是不能交换的，提前特判一下即可。#include <algorithm>\n#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) begin(x),end(x)\nusing ll = long long;\n\ntemplate <typename T> struct fenwick {\n    int n; std::vector<T> t;\n    fenwick(int n_) : n(n_), t(n + 1) {}\n    fenwick(const std::vector<T> &v) : fenwick((int)v.size()) {\n        for (int i = 1; i <= n; i++) {\n            t[i] += v[i - 1];\n            int j = i + (i & -i);\n            if (j <= n) t[j] += t[i];\n        }\n    }\n    void add(int i, T x) {\n        assert(i >= 0 && i < n);\n        for (i++; i <= n; i += i & -i) {\n            t[i] += x;\n        }\n    }\n    template <typename U = T> U query(int i) {\n        assert(i >= 0 && i < n);\n        U res{};\n        for (i++; i > 0; i -= i & -i)\n            res += t[i];\n        return res;\n    }\n    template <typename U = T> U query(int l, int r) {\n        assert(l >= 0 && l <= r && r < n);\n        return query<U>(r) - (l ? query<U>(l - 1) : U{});\n    }\n    int search(T prefix) { // finds first pos s.t. sum(0, pos)>=prefix\n        int pos = 0;\n        T sum = 0;\n        for (int i = __lg(n); i >= 0; i--) {\n            // could change < to <= to make it find upper bound\n            if (pos + (1 << i) <= n && (sum + t[pos + (1 << i)] < prefix)) {\n                pos += (1 << i);\n                sum += t[pos];\n            }\n        }\n        return pos;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    for (auto& x : a) cin >> x;\n    for (int i = 1; i < n; i++) {\n        a[i] += a[i - 1];\n    }\n    auto b = a;\n    sort(begin(b), end(b) - 1);\n    if (!is_sorted(all(b)) || b[0] < 0) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    b.erase(unique(all(b)), end(b));\n    fenwick<int> tr(b.size());\n    ll ans = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        auto idx = lower_bound(all(b), a[i]) - begin(b);\n        if (idx > 0)\n            ans += tr.query(idx - 1);\n        tr.add(idx, 1);\n    }\n    cout << ans << '\\n';\n}M. Moving Both Hands新建一层图为原图的反向图，然后每个节点连一条从原图到新图，长度为0的边，然后跑最最短路看到新图每个节点的距离即可。#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr long long INF = 1e18;\ntemplate <typename G>\nstd::vector<long long> dijkstra(const G &g, int start) {\n    std::vector dis(g.size(), INF);\n    using node = std::pair<long long, int>;\n    std::priority_queue<node, std::vector<node>, std::greater<>> q;\n    dis[start] = 0;\n    q.emplace(0, start);\n    while (!q.empty()) {\n        auto [d, u] = q.top();\n        q.pop();\n        if (d != dis[u]) continue;\n        for (auto [v, cost] : g[u]) {\n            if (dis[v] > dis[u] + cost) {\n                dis[v] = dis[u] + cost;\n                q.emplace(dis[v], v);\n            }\n        }\n    }\n    return dis;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<pair<int, int>>> g(n * 2);\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        u--, v--;\n        g[u].push_back({v, w});\n        g[v + n].push_back({u + n, w});\n    }\n    for (int i = 0; i < n; i++) {\n        g[i].push_back({i + n, 0});\n    }\n    auto dis = dijkstra(g, 0);\n    for (int i = n + 1; i < 2 * n; i++) {\n        cout << (dis[i] == INF ? -1 : dis[i]) << \" \";\n    }\n    cout << endl;\n}"},{"id":"CP_tricks","title":"算法竞赛杂记","content":"仅用做提醒自己，看不懂概不负责～LIS 和 LNDSint LIS(vector<int> &a) {\n    vector<int> dp;\n    for (auto it : a) {\n        auto pos = lower_bound(begin(dp), end(dp), it);\n        if (pos == dp.end()) dp.push_back(it);\n        else\n            *pos = it;\n    }\n    return dp.size();\n}\n\nint LNDS(vector<int> &a) {\n    vector<int> dp;\n    for (auto it : a) {\n        auto pos = upper_bound(begin(dp), end(dp), it);\n        if (pos == dp.end()) dp.push_back(it);\n        else\n            *pos = it;\n    }\n    return dp.size();\n}Maximum subarray sumint cur = 0, max_sum = 0; // max_sum=-1e8 if at least one element must be chosen\nfor (auto it : a) {\n    cur = max(cur + it, it);\n    max_sum = max(max_sum, cur);\n}整数三分以求函数最大值为例while (l < r - 2) {\n    int m = (l + r) / 2;\n    if (cal(m) > cal(m + 1)) r = m + 1;\n    else\n        l = m;\n}\nint ans = max({cal(l), cal(l + 1), cal(r)});把n分成k组\n有组有个，组有个。快速范围判断判断是否在[0, N)，常用于bfs/dfs边界判断if ((unsigned)x < N)判断是否在[l, r]内if ((x - l | r - x) >= 0)根据两数之和和异或值反推两数原理：如果是奇数，那么无解。否则，根据A和xor的每一位填就行了，注意如果某一位两数都是1的话也是无解。优先队列模板参数自动推断利用了类模板实参推导（CTAD），可以少写一点代码，需要C++17。priority_queue q(greater{}, vector<int>{});g++11 有 bug，要写成priority_queue q{greater{}, vector<int>{}};精确计算x == 1 ? 0 : __lg(x - 1) + 1用交换相邻元素的排序数组的最小操作次数是数组中逆序对的数目a个0，b个1组成的01字符串字典序第k小先预处理i个0,j个1的字符串个数，然后从高位到底位枚举vector dp(a + 1, vector(b + 1, 0LL));\ndp[0][0] = 1;\nfor (int i = 0; i <= a; i++) {\n    for (int j = 0; j <= b; j++) {\n        if (i > 0) {\n            dp[i][j] += dp[i - 1][j];\n        }\n        if (j) {\n            dp[i][j] += dp[i][j - 1];\n        }\n    }\n}\nauto find_kth = [&](auto &find_kth, int A, int B, ll k) {\n    if (A == 0) return string(B, 'b');\n    if (B == 0) return string(A, 'a');\n    if (k <= dp[A - 1][B]) return \"a\" + find_kth(find_kth, A - 1, B, k);\n    return \"b\" + find_kth(find_kth, A, B - 1, k - dp[A - 1][B]);\n};位运算技巧可以看这冒泡排序遍历的次数创建一个复制数组b，其中，然后排序b，排序后的最大值就是答案，本质上就是一个数向前移动的距离，不难想出每个会向前移动的数从第一轮遍历就会开始向前移动，直到到达排序后的位置，所以最大的向前移动距离就是遍历的轮数。"},{"id":"GYM102428F","title":"Gym 102428F - Fabricating Sculptures 题解","content":"优雅的解法。题解首先我们可以忽略第一层方块。设表示把个方块放在堆上放法的数量。（有些堆可以是空的)现在我们考虑一下转移方程，有三种情况：第一层是满的最左边的堆是空的在右边的堆是空的第一种情况我们可以忽略掉第一层，放置的方法就是. 第二，三种情况我们可以忽略掉空的那一堆，所以有种放法，但两种情况有重叠，因为有可能左右两堆都是空的，所以要减掉。综上所述，转移方程就是：这个可以用记忆化搜索来求。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate<typename... Args>\nvoid write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nconst int N=5e3+5;\nll dp[N][N];\nconst int mod=1e9+7;\nll solve(int s,int b){\n    if(b==0) return 1;\n    if(s<=0) return 0;\n    ll& ret=dp[s][b];\n    if( ret) return ret;\n    ret=0;\n    if(s<=b) ret=solve(s,b-s);\n    ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod;\n    return ret;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int s,b;\n    cin>>s>>b;\n    cout<<solve(s,b-s);\n    return 0;\n}"},{"id":"HDU5592","title":"HDU 5592 - ZYB's Premutation 题解","content":"妙啊Problem Link题解我们用表示输入，用表示答案。就是比大的数字的个数因此我们也能知道比小的数的个数。我们可以用权值线段树然后从后遍历，这样我们就能得到所有没用过的比小的数的个数，然后在线段树中找到对应的数并更新线段树。Code#include <bits/stdc++.h>\n\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\nusing namespace std;\n\nconst int N=5e4+5;\nint sum[N<<2];\nvoid build(int k,int l,int r){\n\tsum[k]=r-l+1;\n\tif(l==r) return;\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n}\nint query(int root,int l,int r,int p){\n\tsum[root]--;\n\tif(l==r) return l;\n\tint mid=(l+r)>>1;\n\tif(sum[root<<1]>=p) return query(root<<1,l,mid,p);\n\telse return query(root<<1|1,mid+1,r,p-sum[root<<1]);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint tt;\n\tcin>>tt;\n\twhile(tt--){\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int> a(n+1),ans(n+1);\n\t\tfor1(i,n) cin>>a[i];\n\t\tbuild(1,1,n);\n\t\tfor(int i=n;i>0;i--){\n\t\t\tint p=a[i]-a[i-1];\n\t\t\tp=i-p;\n\t\t\tans[i]=query(1,1,n,p);\n\t\t}\n\t\tfor1(i,n) cout<<ans[i]<<(i==n?'\\n':' ');\n\t}\n    return 0;\n}"},{"id":"HDU6278","title":"HDU6278 - Just h-index 题解","content":"主席树！题解用主席树我们可以知道在给定区间里的所有数的出现次数。我们可以比较容易的想到一个二分做法：int l=0,r=INF;\nwhile(l<=r){\n    int mid=(l+r)>>1;\n    if(occurrence_of_numbers_bigger_than(mid)>=mid) l=mid+1;\n    else r=mid-1;\n}\ncout<<r<<endl;这种做法的时间复杂度是。足够通过本题，但还有优化的地方。事实上，二分部分可以在树上查询的时候完成。首先我们规定几个变量：为当前询问的区间，为当前在树上查询的区间，为里数字的出现次数。伪代码大概是这样：int query(int l,int r,int s){\n    int mid=(l+r)>>1;\n    int cnt=occurrence_of_number_from_mid_to_r();\n    if(cnt+s>=mid+1) return query(mid+1,r,s);//(mid,y]中的数比mid大，也就是说答案在右边的区间\n    return query(l,mid,s+cnt);//(mid,y]的数不够多，答案在左边的区间\n}Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nstruct PerSegTree {\n    vector<int> lson, rson, sum, root;\n    int tot;\n    PerSegTree(int n) {\n        lson = rson = sum = vector<int>(n << 5);\n        root = vector<int>(n + 1);\n        tot = 0;\n    }\n    void pushup(int rt) {\n        sum[rt] = sum[lson[rt]] + sum[rson[rt]];\n    }\n    void build(int l, int r, int& rt) {\n        rt = ++tot;\n        if (l == r) return;\n        int mid = (l + r) >> 1;\n        build(l, mid, lson[rt]);\n        build(mid + 1, r, rson[rt]);\n        pushup(rt);\n    }\n    void update(int pos, int val, int l, int r, int ord, int& rt) {\n        rt = ++tot;\n        lson[rt] = lson[ord];\n        rson[rt] = rson[ord];\n        if (l == r) {\n            sum[rt] = sum[ord] + val;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        if (pos <= mid) update(pos, val, l, mid, lson[ord], lson[rt]);\n        else update(pos, val, mid + 1, r, rson[ord], rson[rt]);\n        pushup(rt);\n    }\n    int query(int pos, int l, int r, int lrt, int rrt) {\n        if (l == r) return sum[rrt] - sum[lrt];\n        int mid = (l + r) >> 1;\n        if (pos <= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]);\n        return query(pos, mid + 1, r, rson[lrt], rson[rrt]);\n    }\n};\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,q;\n    while(cin>>n>>q){\n        PerSegTree tree(n);\n        tree.build(1,n,tree.root[0]);\n        for1(i,n){\n            int x;\n            cin>>x;\n            tree.update(x,1,1,n,tree.root[i-1],tree.root[i]);\n        }\n        while(q--){\n            int x,y;\n            cin>>x>>y;\n            int l=0,r=1e5;\n            while(l<=r){\n                int mid=(l+r)>>1;\n                int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]);\n                if(ans>=mid) l=mid+1;\n                else r=mid-1;\n            }\n            cout<<r<<endl;\n        }\n    }\n    return 0;\n}#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nstruct PerSegTree {\n    vector<int> lson, rson, sum, root;\n    int tot;\n    PerSegTree(int n) {\n        lson = rson = sum = vector<int>(n << 5);\n        root = vector<int>(n + 1);\n        tot = 0;\n    }\n    void pushup(int rt) {\n        sum[rt] = sum[lson[rt]] + sum[rson[rt]];\n    }\n    void build(int l, int r, int& rt) {\n        rt = ++tot;\n        if (l == r) return;\n        int mid = (l + r) >> 1;\n        build(l, mid, lson[rt]);\n        build(mid + 1, r, rson[rt]);\n        pushup(rt);\n    }\n    void update(int pos, int val, int l, int r, int ord, int& rt) {\n        rt = ++tot;\n        lson[rt] = lson[ord];\n        rson[rt] = rson[ord];\n        if (l == r) {\n            sum[rt] = sum[ord] + val;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        if (pos <= mid) update(pos, val, l, mid, lson[ord], lson[rt]);\n        else update(pos, val, mid + 1, r, rson[ord], rson[rt]);\n        pushup(rt);\n    }\n    int query(int l, int r, int old_rt, int rt,int s) {\n        if(l==r) return l;\n        int mid=(l+r)>>1;\n        int cnt=sum[rson[rt]]-sum[rson[old_rt]];\n        if(mid<cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s);\n        return query(l,mid,lson[old_rt],lson[rt],s+cnt);\n    }\n};\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,q;\n    while(cin>>n>>q){\n        PerSegTree tree(n);\n        tree.build(1,n,tree.root[0]);\n        for1(i,n){\n            int x;\n            cin>>x;\n            tree.update(x,1,1,n,tree.root[i-1],tree.root[i]);\n        }\n        while(q--){\n            int x,y;\n            cin>>x>>y;\n            cout<<tree.query(1,n,tree.root[x-1],tree.root[y],0)<<endl;\n        }\n    }\n    return 0;\n}"},{"id":"HDU6602","title":"题解 HDU6602 - Longest Subarray","content":"link题解让我们先尝试固定右端点，然后对于每个右端点找到最长的子数组。令为第i个的下标。假设当前的右端点是，对于每个,左端点不可能落在区间，其中是直到为止的出现次数。这是因为如果左端点在这个区间内，则的出现将大于零且小于，不满足约束条件。我们可以在这些区间上加1，那么最左的端点是值为0的最小下标。现在让我们考虑一下当右端点移至时区间如何变化。显而易见，只有的区间会改变。\n区间将从变为。请注意，在代码中，我们不必更改重叠的部分。综上所述，我们需要一个支持区间修改和全局最小值查询的数据结构,aka线段树。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define size(x) int(x.size())\n#define pb push_back\n\nusing namespace std;\n\nstruct SegTree{\n    int n;\n    vector<int> t,lazy,pos;\n    SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){\n        build(1,0,n-1);\n    }\n    void pushup(int node){\n        t[node]=min(t[node<<1],t[node<<1|1]);\n        pos[node]=(t[node]==t[node<<1]?pos[node<<1]:pos[node<<1|1]);\n    }\n    void build(int node,int l,int r){\n        if(l==r){\n            pos[node]=l;\n            return;\n        }\n        int mid=(l+r)>>1;\n        build(node<<1,l,mid);\n        build(node<<1|1,mid+1,r);\n        pushup(node);\n    }\n    void addtag(int p,int x){\n        t[p]+=x;\n        lazy[p]+=x;\n    }\n    void spread(int p){\n        if(lazy[p]){\n            addtag(p<<1,lazy[p]);\n            addtag(p<<1|1,lazy[p]);\n            lazy[p]=0;\n        }\n    }\n    void update(int node,int ql,int qr,int l,int r,int x){\n        if(ql<=l&&qr>=r){\n            addtag(node,x);\n            return;\n        }\n        spread(node);\n        int mid=(l+r)>>1;\n        if(ql<=mid) update(node<<1,ql,qr,l,mid,x);\n        if(qr>mid) update(node<<1|1,ql,qr,mid+1,r,x);\n        pushup(node);\n    }\n    int query(int i){\n        return t[1]==0?i-pos[1]+1:0;\n    }\n\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,c,k;\n    while(cin>>n>>c>>k){\n        vector<vector<int>> pos(c+1,{-1});\n        vector<int> a(n);\n        for(auto& it:a) cin>>it;\n        SegTree st(n);\n        int ans=0;\n        forn(i,n){\n            auto& v=pos[a[i]];\n            v.pb(i);\n            int sz=size(v)-1;\n            if(sz<k) st.update(1,v[sz-1]+1,i,0,n-1,1);\n            else{\n                st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1);\n                st.update(1,v[sz-1]+1,i,0,n-1,1);\n            }\n            ans=max(ans,st.query(i));\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"},{"id":"ICPC-WF-2020-Invitational-L","title":"ICPC WF Moscow Invitational Contest L - Labyrinth 题解","content":"题目链接题解首先，以下两点不难想到：我们只会在最大生成树的边上走，这样我们就把图变成了树。对于所有边，最优策略永远是先吃树上一边的所有点然后再吃另一边。由于宽度小的边会最先不满足条件，因此要优先考虑宽度小的边，但边两侧的连通块的情况还不知道，所以我们要先继续处理两侧的信息再确定吃的方向，而每侧的连通块中最窄的边又会把连通块一分为二……这样一直递归下去直到每个连通块只剩一个点。合并的顺序就是从宽边到窄边，这正好也是求最大生成树的顺序，于是可以在求最大生成树的同时维护答案。对于每个连通块，我们维护进入这个连通块时人的最大宽度。假设待合并的两个连通块为，每个块的值的和为，之间的边的宽度为，从到要满足和，变形一下就是，也就是说如果先吃再吃 的话，进入合并之后的连通块时最大的宽度为 ，先吃再吃的情况类似，取两种情况中宽度更大的情况。代码#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(), (x).end()\nusing ll = long long;\n\nconstexpr ll INF = 1e18;\nstruct UF {\n    vector<int> fa, sz;\n    vector<ll> mx, sum;\n    UF(int n) : fa(n), sz(n, 1), mx(n, INF), sum(n) {\n        iota(all(fa), 0);\n    }\n\n    int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\n    void join(int u, int v, ll w) {\n        u = find(u), v = find(v);\n        if (u == v) return;\n        if (sz[u] > sz[v]) swap(u, v);\n        ll fromV = -INF, fromU = -INF;\n        if (sum[v] <= mx[u]) fromV = min(mx[u], w) - sum[v];\n        if (sum[u] <= mx[v]) fromU = min(mx[v], w) - sum[u];\n        mx[v] = max(fromU, fromV);\n        sum[v] += sum[u];\n        fa[u] = v;\n        sz[v] += sz[u];\n        return;\n    }\n    auto check() { return mx[find(0)]; }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<array<int, 3>> edges(m);\n    UF uf(n);\n    for (int i = 0; i < n; i++)\n        cin >> uf.sum[i];\n    for (auto &[u, v, c] : edges)\n        cin >> u >> v >> c, u--, v--;\n    sort(begin(edges), end(edges), [&](auto& i, auto& j) { return i[2] > j[2]; });\n    for (auto &[u, v, c] : edges)\n        uf.join(u, v, c);\n    if (auto mx = uf.check(); mx < 1) cout << \"-1\\n\";\n    else\n        cout << mx << endl;\n}"},{"id":"JOIOC18-bubblesort2","title":"JOI '18 Open P1 - Bubble Sort 2 题解","content":"题目链接首先我们要知道对于固定的数组如何求遍历轮数： 创建一个复制数组b，其中，然后排序b，排序后的最大值就是答案，本质上就是一个数向前移动的距离，不难想出每个会向前移动的数从第一轮遍历就会开始向前移动，直到到达排序后的位置，所以最大的向前移动距离就是遍历的轮数。现在考虑修改原数组后，数组以及的值会有什么改变，不难发现其实就是删掉了，然后再插入（x与v的含义与题目相同），b数组中在老位置与新位置中间的元素会移动一位，所以他们的会+1或者-1（由新老位置的关系而定），所以我们需要一个可以插入删除又能区间加的数据结构，并且支持查询全局最大值，那只能是平衡树了。代码#include <bits/stdc++.h>\nusing namespace std;\n\nauto seed=chrono::high_resolution_clock::now().time_since_epoch().count();\nmt19937 gen(seed);\ntemplate <typename T> struct Treap {\n    struct node {\n        int ch[2], sz;\n        unsigned k;\n        pair<int, int> d;\n        T mx, lazy, dif;\n        node(pair<int, int> d_, int dd, int z = 1) : sz(z), k((unsigned)gen()), d(d_), mx(dd), lazy(), dif(dd) {\n            ch[0] = ch[1] = 0;\n        }\n    };\n    vector<node> nodes;\n    int root=0, recyc=0;\n    Treap(int size = 2e5) {\n        nodes.reserve(size);\n        nodes.emplace_back(pair{0, 0}, -1e9, 0);\n    }\n    inline int &ch(int rt, int r) { return nodes[rt].ch[r]; }\n    int new_node(const pair<int, int> &d, int dd) {\n        nodes.emplace_back(d, dd);\n        return nodes.size()-1;\n    }\n    int pull(int rt) {\n        node &n = nodes[rt];\n        n.sz = 1 + nodes[n.ch[0]].sz + nodes[n.ch[1]].sz;\n        n.mx = max({n.dif, nodes[n.ch[0]].mx, nodes[n.ch[1]].mx});\n        return rt;\n    }\n    void add(int rt, const T &d) {\n        node &n = nodes[rt];\n        n.lazy += d;\n        n.mx += d;\n        n.dif+=d;\n    }\n    void pushdown(int rt) {\n        node &n = nodes[rt];\n        if (n.lazy) {\n            add(n.ch[0], n.lazy);\n            add(n.ch[1], n.lazy);\n            n.lazy = T();\n        }\n    }\n    int merge(int tl, int tr) {\n        if (!tl) return tr;\n        if (!tr) return tl;\n        if (nodes[tl].k < nodes[tr].k) {\n            pushdown(tl);\n            ch(tl, 1) = merge(ch(tl, 1), tr);\n            return pull(tl);\n        } else {\n            pushdown(tr);\n            ch(tr, 0) = merge(tl, ch(tr, 0));\n            return pull(tr);\n        }\n    }\n    void split(int rt, pair<int, int> k, int &x, int &y) { // split out element less than or equal to k\n        if (!rt) {\n            x = y = 0;\n            return;\n        }\n        pushdown(rt);\n        if (k < nodes[rt].d) {\n            y = rt;\n            split(ch(rt, 0), k, x, ch(rt, 0));\n        } else {\n            x = rt;\n            split(ch(rt, 1), k, ch(rt, 1), y);\n        }\n        pull(rt);\n    }\n    // interface\n    void insert(pair<int, int> v, int d) {\n        int rt = new_node(v, d);\n        root = merge(root, rt);\n    }\n    void move_right(int old, int ne, int idx) {\n        int a, b, c, d;\n        split(root, {ne, idx}, c, d);\n        split(c, {old, idx}, b, c);\n        split(b, {old, idx-1}, a, b);\n        if (c) add(c, 1);\n        nodes[b]=node({ne, idx}, idx-(nodes[a].sz+nodes[c].sz));\n        root = merge(merge(merge(a, c), b), d);\n    }\n    void move_left(int old, int ne, int idx) {\n        int a, b, c, d;\n        split(root, {old, idx}, c, d);\n        split(c, {old, idx-1}, b, c);\n        split(b, {ne, idx}, a, b);\n        if (b) add(b, -1);\n        nodes[c]=node({ne, idx}, idx-(nodes[a].sz));\n        root=merge(merge(merge(a, c), b), d);\n    }\n    int query() {\n        return nodes[root].mx;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, q;\n    cin>>n>>q;\n    vector<int> a(n);\n    for (auto& x  : a) cin>>x;\n    vector<pair<int, int>> b(n);\n    for (int i=0; i<n; i++) {\n        b[i]={a[i], i};\n    }\n    sort(b.begin(), b.end());\n    Treap<int> tr;\n    for (int i=0; i<n; i++) {\n        tr.insert(b[i], b[i].second-i);\n    }\n    while (q--) {\n        int x, v;\n        cin>>x>>v;\n        if (a[x]<v) {  // move right\n            tr.move_right(a[x], v, x);\n        } else { // move left\n            tr.move_left(a[x], v, x);\n        }\n        a[x]=v;\n        cout<<tr.query()<<'\\n';\n    }\n}"},{"id":"LOJ2097","title":"「CQOI2015」任务查询系统题解","content":"题解本题要求的是在某一时刻前k小的优先级的和，所以我们不妨以优先级（要先离散化）为下标建立可持久化线段树（主席树），也就是说从任一根节点出发得到的是某一时刻正在运行的所有任务。这样一个任务可以被拆分成两个事件：在S秒时加入正在运行的任务的集合（也就是在主席树上对应的优先级上+1）在E+1秒时从正在运行的任务的集合中移除（也就是在主席树上对应的优先级上-1）我们把所有事件按时间顺序排序并依次更新主席树，并记录对于每个时刻，该时刻前最新版本的线段树的根节点，查询时就从该根节点出发。线段树要维护两个信息，一个是区间内正在运行任务的数量，一个是正在运行的任务的优先级之和。值得注意的是查询的是单一时刻的信息，不像求区间第k小时要两个区间信息相减，所以写起来也简单一点。一个非常容易错的地方是查询是当走到叶子节点时，如果该优先级的任务数量大于当前的k值，不能直接加上叶子节点中的优先级之和，要先除以任务数量再乘k值。代码#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct PST {\n    int n, tot = 0;\n    struct node {\n        int lc, rc, cnt;\n        ll sum;\n    };\n    vector<node> t;\n    vector<int> roots; // left child, right child\n    PST(int n_) : n(n_), t(n << 6), roots(1) {\n        build(0, n - 1, roots[0]);\n    }\n#define lc(rt) t[rt].lc\n#define rc(rt) t[rt].rc\n    void pushup(int rt) {\n        t[rt].sum = t[lc(rt)].sum + t[rc(rt)].sum;\n        t[rt].cnt = t[lc(rt)].cnt + t[rc(rt)].cnt;\n    }\n    void build(int l, int r, int &rt) {\n        rt = ++tot;\n        if (l == r) return;\n        int mid = (l + r) >> 1;\n        build(l, mid, lc(rt));\n        build(mid + 1, r, rc(rt));\n        pushup(rt);\n    }\n    void update(int pos, int dcnt, int dsum, int l, int r, int old, int &rt) {\n        rt = ++tot;\n        t[rt] = t[old];\n        if (l == r) {\n            t[rt].cnt = t[old].cnt + dcnt;\n            t[rt].sum = t[old].sum + dsum;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        if (pos <= mid) update(pos, dcnt, dsum, l, mid, lc(old), lc(rt));\n        else update(pos, dcnt, dsum, mid + 1, r, rc(old), rc(rt));\n        pushup(rt);\n    }\n    int update(int pos, int dcnt, int dsum) { // return the root of the new version\n        int new_root;\n        update(pos, dcnt, dsum, 0, n - 1, roots.back(), new_root);\n        roots.push_back(new_root);\n        return new_root;\n    }\n    ll query(int v, int l, int r, int k) {\n        if (l == r)\n            return (t[v].cnt > k ? t[v].sum / t[v].cnt * k : t[v].sum);\n        int mid = (l + r) / 2, x = t[lc(v)].cnt;\n        ll sum = t[lc(v)].sum;\n        if (k <= x) return query(lc(v), l, mid, k);\n        return sum + query(rc(v), mid + 1, r, k - x);\n    }\n    ll query(int v, int k) { return query(v, 0, n - 1, k); }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, q;\n    cin >> n >> q;\n    vector<tuple<int, int, int>> tasks(n);\n    vector<int> p; // 所有的优先级，用于离散化\n    for (auto &[s, e, pp] : tasks) {\n        cin >> s >> e >> pp;\n        p.push_back(pp);\n    }\n    sort(begin(p), end(p));\n    p.erase(unique(begin(p), end(p)), end(p)); // 离散化\n    vector<pair<int, int>> events;\n    for (auto [s, e, pp] : tasks) {\n        int id = lower_bound(begin(p), end(p), pp) - begin(p);\n        // 两个事件，用优先级的正负来表示加入或者删除\n        events.emplace_back(s, id + 1);\n        events.emplace_back(e + 1, -id - 1);\n    }\n    sort(begin(events), end(events));\n    PST tr(size(p));\n    vector<int> roots(n + 1); // root[i]代表i时刻前最新的线段树的版本\n    roots[0] = 1;\n    for (auto [time, id] : events) {\n        if (id > 0) {\n            roots[time] = (tr.update(id - 1, 1, p[id - 1]));\n        } else {\n            id = -id - 1;\n            roots[time] = (tr.update(id, -1, -p[id]));\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        // 对于没有事件发生的时刻i，其最新的版本为上一时刻的最新版本\n        if (!roots[i]) roots[i] = roots[i - 1];\n    ll pre = 1;\n    while (q--) {\n        int x, a, b, c;\n        cin >> x >> a >> b >> c;\n        auto k = 1 + (a * pre + b) % c;\n        auto res = tr.query(roots[x], k);\n        cout << res << '\\n';\n        pre = res;\n    }\n}"},{"id":"NC5447C","title":"题解 Nowcoder 5447C - 张老师的旅行","content":"题解观察易知，若想用最小的时间覆盖一段线段，那么结束时的位置一定在线段的左端点或右端点。那么我们的dp状态就可以设为，代表覆盖从l到r的线段所用的最短时间并且以左端点结尾（p=0），右端点结尾（p=1）。状态转移是不难想的，可以由或得到，同理可以由或得到，别忘了判断一下是否在规定的时间之内。具体转移看代码～Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N=1005;\nint dp[N][N][2];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> p(n+1),t(n+1);\n    ms(dp,INF);\n    for1(i,n){\n        cin>>p[i];\n        dp[i][i][0]=dp[i][i][1]=0;\n    }\n    for1(i,n) cin>>t[i];\n    for(int len=2;len<=n;len++){\n        for(int l=1;l+len-1<=n;l++){\n            int r=l+len-1;\n            int t1=min(dp[l+1][r][0]+p[l+1]-p[l],dp[l+1][r][1]+p[r]-p[l]);\n            int t2=min(dp[l][r-1][0]+p[r]-p[l],dp[l][r-1][1]+p[r]-p[r-1]);\n            if(t1<=t[l]) dp[l][r][0]=t1;\n            if(t2<=t[r]) dp[l][r][1]=t2;\n        }\n    }\n    int ans=min(dp[1][n][0],dp[1][n][1]);\n    cout<<(ans==INF?-1:ans);\n    return 0;\n}"},{"id":"NonPuzzle-Segment-Pair","title":"2023牛客多校9 I - Non-Puzzle: Segment Pair 题解","content":"首先我们考虑某一个点被所有线段覆盖的方案数：如果一对线段中有只有一条线段能覆盖这个点，那么我们就只能选这条线段，如果两条线段都能覆盖这个点，我们可以任选其一。但是题目要求的是存在一个点被所有线段覆盖，如果我们对数轴上的每一个点求方案数的话，其中必然有重复的方案，我们考虑什么样的情况方案会重复。不难发现，对于两个点，如果覆盖第一个点的线段的集合与覆盖第二个点的线段的集合相同的话，这两个点所对应的方案的集合是相同的。反之，这两个点对应的情况是不同的，具体来说有两种情况：存在一对线段，一个点只被其中的一条线段覆盖，而另一个点只被另一条线段覆盖。这两个点所对应的方案的集合是不交的。否则，存在一对线段，一个点只被其中的一条线段覆盖，而另一个点只被两条线段覆盖。一个点所对应的方案的集合是另一个点对应的集合的子集。于是我们在每次线段覆盖情况变化的时候计算当前的方案数并加入到答案中。我们可以把每条线段  拆成两个事件：在  处线段覆盖开始在  处线段覆盖结束我们将所有事件排序，从小到大遍历就可以得到所有线段覆盖的情况。遍历的过程中维护  为一对线段中有  条线段覆盖当前点的线段对的数量。注意到线段覆盖变化有四种情况：有一对线段从零条覆盖变成了一条覆盖，此时如果  我们应把答案加上 有一对线段从一条覆盖变成了两条覆盖，还记得我们上面说的第二种情况吗？由于子集的方案数已经加到答案里了，此时如果  我们应把答案加上 有一对线段从两条覆盖变成了一条覆盖，答案已经计算过了，跳过有一对线段从一条覆盖变成了零条覆盖，不符合被所有线段覆盖的条件，跳过#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n\n    constexpr int mod = 1e9 + 7;\n    vector<int> pw(n + 1);\n    pw[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        pw[i] = pw[i - 1] * 2 % mod;\n    }\n\n    vector<array<int, 3>> a;\n    for (int i = 0; i < n; i++) {\n        int l1, r1, l2, r2;\n        cin >> l1 >> r1 >> l2 >> r2;\n        a.push_back({l1, 1, i});\n        a.push_back({r1 + 1, -1, i});\n        a.push_back({l2, 1, i});\n        a.push_back({r2 + 1, -1, i});\n    }\n\n    sort(begin(a), end(a));\n\n    array<int, 3> num{n, 0, 0}; // 题解里提到的\n    vector<int> cnt(n); // 每一对线段中当前有几条覆盖\n    int ans = 0;\n\n    for (auto [x, f, i] : a) {\n        num[cnt[i]]--;\n        cnt[i] += f;\n        num[cnt[i]]++;\n\n        if (f == 1 && num[0] == 0) {\n            if (cnt[i] == 2) { // 从一条覆盖变成两条覆盖\n                ans = (ans + pw[num[2] - 1]) % mod;\n            } else { // 从零条覆盖变成一条覆盖\n                ans = (ans + pw[num[2]]) % mod;\n            }\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}"},{"id":"PBDS_basic_usage","title":"PB_DS的基础用法","content":"Policy-Based Data Structure(PB_DS)的基础用法哈希表用法#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ncc_hash_table<int, int> table;//collision-chaining hash table\ngp_hash_table<int, int> table;//probing hash table可以像一样用。稍微好一点的哈希函数struct custom_hash {\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        x ^= FIXED_RANDOM;\n        return x ^ (x >> 16);\n    }\n};无敌哈希函数struct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};平衡树声明头文件#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;用作tree<int, int, less<int>, rb_tree_tag, tree_order_statistics_node_update> t;用作tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> t;用作tree<pair<int,int>, null_type, less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> t;也可以用，但 和  函数会交换功能并且会失效，所以谨慎使用。tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> t;比更强的功能：排名必须在声明里用以获得与排名相关的功能:size_type order_of_key(key_const_reference);// 返回比key小的元素的个数\niterator find_by_order(size_type order) // 返回排名为order的元素的迭代器，排名从0开始e.g. 求逆序对#include <bits/extc++.h>\nusing namespace std;\nusing namespace __gnu_pbds;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    // 注意此处用了less_equal以允许重复的元素\n    tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> st;\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto& x : a) cin >> x;\n    long long ans=0;\n    for (int i=n-1; i>=0; i--) {\n        ans += st.order_of_key(a[i]);\n        st.insert(a[i]);\n    }\n    cout << ans << '\\n';\n}使用  和  找前驱和后继前驱：*prev(t.lower_bound(x))//set\nprev(t.lower_bound({x,0}))->first//multi-set后继：*t.upper_bound(x);//set\n*t.lower_bound({x+1,0});优先队列原型template<typename  Value_Type,\n\t  typename  Cmp_Fn = std::less<Value_Type>,\n\t  typename  Tag = pairing_heap_tag,\n\t  typename  Allocator = std::allocator<char > >\n\t  class priority_queue;用法默认的模板参数就是性能最好的，注意必须要带上命名空间以区分。#include<ext/pb_ds/priority_queue.hpp>\n__gnu_pbds::priority_queue<int>;所有的5种tag:和 的不同之处point_iterator push(const_reference r_val); //push会返回指向插入后元素的point迭代器（和遍历迭代器不一样）\nvoid PB_DS_CLASS_C_DEC:: join(PB_DS_CLASS_C_DEC& other) //合并两个堆同时清空other\nvoid split(Pred prd,priority_queue &other) // 根据prd函数的返回值（true或false）分裂两个堆\nvoid modify(point_iterator it,const key) // 某些堆支持快速修改堆中的元素，比如用在dijkstra中\nbegin();\nend();//begin 和 end 迭代器参考资料Policy-Based Data StructureBlowing up unordered_map, and how to stop getting hacked on itpb_ds库的一些常用方法用 pbds 过 luogu P3369【模板】普通平衡树"},{"id":"PBreconstruction","title":"12.42 PB 复盘","content":"解法动画打乱L2 R2 U L2 B2 F2 U R2 D' U' F' R F2 D B2 D2 B' F' L B解法y' //inspectionF' D' F2 U R B' //FBr' U' r' U2 r U M r' U' r M' U' R U R' U' R U R' //SBU' R U R' U' R' F R F' //CMLLM' U M2' U' M U2 M' U M U2 M' U2 //LSE46 ETM, 3.7 TPS"},{"id":"SWERC2017E","title":"SWERC2017 E - Ingredients 题解","content":"竟然一次就过了Linkms(cost,INF);\nqueue<int> q;\nfor1(i,id.size()){\n\tif(deg[i]==0){\n\t\tq.push(i);\n\t\tcost[i]=0;\n\t}\n}\nwhile(!empty(q)){\n\tint now=q.front();\n\tq.pop();\n\tfor(auto [dish,cost,prestige]:G[now]){\n\t\tif(cost[now]+cost<cost[dish]){//choose the smallest cost\n\t\t\tcost[dish]=cost[now]+cost;\n\t\t\tpre[\n\t\t}else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige\n\t\t\tpre[dish]=max(pre[dish],pre[now]+prestige);\n\t\t}\n\t\tdeg[dish]--;\n\t\tif(deg[dish]==0) q.push(dish);\n\t}\n}The nest part is more familiar: using 0/1 knapsack algorithm to find the answer.题解这个题结合了最短路和0/1背包算法。第一步是找到所有菜品的最小花费，也就是DAG上的最短路。这个可以用拓扑排序在的时间内解决，具体实现看上面的代码解释。第二步就是非常标准的0/1背包了，没什么好说的。Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\n\nconst int N=1e4+5;\nvector<tuple<int,int,int>> G[N];\nint cost[N],pre[N],deg[N],dp[N];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n,b;\n\tcin>>b>>n;\n\tunordered_map<string,int> id;\n\tauto getid=[&](string& st){\n\t\tif(id[st]) return id[st];\n\t\telse return id[st]=size(id);\n\t};\n\tforn(i,n){\n\t\tstring s,t,tmp;\n\t\tint x,y;\n\t\tcin>>s>>t>>tmp>>x>>y;\n\t\tint ids=getid(s),idt=getid(t);\n\t\tG[idt].eb(ids,x,y);\n\t\tdeg[ids]++;\n\t}\n    //topo sort\n\tms(cost,INF);\n\tqueue<int> q;\n\tfor1(i,id.size()){\n\t\tif(deg[i]==0){\n\t\t\tq.push(i);\n\t\t\tcost[i]=0;\n\t\t}\n\t}\n\twhile(!empty(q)){\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(auto [to0,to1,to2]:G[now]){\n\t\t\tif(cost[now]+to1<cost[to0]){\n\t\t\t\tcost[to0]=cost[now]+to1;\n\t\t\t\tpre[to0]=pre[now]+to2;\n\t\t\t}else if(cost[now]+to1==cost[to0]){\n\t\t\t\tpre[to0]=max(pre[to0],pre[now]+to2);\n\t\t\t}\n\t\t\tdeg[to0]--;\n\t\t\tif(deg[to0]==0) q.push(to0);\n\t\t}\n\t}\n    //knapsack\n\tfor1(i,size(id)){\n\t\tfor(int j=b;j>=cost[i];j--){\n\t\t\tdp[j]=max(dp[j],dp[j-cost[i]]+pre[i]);\n\t\t}\n\t}\n\tint ans1=0,ans2=0;\n\tfor(int i=0;i<=b;i++){\n\t\tif(dp[i]>ans1){\n\t\t\tans1=dp[i];\n\t\t\tans2=i;\n\t\t}\n\t}\n\tcout<<ans1<<endl<<ans2;\n\treturn 0;\n}"},{"id":"abc207e","title":"AtCoder Beginner Contest(ABC) 207E - Mod i题解","content":"方法一一种简单的dp是令为将前个数分成个子数组的分法的个数。次转移要遍历前的每个位置然后前缀前缀和判断是否是的倍数，如果是的话就加上，所以转移是 的，总的复杂度是，会TLE，于是我们想如何优化。考虑到 也许我们不用遍历所有的，只要记录对于每个位置, 的的和就行了。于是我们的状态的定义就变成了在k位置结束的子数组,分成个子数组并且的分法的个数。（说实话不是很好理解）#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <int MOD> struct ModInt {\n    int val;\n    // constructor\n    ModInt(ll v = 0) : val(int(v % MOD)) {\n        if (val < 0) val += MOD;\n    };\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n    // arithmetic\n    ModInt operator+(const ModInt &x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt &x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt &x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt &x) const { return ModInt(*this) /= x; }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    // compound assignment\n    ModInt &operator+=(const ModInt &x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &x) {\n        val = int(ll(val) * x.val % MOD);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &x) { return *this *= x.inv(); }\n    // compare\n    bool operator==(const ModInt &b) const { return val == b.val; }\n    bool operator!=(const ModInt &b) const { return val != b.val; }\n    // I/O\n    friend std::istream &operator>>(std::istream &is, ModInt &x) noexcept { return is >> x.val; }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<int(1e9 + 7)>;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<ll> a(n), sum(n + 1);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        sum[i + 1] = sum[i] + a[i];\n    }\n    vector dp(n + 2, vector<mint>(n + 2));\n    dp[1][0] += 1;\n    mint ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = n; j >= 1; j--) {\n            dp[j + 1][sum[i + 1] % (j + 1)] += dp[j][sum[i + 1] % j];\n            if (i == n - 1) ans += dp[j][sum[n] % j];\n        }\n    }\n    cout << ans << '\\n';\n}方法二这种方法和方法一的出发点一样，但转移的时候我们只考虑最大的k,这是因为两个和为的的倍数的子数组拼起来和依然是的倍数，所以我们保持一开始的dp状态定义，然后用的时间预处理出，即对于每个位置，其左边第一个位置使得，转移时考虑两种情况：pre的位置被分成了或个子数组。#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate <int MOD> struct ModInt {\n    int val;\n    // constructor\n    ModInt(ll v = 0) : val(int(v % MOD)) {\n        if (val < 0) val += MOD;\n    };\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n    // arithmetic\n    ModInt operator+(const ModInt &x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt &x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt &x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt &x) const { return ModInt(*this) /= x; }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    // compound assignment\n    ModInt &operator+=(const ModInt &x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &x) {\n        val = int(ll(val) * x.val % MOD);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &x) { return *this *= x.inv(); }\n    // compare\n    bool operator==(const ModInt &b) const { return val == b.val; }\n    bool operator!=(const ModInt &b) const { return val != b.val; }\n    // I/O\n    friend std::istream &operator>>(std::istream &is, ModInt &x) noexcept { return is >> x.val; }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<int(1e9 + 7)>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    for (auto &x : a)\n        cin >> x;\n    vector pre(n, vector(n + 1, -1));\n    vector last(n + 1, vector(n, -1));\n    ll sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += a[i];\n        for (int j = 1; j <= n; j++) {\n            pre[i][j] = last[j][sum % j];\n            last[j][sum % j] = i;\n        }\n    }\n    vector dp(n, vector<mint>(n + 1));\n    dp[0][1] = 1;\n    for (int i = 1; i < n; i++) {\n        for (int j = 1; j <= n; j++) {\n            int p = pre[i][j];\n            if (p != -1) { dp[i][j] = dp[p][j] + dp[p][j - 1]; }\n        }\n    }\n    cout << accumulate(dp[n - 1].begin(), dp[n - 1].end(), mint()) << '\\n';\n}"},{"id":"abc274g","title":"AtCoder Beginner Contest 274 G - Security Camera 3","content":"不难发现对于一行或一列中连续的方块，我们只需要最多一个摄像头，不妨让摄像头放置在一行的最左边或者一列的最上面。对于每一个方块，它要被以下至少一个位置的摄像头监控到：这个方块上面最后一个非障碍的方块这个方块左边最后一个非障碍的方块如果我们把可能的摄像头的位置看成点（每一个方块被看成两个点，向右看的摄像头和向下看的摄像头），每一个方块看成一条边（连接上面提到的两个位置的摄像头），那么这个问题就变成了二分图的最小点覆盖问题，也就等价于最大匹配问题。代码：#include <bits/stdc++.h>\nstruct aug_path {\n    std::vector<std::vector<int>> g;\n    std::vector<int> L, R, vis;\n    aug_path(int n, int m) : g(n), L(n, -1), R(m, -1), vis(n) {}\n    void add_edge(int a, int b) { g[a].push_back(b); }\n    bool match(int u) {\n        if (vis[u]) return false;\n        vis[u] = true;\n        for (auto v : g[u]) {\n            if (R[v] == -1) {\n                L[u] = v;\n                R[v] = u;\n                return true;\n            }\n        }\n        for (auto vec : g[u]) {\n            if (match(R[vec])) {\n                L[u] = vec;\n                R[vec] = u;\n                return true;\n            }\n        }\n        return false;\n    }\n    template<bool to_shuffle = false>\n    int solve() {\n        std::vector<int> order;\n        if constexpr (to_shuffle) {\n            std::mt19937 rng(1);\n            for (auto& v : g)\n                shuffle(v.begin(), v.end(), rng);\n            order.resize(L.size());\n            iota(order.begin(), order.end(), 0);\n            shuffle(order.begin(), order.end(), rng);\n        }\n        bool ok = true;\n        while (ok) {\n            ok = false;\n            fill(vis.begin(), vis.end(), 0);\n            if constexpr (to_shuffle) {\n                for (auto i : order) {\n                    if (L[i] == -1) ok |= match(i);\n                }\n            } else {\n                for (int i = 0; i < (int)L.size(); ++i) {\n                    if (L[i] == -1) ok |= match(i);\n                }\n            }\n        }\n        int ret = 0;\n        for (size_t i = 0; i < L.size(); ++i)\n            ret += (L[i] != -1);\n        return ret;\n    }\n};\nusing namespace std;\nusing ll = long long;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<string> a(n);\n    for (auto& s : a) {\n        cin >> s;\n    }\n    vector top(n, vector(m, 0));\n    auto left(top);\n    aug_path g(n * m, n * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (a[i][j] == '#') continue;\n            if (i == 0 || a[i - 1][j] == '#') {\n                top[i][j] = i;\n            } else {\n                top[i][j] = top[i - 1][j];\n            }\n            if (j == 0 || a[i][j - 1] == '#') {\n                left[i][j] = j;\n            } else {\n                left[i][j] = left[i][j - 1];\n            }\n            g.add_edge(top[i][j] * m + j, i * m + left[i][j]);\n        }\n    }\n    cout << g.solve() << '\\n';\n    return 0;\n}"},{"id":"add-arithmetic-progression","title":"区间加等差数列","content":"顾名思义，就是在区间上加上首项为，公差为的等差数列。分为以下这么三类情况：先加后询问即先加，最后再输出整个数组，或者询问的位置和修改的左端点是有序的。这种情况我们不需要借助其他数据结构，有以下两种思路：靠思维我们先回顾一下区间加同样的数是怎么做的，我们维护当前加在原数组上的值，并用一个数组标记维护的值在位置该如何变化，比如说给加上，我们令，这样中的数都会加，然后位置还原。加等差数列就是上述思路的扩展，我们不仅维护当前加在原数组上的值，还维护当前的公差，以及用两个数组和标记两个维护的值的变化。当加一个等差数列时，我们在处标记代表从处开始公差加，在处标记以复原公差。也需要类似的标记：在处标记，在处标记。总结一下：auto add = [&](int l, int r, int k, int d) {  \n    cur_add[l] += k;\n    cur_add[r+1] -= k + (r - l + 1) * d;\n\n    inc_add[l] += d;\n    inc_add[r+1] -= d;\n}\n\nauto update_current_position = [&](int i) {\n    cur += cur_add[i];\n    inc += inc_add[i];\n    cur += inc;\n}靠数学分析一下差分数组下标原数组$一阶差分$二阶差分$不难看出二阶差分数组上产生了四次单点修改。所以我们先在二阶差分数组上修改最后再跑两次前缀和即可得到最后的数组。放个例题CF1661D#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    vector<ll> a(n);\n    vector<ll> inc_add(n), sum_add(n);\n    for (auto &x : a)\n        cin >> x;\n\n    ll cur = 0, inc = 0, ans = 0;\n\n    for (int i = n - 1; i >= 0; i--) {\n        inc += inc_add[i];\n        cur += sum_add[i];\n        cur += inc;\n        auto x = a[i] + cur;\n        if (x > 0) {\n            int len = min(k, i + 1);\n            auto need = (x + len - 1) / len;\n            ans += need;\n            cur -= need * len;\n            inc += need;\n            if (i - len >= 0) {\n                inc_add[i-len] -= need;\n                sum_add[i-len] += need;\n            }\n        }\n    }\n    cout << ans << endl;\n}区间修改，单点查询此时我们就需要数据结构维护差分数组了维护一阶差分数组观察上面一阶差分可以发现有两个单点修改一个区间修改，是一阶差分的前缀和，所以用区间修改区间查询的数据结构即可（线段树，树状数组）维护二阶差分数组我们需要单点修改然后二阶前缀和，二阶前缀和可以拆成两个前缀和：维护和的前缀和即可。例题：洛谷P1438 无聊的数列#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (auto& x : a) cin >> x;\n\n    vector<int64_t> t1(n + 1), t2(n + 1); \n    auto add = [&](int idx, int x) {\n        for (int i = idx; i <= n; i += i&-i) {\n            t1[i] += x;\n            t2[i] += (int64_t)idx * x;\n        }\n    };\n    auto sum = [&](int idx) {\n        int64_t res = 0;\n        for (int i = idx; i > 0; i -= i&-i) {\n            res += (idx + 1) * t1[i] - t2[i];\n        }\n        return res;\n    };\n\n    while (m--) {\n        int op;\n        cin >> op;\n        if (op == 1) {\n            int l, r, k, d;\n            cin >> l >> r >> k >> d;\n            int len = r - l + 1;\n            add(l, k);\n            add(l + 1, d - k);\n            add(r + 1, -(k + len * d));\n            add(r + 2, k + (len-1)*d);\n        } else {\n            int i;\n            cin >> i;\n            cout << sum(i) + a[i-1] << '\\n';\n        }\n    }\n}区间修改，区间查询要是搞三阶前缀和那可能略显麻烦了，我们不妨转变思路用线段树，其实与正常的区间加类似，懒惰标记变成了这个区间加的等差数列的首项和公差。"},{"id":"arc076d","title":"AtCoder Regular Contest (ARC) 076F - Exhausted? 题解","content":"前置知识：霍尔定理（Hall's Theorem)也叫霍尔结婚定理(Hall's marriage theorem)。在二分图中，令两部分点集分别为, 则存在完美匹配（中的点集全部被匹配）的充分必要条件是:对于的任意子集,，其中为与直接相连的点的集合。题解本题是让我们求最大匹配数，但直接跑匹配算法肯定不合适，此时我们考虑霍尔定理：假设所有人的集合为,我们至少还需要。但是的子集的个数是指数级的所以不能直接考虑子集。但是我们发现总是所有椅子的一个前缀加一个后缀，也就是。于是我们可以考虑枚举，那么椅子的集合所对应的人的集合为,此时。但很显然的个数是的，还是太慢，不过这已经是一个很大的进步了。我们再想进一步优化，从小到大枚举，通过某些数据结构直接求得所有中的最大值：我们可以用线段树维护对于每一个,的最大值。对于每一个人的限制条件，当我们枚举到时，如果选择的的话，那么对应的人的集合就会包含，反映到维护的值上去的话就是把区间里的值+1。然后用中的最大值减当前的来更新答案。注意几点：按l从小到大的顺序可以保证前面的都是符合条件的，只要考虑的取值即可。维护的值是把除去的，因为我们只考虑 的取值。每个位置的都是固定的，所以建树的时候就可以加进去。特殊情况当为整个椅子的集合时，代码#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> struct SegTree {\n    int n, M;\n    vector<T> t;\n    SegTree(int n_, int _m) : n(n_), M(_m), t(4 * n) {\n        build(1, 0, n - 1);\n    }\n    void pull(int node) { t[node] = t[node * 2] + t[node * 2 + 1]; }\n    void build(int node, int l, int r) {\n        if (l == r) { return t[node].apply(l, r, -M + r - 1); }\n        int mid = (l + r) / 2;\n        build(node * 2, l, mid);\n        build(node * 2 + 1, mid + 1, r);\n        pull(node);\n    }\n    void push(int p, int l, int r) {\n        if (t[p].lazy) {\n            int m = (l + r) / 2;\n            t[p * 2].apply(l, m, t[p].lazy);\n            t[p * 2 + 1].apply(m + 1, r, t[p].lazy);\n            t[p].lazy = 0;\n        }\n    }\n    void add(int node, int ql, int qr, int l, int r, int x) {\n        if (r < ql || l > qr) return;\n        if (ql <= l && qr >= r) return t[node].apply(l, r, x);\n        push(node, l, r);\n        int mid = (l + r) / 2;\n        add(node * 2, ql, qr, l, mid, x);\n        add(node * 2 + 1, ql, qr, mid + 1, r, x);\n        pull(node);\n    }\n    T get(int node, int ql, int qr, int l, int r) {\n        if (ql <= l && qr >= r) return t[node];\n        push(node, l, r);\n        int mid = (l + r) / 2;\n        if (qr <= mid) return get(node << 1, ql, qr, l, mid);\n        if (ql > mid) return get(node << 1 | 1, ql, qr, mid + 1, r);\n        return get(node << 1, ql, qr, l, mid) +\n               get(node << 1 | 1, ql, qr, mid + 1, r);\n    }\n    // wrapper\n    void add(int l, int r, int x) {\n        assert(l >= 0 && l <= r && r < n);\n        add(1, l, r, 0, n - 1, x);\n    }\n    T get(int l, int r) {\n        assert(l >= 0 && l <= r && r < n);\n        return get(1, l, r, 0, n - 1);\n    }\n};\nstruct node {\n    int v = 0; // don't forget to set default value (used for leaves),\n               // not necessarily zero element\n    int lazy = 0;\n    void apply(int l, int r, int x) {\n        lazy += x;\n        v += x;\n    }\n    node operator+(const node &b) const {\n        node res;\n        res.v = max(v, b.v);\n        return res;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    const int M = 200000;\n    vector<vector<int>> rs(M + 1);\n    for (int i = 0; i < n; i++) {\n        int l, r;\n        cin >> l >> r;\n        rs[l].push_back(r);\n    }\n    SegTree<node> tr(m + 2, m);\n    int ans = n - m;\n    for (int l = 0; l <= M && l <= m - 1; l++) {\n        for (auto r : rs[l]) {\n            tr.add(l + 1, r, 1);\n        }\n        ans = max(ans, tr.get(l + 1, m + 1).v - l);\n    }\n    cout << ans << '\\n';\n}"},{"id":"binomial-inversion","title":"二项式反演","content":"感觉这篇讲得不错。目前就先记录公式，以后有更深的理解再补。形式零形式一形式二最常用的形式"},{"id":"bsearch_implementations","title":"二分搜索的两种写法","content":"背景：今天做了个题，用自己平常的二分写法很不方便，第一次碰到这种情况，为了防止后面再碰到类似的情况，决定记录一下二分的两种常见写法。根据搜索的条件，整个搜索区间可以被划分为两个区间，其中一个为符合条件的区间，我们想要的值就是最接近分界线的那个数：如果前半部分符合条件，那我们要找的是其中最大的那个值，反之则是后半部分中最小的那个值。这两种不同的情况会在写法有所不同。写法一：循环条件为，优点是不论哪部分符合条件，边界变化都是或，终止时，，也就是r是前半部分的最大值，l和后半部分的最小值，根据情况取或者。次方法缺点是不能同时进行两个二分搜索，不适合在某些二分的交互题里使用。写法二：循环终止条件为但中点的取法和边界的变化两种情况不一样：如果前半部分符合条件：搜索区间为while (l < r) {\n    int mid = (l + r + 1) / 2;\n    if (ok(mid)) l = mid;\n    else r = mid - 1;\n}如果后半部分符合条件：搜索区间为while (l < r) {\n    int mid = (l + r) / 2;\n    if (ok(mid)) r = mid;\n    else l = mid + 1;\n}总结下来就是：中点偏向分界线符合条件的话，边界移动到中点，否则要+1或者-1半开半闭区间是为了考虑到没有符合条件的数的情况，此时边界会移动到开区间那头，类似于找不到的话会返回。优点是可以同时进行两个二分，当其中一个区间收敛之后就不会再变化了。而且这种写法比较符合直觉，有些二分交互题中我就会不由自主的换成这种写法（虽然以前并没有仔细研究过）。缺点就是细节稍多，一是取中点的写法，二是注意开区间。"},{"id":"bundle-cpp-code","title":"用Clang打包C++代码","content":"作为一名算法竞赛选手，我一直在寻找避免复制粘贴板子的方法，这样我就的板子库就能更加复杂。受Egor的rust bundler启发，我不禁想C++也有没有相似的东西? 于是想起来很久之前看过这个博客然后我就话了点时间又找到了那篇博文，但并不是bundler而且看起来很复杂。评论区里有人提到用这个预处理命令。也许你知道，基本就是复制粘贴所以看起来好像有戏，但问题是预处理也会复制粘贴标准库，大概有20多万行。所以我继续搜寻能不能跳过系统头文件，然后就找到了这个，但只有clang才能用，因为我自己也用clang所以就没再找gcc的解决办法。命令如下clang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc main.cpp解释： 只进行预处理 关闭在预处理中生成行标记 关闭C++标准库 关闭内置的#include目录（不太知道什么意思，可能没用）因为系统头文件不会被保留，所以需要另一条命令把体统头文件加上，然后我就写了一个shell函数一起做这两件事：expand_cpp () {\n    clang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc $1 | gsed \"1s/^/#include <bits\\/stdc++.h>\\n/\" | pbcopy\n}其中是macOS上复制到剪切板的命令，其他平台用相应的命令代替即可。"},{"id":"clangd-backgound-indexing","title":"以算法竞赛写题为例的 clangd 后台索引(backgound indexing)使用指南","content":"我也不知道标题在说什么问题虽然目前我的板子大部分都进行了封装，include就能直接用，但依然有两个痛点：需要手动 include，每次要跳到最上面include之后再回来不免有些麻烦由于目前是靠 compile_flags.txt 配置的 clangd，所以并不会有后台索引，也就是说include之后并不能获得该文件的补全信息，而我经常记不得类或者函数的名字所以不得不跳转过去看一眼，而对于有些非常长的名字，也还是要跳转打开文件一次这样clangd才能索引该文件。如果有后台索引的话这两个问题都能完美解决！步骤首先在放代码的目录里写一个非常简单的 :cmake_minimum_required(VERSION 3.1...3.26)\n\nproject(\n    competitive programming\n  VERSION 1.0\n  LANGUAGES CXX)\n\nset (CMAKE_CXX_STANDARD 20)\n\nadd_executable(include-all include-all.cpp)\n\ninclude_directories(板子的目录)我们还要新建一个 include-all.cpp 并在里面 include 我们所有的板子文件（后面会提到他的所用）。然后执行  这样就能得到  文件，clangd就是根据这个文件来进行索引的。\n然而你发现  里面其实并没有头文件的信息。这是因为头文件并不是一个 translation unit 所以 cmake 就不会为其生成编译信息。那怎么办呢？我们可以借助 compdb 这个工具为我们加入头文件的信息，这就是 CMakeLists.txt 里 include-all.cpp 的作用。然后我们执行:compdb -p . list > new.json # 这里不能直接重定向到compile_commands.json，好奇的话可以自己试一下\nmv new.json compile_commands.json # 把原来的覆盖掉当你以为大功告成的时候你会发现好像还是不行，这是因为 clangd 默认不会索引当前目录之外的东西（大概是这么个意思），要给 clangd 加上  参数。最后的最后，要保证你的板子第一行要有 ，不然不能自动 include。以上便是我从下午三点到晚上十点的研究成果（为什么我总是花大把时间研究一些没什么用的功能）"},{"id":"cover_edges_with_path_of_length_two","title":"用长为2的路径覆盖所有边","content":"貌似还挺经典的一个问题显然我们要单独考虑每个连通块，结论是答案为，其中m为边数。寻找答案的算法如下：跑一遍dfs得到dfs生成树，然后从下往上处理边：将与当前节点相连的边两两配对，如果边数是奇数就留下与父亲节点相连的那条边给父亲节点。这样就可以保证所有边都被覆盖了。代码：#include <bits/stdc++.h>\n\nusing namespace std;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin>>n>>m;\n    vector<vector<int>> g(n);\n    for (int i=0; i<m; i++) {\n        int u, v;\n        cin>>u>>v;\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> vis(n);\n    vector<tuple<int, int, int>> res;\n    auto dfs=[&](auto& dfs, int u, int p) -> bool {\n        vis[u]=1;\n        vector<int> w;\n        if (p!=-1) w.push_back(p);\n        for (auto v : g[u]) {\n            if (v==p) continue;\n            if (!vis[v]) {\n                if (dfs(dfs, v, u)) w.push_back(v);\n            } else if (vis[v]==1) w.push_back(v);\n        }\n\n        while (w.size() >= 2) {\n            res.emplace_back(*(w.rbegin()+1), u, w.back());\n            w.pop_back();\n            w.pop_back();\n        }\n        vis[u]=2;\n        return !w.empty();\n    };\n    for (int i=0; i<n; i++) {\n        if (!vis[i]) dfs(dfs, i, -1);\n    }\n    cout<<res.size()<<'\\n';\n    for (auto& [x, y, z] : res) cout<<x+1<<' '<<y+1<<' '<<z+1<<'\\n';\n    return 0;\n}练习题：CF1159E - Off by Onegym102001K - BoomerangsCF858E - Wizard's Tour"},{"id":"cp-bot-dev-log-1","title":"全新的开始 - 算法竞赛机器人开发日志1","content":"我的机器人，明明只有两个功能，却已重写了两次了，第一次从C++搬到Python，现在又从Python搬到Nonebot框架上（虽说还是Python)，以后应该不会再动了。这次搬迁起源于周六在给上一版本写readme，准备发布到GitHub上，当时我在特点里写下了不使用框架（可能是个错误的决定）然后我就不禁思考这到底是不是个错误的决定：当初不用框架的原因也很简单，就是不想学框架的那一套，然后又觉得自己造点轮子也挺好玩的，但后来发现自己需要造的轮子越来越大时就不那么好玩了，目前有几个大轮子要造：命令与参数系统，如果将来命令增多的话一堆if else加字符串匹配又麻烦又丑定时命令，比赛提醒是我接下来想做的一大特性，因为我老是忘AtCoder的比赛配置系统，要是将来别人要用的话一定要做好配置系统于是我又看了看Nonebot的文档，发现好像也没那么麻烦，而且自带命令与定时系统，又想到框架难道不就是为了让开发者专注于编写业务逻辑吗？于是就想先试试看，然后第二天早上加中午吃完饭一点时间就基本搬过去了，又看到非常fancy的log界面就决定完全转到Nonebot上了。那又为什么要写开发日志捏？因为机器人其实好久没再继续开发了，自从前两周发现了APScheduler之后就开始研究加缓存与比赛提醒的功能，然后就萌生了写日志的想法，这次搬迁又差不多算是“从头开始”所以就每周写一篇开发日志记录本周工作以及接下来要做的任务，顺便起到督促自己的作用。第一篇（这篇）本来应该周日写的来着，结果周日出去玩由于突发情况回来的很晚，基本上接着就上床睡觉了。以后日志争取在周末写，这次由于背景介绍所以稍长，以后应该就简单记录一下。上周工作：基本完成搬运，两个命令已可用，但缓存还没搞定一些重构：重命名，添加type hint变成包之后import语句要变成类似，把所有import都修了（还挺多的）TODO：参数系统，查比赛命令挺需要的画图功能也很需要看看内置的scheduler能不能用数据库的job store，如果能的话：尽快能把缓存弄好比赛提醒根据配置开关某些功能，比如是否使用缓存重构一些抄的TLE的代码，感觉不是很喜欢TLE的一些设计搬一些TLE其他的有趣的功能"},{"id":"cp-bot-dev-log-2","title":"算法竞赛机器人开发日志2","content":"这周没做什么大功能，做了下几件小事：参数原来  就是专门负责这个的，可以传入一个 argument parser，那这样就很简单了，于是给查比赛加了  和  以显示前 x 条或者全部比赛。数据库相关最近了解到 ORM（我真是孤陋寡闻现在才知道这个东西），于是决定放弃 MongoDB 还是用关系型数据库，但 APScheduler 的  好像没完全支持 SQLAlchemy 2所以比赛提醒暂时就没法做可持久化了，但一想可持久化也没有太大的用，每次更新缓存的时候重新添加一遍提醒应该就够了。。。缓存的话到是弄完了但是没法测试，因为今天cf的API一直都是挂了的。说到ORM就不得不提重构的事：重构现在  类不再用  了，因为可以和ORM（用的SQLModel）的Model共用一个类，而且SQLModel的model也是Pydantic model所以可以直接用，比之前优雅多了。不得不说SQLModel的理念真的很有想法。LaTex插件受群友的提示写了个渲染LaTex的插件，试了Matplotlib和SymPy的latex功能都不太满意，最后基于SymPy的函数自己写了个插件。TODO缓存和提醒继续研究TLE的代码看看有没有好玩的功能把代码整理好开源到github上"},{"id":"cugb-21-training-4-sol","title":"CUGBACM21级组队训练（四）题解","content":"出题思路没有很水的签到，中档题为主思维题为主，穿插一些算法知识/思维两个码农题练一下码力A. 座位安排把每对朋友的要求看成一条边，那么每个点的度数最多为2，说明每个连通分量要么是环要么是链。是链的话每个要求都能满足，是环的话除非整个图是一个大环，否则必然有一条边不能满足，那么舍弃掉钱最少的条件。#include <bits/stdc++.h>\n\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<array<int, 2>>> g(n);\n    ll sum = 0;\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        u--, v--;\n        sum += w;\n        g[u].push_back({v, w});\n        g[v].push_back({u, w});\n    }\n\n    vector<int> vis(n);\n    // mn: 当前连通分量中的最小边，sz: 当前连通分量的大小\n    auto dfs = [&](auto& slf, int u, int p, int mn, int sz) -> void {\n        vis[u] = 1;\n        for (auto [v, w] : g[u]) {\n            if (v == p) continue;\n            if (vis[v] == 1) { // 成环了\n                if (sz != n) {\n                    sum -= min(mn, w);\n                }\n            } else if (vis[v] == 0) {\n                slf(slf, v, u, min(mn, w), sz + 1);\n            }\n        }\n        vis[u] = 2;\n    };\n\n    for (int i = 0; i < n; i++) {\n        if (!vis[i]) {\n            dfs(dfs, i, i, 1e9, 1);\n        }\n    }\n\n    cout << sum << endl;\n    return 0;\n}B. 左撇子与右撇子非常简单的 dp，令  为考虑了前  个问题，且左撇子与右撇子数量之差为  时所需要采访的最少的老师个数。我们遍历每个问题，对于每个问题，我们要么只采访左撇子，要么只采访右撇子，要么左撇子右撇子各采访一个。具体状态转移可以看代码~#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t, n;\n    cin >> t >> n;\n\n    vector<int> cnt1(t), cnt2(t);\n    for (int i = 0; i < n; i++) {\n        int x;\n        char c;\n        cin >> x >> c;\n        x--;\n        if (c == 'L') cnt1[x]++;\n        else cnt2[x]++;\n    }\n\n    const int INF = 1e9;\n    vector<int> dp(2 * n + 1, INF);\n    dp[n] = 0;\n\n    for (int i = 0; i < t; i++) {\n        vector<int> ndp(2 * n + 1, INF);\n\n        for (int j = 0; j <= 2 * n; j++) {\n            // 只采访左撇子\n            for (int k = 1; k <= cnt1[i]; k++) {\n                if (j - k >= 0)\n                    ndp[j - k] = min(ndp[j - k], dp[j] + k);\n            }\n            // 只采访右撇子\n            for (int k = 1; k <= cnt2[i]; k++) {\n                if (j + k <= 2 * n)\n                    ndp[j + k] = min(ndp[j + k], dp[j] + k);\n            }\n\n            // 各采访一个\n            if (cnt1[i] && cnt2[i]) {\n                ndp[j] = min(ndp[j], dp[j] + 2);\n            }\n        }\n        swap(dp, ndp);\n    }\n\n    cout << (dp[n] == INF ? -1 : dp[n]) << endl;\n    return 0;\n}C. 打扫道路一种比较简单的判断一条边  是否在  到  的最短路上的方法是检查  到  的最短距离加  到  的最短距离（也可能反过来）加  边的长度是否是  到  的最短距离，也就是检查：#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvector<int> dijkstra(const vector<vector<array<int, 2>>>& g, int start) {\n    constexpr int INF = 1e9;\n    int n = (int)g.size();\n\n    vector dis(n, INF);\n\n    using node = std::pair<int, int>;\n    std::priority_queue<node, std::vector<node>, std::greater<>> q;\n\n    dis[start] = 0;\n    q.emplace(0, start);\n\n    while (!q.empty()) {\n        auto [d, u] = q.top();\n        q.pop();\n\n        if (d != dis[u]) continue;\n\n        for (auto [v, cost] : g[u]) {\n            if (dis[v] > d + cost) {\n                dis[v] = d + cost;\n                q.emplace(dis[v], v);\n            }\n        }\n    }\n    return dis;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, a, b;\n    cin >> n >> m >> a >> b;\n    a--, b--;\n\n    vector<vector<array<int, 2>>> g(n);\n    vector<array<int, 3>> edges(m);\n\n    for (auto& [u, v, w] : edges) {\n        cin >> u >> v >> w;\n        u--, v--;\n        g[u].push_back({v, w});\n        g[v].push_back({u, w});\n    }\n\n    auto disa = dijkstra(g, a);\n    auto disb = dijkstra(g, b);\n\n    int ans = 0;\n    int mndis = disa[b];\n    for (auto [u, v, w] : edges) {\n        int mn = min(disa[u] + disb[v], disa[v] + disb[u]) + w;\n        if (mn == mndis) {\n            ans += w;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}还有一种做法是利用从  开始的最短路 DAG（K 题题解中有介绍），将其中的边反转后后从  出发，所有经过的边就是在  到  的最短路上的边。#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvector<int> dijkstra(const vector<vector<array<int, 2>>>& g, int start) {\n    constexpr int INF = 1e9;\n    int n = (int)g.size();\n\n    vector dis(n, INF);\n\n    using node = std::pair<int, int>;\n    std::priority_queue<node, std::vector<node>, std::greater<>> q;\n\n    dis[start] = 0;\n    q.emplace(0, start);\n\n    while (!q.empty()) {\n        auto [d, u] = q.top();\n        q.pop();\n\n        if (d != dis[u]) continue;\n\n        for (auto [v, cost] : g[u]) {\n            if (dis[v] > d + cost) {\n                dis[v] = d + cost;\n                q.emplace(dis[v], v);\n            }\n        }\n    }\n    return dis;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, a, b;\n    cin >> n >> m >> a >> b;\n    a--, b--;\n\n    vector<vector<array<int, 2>>> g(n);\n    vector<array<int, 3>> edges(m);\n\n    for (auto& [u, v, w] : edges) {\n        cin >> u >> v >> w;\n        u--, v--;\n        g[u].push_back({v, w});\n        g[v].push_back({u, w});\n    }\n\n    auto dis = dijkstra(g, a);\n\n    vector<int> vis(n);\n    int ans = 0;\n    auto dfs = [&](auto& slf, int u) -> void {\n        vis[u] = 1;\n        for (auto [v, cost] : g[u]) {\n            if (dis[v] + cost == dis[u]) {\n                ans += cost;\n                if (vis[v]) continue;\n                slf(slf, v);\n            }\n        }\n    };\n    dfs(dfs, b);\n\n    cout << ans << endl;\n\n    return 0;\n}D. 厕所管理员首先把所有人按 deadline 归类，然后从小到大遍历 deadline，我们维护到当前时间点，两种坑位能让多少人上完厕所，假设当前的 deadline 为 ，上一个 deadline 为 ，那么我们能多让  的不需要厕纸的人上完厕所，能多让  需要厕纸的人上完厕所。对于当前 deadline，我们先让不需要厕纸的人尽量去没有厕纸的坑位，如果剩下的不需要厕纸的人（如果有）加上需要厕纸的人大于有厕纸的坑位能让人上完厕所是数量，答案就是 No，否则我们继续处理下一个 deadline。#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int s, n;\n    cin >> s >> n;\n\n    map<int, array<int, 2>> cnt;\n    for (int i = 0; i < n; i++) {\n        int deadline;\n        char c;\n        cin >> deadline >> c;\n        cnt[deadline][c == 'y']++;\n    }\n\n    ll have[2] {}; // 到当前时间点，两种坑位能让多少人上完厕所\n    int prev = 0;\n\n    for (const auto [deadline, v] : cnt) {\n        have[1] += deadline - prev;\n        have[0] += ll(deadline - prev) * (s - 1);\n        prev = deadline;\n\n        auto [dont_need, need] = v;\n\n        ll no_paper = min((ll)dont_need, have[0]); // 去没有厕纸的坑位的人数\n        dont_need -= no_paper;\n        have[0] -= no_paper;\n\n        if (dont_need + need > have[1]) { // 剩下的人只能去有厕纸的坑位，如果超出了就是no\n            cout << \"No\\n\";\n            return 0;\n        }\n        have[1] -= dont_need + need;\n    }\n    cout << \"Yes\\n\";\n    return 0;\n}E. 这一样吗？模拟题，没什么思维难度。一种比较好想的做法可能是先预处理出配对的括号，每一对括号就是一个子树，然后跑一遍 dfs。下面给出一个只遍历一次的实现。一个比较容易错的输入是两棵树都只有一个节点，且编号不一样，如果你给  每个节点都开了一个邻接表，那么你将判断不出来 No。一种解决方法是把根节点连到节点 0 上。#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    string s, t;\n    getline(cin, s);\n    getline(cin, t);\n    s = \"0(\" + s + \")\";\n    t = \"0(\" + t + \")\";\n\n    auto build = [&](const string& s) {\n        const int N = 1e6;\n        vector<vector<int>> g(N + 1);\n\n        string current_num;\n        vector<int> stack;\n\n        for (auto c : s) {\n            if (c == ' ') continue;\n\n            if (c == '(') {\n                if (!current_num.empty()) {\n                    int num = stoi(current_num);\n                    current_num.clear();\n                    if (!stack.empty()) {\n                        g[stack.back()].push_back(num);\n                    }\n                    stack.push_back(num);\n                }\n            } else if (c == ')') {\n                if (!current_num.empty()) {\n                    int num = stoi(current_num);\n                    current_num.clear();\n                    if (!stack.empty()) {\n                        g[stack.back()].push_back(num);\n                    }\n                    stack.push_back(num);\n                }\n                stack.pop_back();\n            } else {\n                current_num += c;\n            }\n        }\n\n        for (int i = 0; i <= N; i++) {\n            sort(begin(g[i]), end(g[i]));\n        }\n\n        return g;\n    };\n\n    auto gs = build(s), gt = build(t);\n    cout << (gs == gt ? \"Yes\\n\" : \"No\\n\");\n    return 0;\n}F. 电影之夜如果我们把依赖关系（）看成是图的话，这种每个点出度为 1 的图被称为函数图（functional graph）。图的结构由一个环以及一些挂在环上的树构成。对于环上的人，他们要么都去要么都不去，所以我们可以把他们看成一个点，这样图就变成了一个有向的树。我们在树上 dp，定义  为：邀请  且同时让  的子树里的人的要求都满足的邀请方式的数量，那么状态转移为：如果怕 dfs 找环写错的话也可以利用强连通分量来缩点。#include <bits/stdc++.h>\n\n\nusing namespace std;\nusing ll = long long;\n\ninline auto scc(const std::vector<std::vector<int>>& g) -> std::pair<int, std::vector<int>> {\n    int n = (int)size(g);\n    int pos = 0;\n    std::vector<bool> on_stk(n);\n    std::vector<int> low(n), ord(n, -1), color(n), stk;\n    int cnt = 0;\n\n    auto dfs = [&](auto& slf, int u) -> void {\n        low[u] = ord[u] = pos++;\n        stk.push_back(u);\n        on_stk[u] = true;\n        for (auto v : g[u]) {\n            if (ord[v] == -1) slf(slf, v);\n            if (on_stk[v]) low[u] = std::min(low[u], low[v]);\n        }\n        if (low[u] == ord[u]) {\n            while (true) {\n                int v = stk.back();\n                stk.pop_back();\n                on_stk[v] = false;\n                color[v] = cnt;\n                if (u == v) break;\n            }\n            cnt++;\n        }\n    };\n\n    for (int i = 0; i < n; i++) {\n        if (ord[i] == -1) {\n            dfs(dfs, i);\n        }\n    }\n\n    return {cnt, color};\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> g(n);\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        a[i]--;\n        g[i].push_back(a[i]);\n    }\n\n    auto [cnt, color] = scc(g);\n\n    const int mod = 1e9+7;\n    int ans = 1;\n    vector<vector<int>> g2(cnt); // 缩点之后的图\n    vector<int> deg(cnt);\n    for (int i = 0; i < n; i++) {\n        if (color[a[i]] != color[i]) {\n            g2[color[a[i]]].push_back(color[i]);\n            deg[color[i]]++;\n        }\n    }\n\n    vector<int> dp(cnt, 1);\n    for (int i = cnt - 1; i >= 0; i--) {\n        for (auto v : g2[i]) {\n            dp[i] = (ll)dp[i] * (dp[v] + 1) % mod;\n        }\n    }\n\n    for (int i = 0; i < cnt; i++) {\n        if (deg[i] == 0) { // 不同分量之间互相独立\n            ans = (ll)ans * (dp[i] + 1) % mod;\n        }\n    }\n    cout << (ans - 1 + mod) % mod << endl;\n    return 0;\n}G. 送礼物不妨考虑按  的大小遍历礼物，假设送给小明礼物 ，那么送给小红任意  之前的礼物都不会使小明嫉妒。同时我们还要不能使小红嫉妒，所以我们要知道在前  个礼物中有多少个  使得 ，我们可以将  离散化之后用树状数组维护。更本质地说，这个题是二维偏序问题，二维偏序问题通常先按其中一个维度排序然后用树状数组解决。感兴趣的同学可以自行了解。#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T> struct Fenwick {\n    int n;\n    std::vector<T> t;\n\n    Fenwick(int n_) : n(n_), t(n + 1) {}\n    Fenwick(const std::vector<T> &v) : Fenwick((int)v.size()) {\n        for (int i = 1; i <= n; i++) {\n            t[i] += v[i - 1];\n            int j = i + (i & -i);\n            if (j <= n) t[j] += t[i];\n        }\n    }\n\n    void add(int i, const T& x) {\n        assert(i >= 0 && i < n);\n        for (i++; i <= n; i += i & -i) {\n            t[i] += x;\n        }\n    }\n\n    // Returns `data[0] + ... + data[i - 1]`.\n    template <typename U = T> U get(int i) {\n        assert(i >= 0 && i <= n);\n        U res{};\n        for (; i > 0; i -= i & -i)\n            res += t[i];\n        return res;\n    }\n\n    // Returns `data[l] + ... + data[r - 1]`.\n    template <typename U = T> U get(int l, int r) {\n        assert(l >= 0);\n        assert(l <= r);\n        assert(r <= n);\n        return get<U>(r) - get<U>(l);\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<int> a(n), b(n);\n    for (auto& x : a) {\n        cin >> x;\n    }\n    for (auto& x : b) {\n        cin >> x;\n    }\n\n    auto compress = b;\n    sort(begin(compress), end(compress));\n    compress.erase(unique(begin(compress), end(compress)), end(compress));\n    for (auto& x : b) {\n        x = lower_bound(begin(compress), end(compress), x) - begin(compress);\n    }\n\n    vector<int> order(n);\n    iota(begin(order), end(order), 0);\n    sort(begin(order), end(order), [&](int i, int j) { return a[i] < a[j]; });\n\n    Fenwick<int> tr(n);\n    ll ans = 0;\n    for (int i = 0, j = 0; i < n; ) {\n        while (j < n && a[order[i]] == a[order[j]]) {\n            tr.add(b[order[j]], 1);\n            j++;\n        }\n\n        while (i < j) {\n            ans += tr.get(b[order[i]], n);\n            i++;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}H. 循环排序如果  中有重复的元素的话，不失一般性地，假设有两个 1，首先我们可以利用一次操作将两个 1 放到 1 和 2 的位置。然后我们可以利用这两个 1 来交换任意两个位置：假设我们要交换  ()，我们只需要应用操作  和  即可交换 。如果  中没有重复的元素，说明  是一个长为  的排列。我们不妨从逆元的角度入手，题目中的操作本质上就是先交换 ，再交换 ，由于一次交换操作会使整个序列的逆元个数的奇偶性改变（想想为什么），所以循环操作不会使整个序列的逆元个数的奇偶性改变，所以不妨大胆猜想当且仅当整个序列的逆元的个数为偶数个时，我们可以通过循环操作排序。下面给出当逆元个数为偶数个时可以通过循环操作排序的证明：考虑将  依次放到第  个位置，对于每一个  我们可以用一次循环操作在不破坏之前排好序的元素的情况下把  放到位置 。在排好前  个元素之后，由于我们没有改变逆序对的奇偶性，所以最后剩下的两个元素也一定是有序的。更本质的，我们也可以从排列（permutation）的角度来看这个问题，定义一个排列的奇偶性为它的逆序对数量的奇偶性。三循环可以用排列来表示，所有偶排列都可以表示为三循环排列的复合。想深入了解的话可以看这篇英文博客（不用全看，挑自己感兴趣的即可）。#include <bits/stdc++.h>\n\n// 归并排序求逆序对个数\ntemplate<typename T>\nint64_t count_inversion(const std::vector<T>& v) {\n    auto a(v);\n    std::vector<T> tmp(v.size());\n    int64_t cnt{};\n    auto merge = [&](auto& slf, int l, int r) {\n        if (r - l <= 1) {\n            return;\n        }\n        int mid = l + (r - l) / 2;\n        slf(slf, l, mid);\n        slf(slf, mid, r);\n        for (int i = l, j = mid, k = l; k < r; k++) {\n            if (j == r || (i < mid && a[i] <= a[j])) {\n                tmp[k] = a[i++];\n            } else {\n                tmp[k] = a[j++];\n                cnt += mid - i;\n            }\n        }\n        std::copy(tmp.begin() + l, tmp.begin() + r, a.begin() + l);\n    };\n    merge(merge, 0, (int)v.size());\n    return cnt;\n}\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n    for (auto& x : a) {\n        cin >> x;\n        x--;\n    }\n\n    if (set(begin(a), end(a)).size() != n) {\n        cout << \"Yes\\n\";\n        return 0;\n    }\n\n    cout << (count_inversion(a) % 2 ? \"No\\n\" : \"Yes\\n\");\n    return 0;\n}I. 送礼物2本题做法不唯一，下面介绍 dp 做法：不难想到一种 dp 状态 ，代表前  个数中，是否存在和为  且大小为  的子集。本来想卡掉这个做法的，和易老师以及伍老师讨论之后还是放弃了，下面是优化后的做法：设  为前  个数中，和为  的子集的大小的集合。例如，假设，因为 ，那么 。那么状态转移是显然的：如果我们用二进制表示集合的话，这个状态转移可以被非常容易的写成dp[i][sum + a[i]] |= dp[i - 1][sum] << 1;这个优化技巧在找哈密顿路径算法中也有应用。#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n    for (auto &x : a) {\n        cin >> x;\n    }\n\n    int sum = accumulate(begin(a), end(a), 0);\n\n    vector dp(sum + 1, 0);\n    dp[0] = 1;\n\n    for (auto x : a) {\n        for (int i = sum - x; i >= 0; i--) {\n            dp[i + x] |= dp[i] << 1;\n        }\n    }\n\n    for (int j = 0; j <= sum; j++) {\n        for (int i = 1; i < n; i++) {\n            if ((dp[j] >> i & 1) && i * (sum - j) == j * (n - i)) {\n                cout << \"Yes\\n\";\n                return 0;\n            }\n        }\n    }\n    cout << \"No\\n\";\n    return 0;\n}J. 寻宝不难看出这个是 bfs（只是状态有点复杂），由于数据范围比较小，所以我们可以直接记录当前在第几个单词的第几个位置。由于不能经过同一个位置两次，也就是说在一行里只能向左或者向右，所以我们还要记录当前的方向。所以我们 bfs 的状态就是 ，代表到达  这个位置，当前字母是第  个单词的第  位置，且当前方向是  的最短路径。具体实现细节请看代码。#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconstexpr int N = 50;\nint dis[N][N][N][N][3];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector a(n, vector<char>(m));\n    vector<string> words(k);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> a[i][j];\n        }\n    }\n    for (auto &s : words) {\n        cin >> s;\n    }\n\n    queue<array<int, 5>> q;\n    memset(dis, -1, sizeof(dis));\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < k; j++) {\n            if (a[0][i] == words[j][0]) {\n                dis[0][i][j][0][0] = 0;\n                q.push({0, i, j, 0, 0});\n            }\n        }\n    }\n\n    const vector<pair<int, int>> dir{{1, 0}, {0, 1}, {0, -1}};\n    auto update_dis = [](int &x, const int y) {\n        if (x == -1) {\n            x = y + 1;\n            return true;\n        }\n        return false;\n    };\n    while (!q.empty()) {\n        auto [i, j, word_idx, char_idx, d] = q.front();\n        q.pop();\n\n        for (int dir_idx = 0; dir_idx < 3; dir_idx++) {\n            auto [di, dj] = dir[dir_idx];\n            if (d != 0 && dir_idx != 0 && dir_idx != d) {\n                continue;\n            }\n            int next_i = i + di, next_j = j + dj;\n            if (next_i < n && next_j >= 0 && next_j < m) {\n                if (char_idx == words[word_idx].size() - 1) { // 当前是一个单词的结尾\n                    for (int next_word = 0; next_word < k; next_word++) { // 检查是否匹配任意单词的第一个字符\n                        if (a[next_i][next_j] == words[next_word][0]) {\n                            if (update_dis(dis[next_i][next_j][next_word][0][dir_idx],\n                                           dis[i][j][word_idx][char_idx][d])) {\n                                q.push({next_i, next_j, next_word, 0, dir_idx});\n                            }\n                        }\n                    }\n                } else {\n                    if (a[next_i][next_j] == words[word_idx][char_idx + 1]) { // 检查是否匹配下一个字符\n                        if (update_dis(\n                                dis[next_i][next_j][word_idx][char_idx + 1][dir_idx],\n                                dis[i][j][word_idx][char_idx][d])) {\n                            q.push({next_i, next_j, word_idx, char_idx + 1, dir_idx});\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 1e9;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < k; j++) {\n            for (int d = 0; d < 3; d++) {\n                auto x = dis[n - 1][i][j][words[j].size() - 1][d];\n                if (x != -1) {\n                    ans = min(ans, x);\n                }\n            }\n        }\n    }\n    if (ans == 1e9) {\n        cout << \"impossible\\n\";\n    } else {\n        cout << ans + 1 << '\\n';\n    }\n    return 0;\n}K. 旅行记录首先我们跑一遍最短路，对于每个点，如果到这个点的最短距离在里程记录里出现过，我们就标记这个点。我们要找的就是一条经过  个标记过的点到达点  的路径，并且路径是最短路。考虑从点 1 起始的所有最短路上的所有边所构成的子图，如果我们将这些边定向（从离点 1 近的点指向离点 1 远的点），我们将会得到一个 DAG。这个DAG上从点 1 到点  的任意路径都是一条最短路。由于是 DAG，我们可以按拓扑序 dp，令  为到达  时经过的最多标记的点的数量，令  是否有多条这样的路径。状态转移的代码：for (int v : g[u]) { // g 是上面提到的DAG\n    if (dp[u] + marked[v] > dp[v]) {\n        dp[v] = dp[u] + seen[v];\n        multi[v] = multi[u];\n        prev[v] = u;\n    } else if (dp[u] + seen[v] == dp[v]) {\n        multi[v] = 1;\n    }\n}#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m, d;\n    cin >> n >> m >> d;\n    vector<vector<array<int, 2>>> g(n);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        u--, v--;\n        g[u].push_back({v, w});\n    }\n\n    set<ll> log;\n    for (int i = 0; i < d; i++) {\n        ll t;\n        cin >> t;\n        log.insert(t);\n    }\n\n    constexpr long long INF = 1e18;\n    vector dis(n, INF);\n\n    using node = std::pair<long long, int>;\n    priority_queue<node, vector<node>, greater<>> q;\n    dis[0] = 0;\n    q.emplace(0, 0);\n    while (!q.empty()) {\n        auto [d, u] = q.top();\n        q.pop();\n        if (d != dis[u]) continue;\n        for (auto [v, cost] : g[u]) {\n            if (dis[v] > d + cost) {\n                dis[v] = d + cost;\n                q.emplace(dis[v], v);\n            }\n        }\n    }\n\n    vector<int> seen(n);\n    for (int i = 0; i < n; i++) {\n        if (log.count(dis[i])) {\n            seen[i] = 1;\n        }\n    }\n\n    vector<int> order(n);\n    iota(begin(order), end(order), 0);\n    // 按距离排序是一种合法的拓扑序\n    sort(begin(order), end(order), [&](int i, int j) { return dis[i] < dis[j]; });\n\n    vector<int> dp(n, -1), multi(n), prev(n);\n    dp[0] = seen[0];\n    for (auto u : order) {\n        for (auto [v, w] : g[u]) {\n            if (dis[u] + w == dis[v]) { // 这是一条最短路上的边\n                if (dp[u] + seen[v] > dp[v]) {\n                    dp[v] = dp[u] + seen[v];\n                    multi[v] = multi[u];\n                    prev[v] = u;\n                } else if (dp[u] + seen[v] == dp[v]) {\n                    multi[v] = 1;\n                }\n            }\n        }\n    }\n\n    if (dp[n - 1] != d) {\n        cout << \"0\\n\";\n    } else if (multi[n - 1]) {\n        cout << \"1\\n\";\n    } else {\n        vector<int> path;\n        int u = n - 1;\n        while (u != 0) {\n            path.push_back(u);\n            u = prev[u];\n        }\n        path.push_back(0);\n        reverse(begin(path), end(path));\n        cout << size(path) << '\\n';\n        for (auto x : path) {\n            cout << x + 1 << '\\n';\n        }\n    }\n    return 0;\n}L. 彩票枚举被涂黑两次的格子的个数，假设有  个格子被涂黑了两次。首先我们先选择第  个球的编号，它可以是我们填的  个数中的任意一个。前  个球中，有  个数是我们填的，我们先选被涂黑两次的格子，有  种选法，在剩下每个只涂黑一次的格子中我们选一个数，有  中选法。前  个球中没出现在纸上的有 。最后前  个球有  种顺序，第  个球后面的  个球有 种顺序。所以答案为：#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    ModInt(ll v = 0) : val(v % MOD) { if (val < 0) val += MOD; };\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const {\n        auto a = val, m = MOD, u = 0, v = 1;\n        while (a != 0) { auto t = m / a; m -= t * a; swap(a, m); u -= t * v; swap(u, v); }\n        assert(m == 1);\n        return u;\n    }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    friend ModInt operator+ (ModInt lhs, const ModInt& rhs) { return lhs += rhs; }\n    friend ModInt operator- (ModInt lhs, const ModInt& rhs) { return lhs -= rhs; }\n    friend ModInt operator* (ModInt lhs, const ModInt& rhs) { return lhs *= rhs; }\n    friend ModInt operator/ (ModInt lhs, const ModInt& rhs) { return lhs /= rhs; }\n    ModInt& operator+=(const ModInt& x) { if ((val += x.val) >= MOD) val -= MOD; return *this; }\n    ModInt& operator-=(const ModInt& x) { if ((val -= x.val) < 0) val += MOD; return *this; }\n    ModInt& operator*=(const ModInt& x) { val = int64_t(val) * x.val % MOD; return *this; }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<1'000'000'007>;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m, p;\n    cin >> m >> n >> p;\n    if (n == 0 && p == 0) {\n        cout << 1 << endl;\n        return 0;\n    }\n\n    if (p < n || p == m) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    vector<mint> fac(m + 1), pow(m + 1), invfac(m + 1);\n    fac[0] = pow[0] = 1;\n    for (int i = 1; i <= m; i++) {\n        fac[i] = fac[i - 1] * i;\n        pow[i] = pow[i - 1] * 2;\n    }\n\n    invfac[m] = fac[m].inv();\n    for (int i = m - 1; i >= 0; i--) {\n        invfac[i] = invfac[i + 1] * (i + 1);\n    }\n\n    auto C = [&](int n, int k) -> mint {\n        if (k > n || k < 0) return 0;\n        return fac[n] * invfac[k] * invfac[n - k];\n    };\n\n    mint tot = fac[m];\n    mint win = 0;\n\n    for (int i = 0; i < n; i++) { // 枚举被涂了两次的格子的个数\n        win += C(n - 1, i) * pow[n - 1 - i] * C(m - 2 * n, p - 1 - (n - 1 + i)) * 2 * n * fac[p - 1] * fac[m - p];\n    }\n\n    cout << win / tot << endl;\n    return 0;\n}M. 连通分量计数考虑树形 dp，设  为选择  的子树中的节点的方式，使得导出子图中有  个连通分量， 代表节点  是否被选择。转移比较暴力，我们直接看 dfs 的代码：auto dfs(int u, int p) -> vector<vector<mint>> {\n    vector dp(2, vector<mint>(2));\n    dp[0][0] = 1;\n    dp[1][1] = 1;\n\n    for (auto v : g[u]) {\n        if (v == p) continue;\n\n        auto res = dfs(v, u);\n\n        // 每次将 v 子树的结果加入当前结果中，所以新的结果最多有dp.size() + res.size() \n        // 个连通分量\n        vector ndp(dp.size() + res.size() - 1, vector<mint>(2, 0));\n        for (int i = 0; i < (int)dp.size(); i++) {\n            for (int j = 0; j < (int)res.size(); j++) {\n                // 不选 u 的时候，子树中的连通分量互不干扰，\n                // 所以连通分量的个数为 i + j\n                ndp[i + j][0] += dp[i][0] * (res[j][0] + res[j][1]);\n                // 选 u 的时候，如果 v 不选，连通分量的个数也是直接相加\n                ndp[i + j][1] += dp[i][1] * res[j][0];\n                // 如果选 u 并且选 v 的话，会有两个连通分量相连，\n                // 所以总的连通分量个数为 i + j - 1\n                if (i + j > 0) {\n                    ndp[i + j - 1][1] += dp[i][1] * res[j][1];\n                }\n            }\n        }\n        swap(dp, ndp);\n    }\n\n    return dp;\n};整个 dfs 乍一看是  的，如果我们像上面那样只转移到当前处理过子树的大小之和，整个过程其实是  的（证明略，我也不会）。#include <bits/stdc++.h>\ntemplate <typename T, T MOD>\nstruct ModInt {\n    using prod_type = std::conditional_t<std::is_same_v<T, int>, long long, __int128>;\n    T val;\n    ModInt(const prod_type v = 0) : val(v % MOD) { if (val < 0) val += MOD; };\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const {\n        auto a = val, m = MOD, u = 0, v = 1;\n        while (a != 0) {\n            auto t = m / a;\n            m -= t * a;\n            std::swap(a, m);\n            u -= t * v;\n            std::swap(u, v);\n        }\n        assert(m == 1);\n        return u;\n    }\n    ModInt pow(prod_type n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1)\n                x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    friend ModInt operator+(ModInt lhs, const ModInt &rhs) { return lhs += rhs; }\n    friend ModInt operator-(ModInt lhs, const ModInt &rhs) { return lhs -= rhs; }\n    friend ModInt operator*(ModInt lhs, const ModInt &rhs) { return lhs *= rhs; }\n    friend ModInt operator/(ModInt lhs, const ModInt &rhs) { return lhs /= rhs; }\n    ModInt &operator+=(const ModInt &x) {\n        if ((val += x.val) >= MOD)\n            val -= MOD;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &x) {\n        if ((val -= x.val) < 0)\n            val += MOD;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &x) {\n        val = prod_type(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &x) { return *this *= x.inv(); }\n    bool operator==(const ModInt &b) const { return val == b.val; }\n    bool operator!=(const ModInt &b) const { return val != b.val; }\n    friend std::istream &operator>>(std::istream &is, ModInt &x) noexcept {\n        return is >> x.val;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) noexcept {\n        return os << x.val;\n    }\n};\nusing ModInt1000000007 = ModInt<int, 1'000'000'007>;\nusing ModInt998244353 = ModInt<int, 998244353>;\nusing namespace std;\nusing ll = long long;\nusing mint = ModInt998244353;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    vector<vector<int>> g(n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    auto dfs = [&](auto& slf, int u, int p) -> vector<vector<mint>> {\n        vector dp(2, vector<mint>(2));\n        dp[0][0] = 1;\n        dp[1][1] = 1;\n\n        for (auto v : g[u]) {\n            if (v == p) continue;\n\n            auto res = slf(slf, v, u);\n\n            vector ndp(dp.size() + res.size() - 1, vector<mint>(2, 0));\n            for (int i = 0; i < (int)dp.size(); i++) {\n                for (int j = 0; j < (int)res.size(); j++) {\n                    ndp[i + j][0] += dp[i][0] * (res[j][0] + res[j][1]);\n                    ndp[i + j][1] += dp[i][1] * res[j][0];\n                    if (i + j > 0) {\n                        ndp[i + j - 1][1] += dp[i][1] * res[j][1];\n                    }\n                }\n            }\n            swap(dp, ndp);\n        }\n\n        return dp;\n    };\n\n    auto res = dfs(dfs, 0, 0);\n    for (int i = 1; i <= n; i++) {\n        cout << res[i][0] + res[i][1] << '\\n';\n    }\n\n    return 0;\n}"},{"id":"cugb4tutr","title":"CUGBACM18级训练#4 题解","content":"B - Godfather Gym - 101649G题意： 给出一个有n个点的树，问去掉哪个点后剩下的树中最大的节点数最小（如果有多个按从小到大的顺序输出）。思路： 一开始没看见“保证是一棵树”想复杂了，先跑一遍dfs序，这样就能知道每个点除了父节点之外所有的子树的大小了，父节点对应的“子树”的大小就是n减去所有子树的大小之和。遍历所有点，找出所有“子树”中最大的那个，将其大小和编号作为数对加入数组中，然后对所有点排序，输出最小的那几个就行了。E - Wow! Such Doge! HDU - 4847题意： 给出一篇文章，问其中出现过多少个\"doge\"（不区分大小写）。思路： 先遍历文章，将所有大写之母转为小写，然后再用find或者暴力查找\"doge\"即可。G - Theme Section HDU - 4763题意： 给出一个字符串n找出一个最长的子串（theme），使其出现在开头中间和结尾（不允许重叠）思路： 一开始被样例误导了，以为theme里面只能有一种字符，wa了几发感觉不对，所以应该先跑前缀函数，然后从从第二位遍历到倒数第二位，如果某一位前缀函数大于其到第一位距离的一半，则取一半，找出其中的最大值，这样就得到了出现在中间的theme的最大长度。然后再判断最后一位的前缀长度是否大于整个字符串长度的三分之一，如果大于则取三分之一，这样就是出现在后面的theme的长度，输出中间和后面中比较小的一个即可。I - Path HDU - 6582不会网络流，有空再补。"},{"id":"cugb6","title":"CUGBACM18级训练#6 题解","content":"A - Keywords Search HDU - 2222题意： 给出单词和文章，问多少个单词在文章中出现过。思路： AC自动机板子题，之前也说过，不再赘述。B - 病毒侵袭 HDU - 2896题意： 给出n个单词（病毒）和m个长串（源码）问每个长串中有哪些单词出现过以及有多少个源码中有病毒。思路： 和上个题类似，字符集不只是26个字母了……是所有ASCII可见字符，不过开到130就行，不用统计出现次数，新加一个数组记录病毒编号在字典树上的位置，查询的时候如果某个节点对应的病毒编号不为0就加入答案数组，排序之后输出，如果答案数组的大小不为0，总个数加1，最后输出总个数。C - Sliding Window POJ - 2823题意： 数组长度为,长度为的窗户在数组上滑动，问每次滑动后的窗户中的最大和最小值。思路： 用线段树或者st表复杂度都是，单调队列可以做到，如果求最大值就维护单调递增序列，方法如下：不断从队尾出列，直到队尾元素大于待入队的数，因为又小又靠前面的数自然比不上又大又靠后的数。不断从队首出列，直到队首元素的下标在窗户的范围之内。输出队首元素，为当前窗户的最大值。求最小值步骤类似，实际维护的时候为了容易实现第二步，队列中存的是下标。D - Intersections Gym - 101853C题意： 给出两行序列，连接相同的数，问产生交点的个数。思路： 如果两个数在上下两行中的相对位置发生了变化，连线的时候就会产生一个交点。在读入第一行的时候记录每个数在数组中的位置。在读入第二行的时候将其替换为该数在第一行的出现位置，那么问题就变成了求逆序对（）个数的问题。有两种求法：归并排序和树状数组。这里介绍树状数组的做法：将所有的数的在第一行出现的位置和在第二行出现的位置作为数对保存在数组中，按照第一行出现的位置从大到小排序，这样每次插入一个数的时候前面数字的个数就是插入这个数产生新的逆序对的个数，因为数组是从大到小排序，此时已经插入的数都是比当前数大的数，而位置在前面的数就是符合逆序对定义的数。而这就可以用树状数组实现，计算前面数的个数就是算前缀和，插入就是在第二次出现的位置+1。E - 维护序列 Gym - 237040G题意： 维护一个序列，支持以下操作：把数列中的一段数全部乘一个值；把数列中的一段数全部加一个值；询问数列中的一段数的和模  的值。思路： 线段树改板子题，需要动点脑子，乘的时候加和乘的lazy tag都要更新。因为 其他貌似就忘 没 的  什 差 么 不 好 多 说 了 的了。F - Little Elephant and Array CodeForces - 220B见我的另一篇文章G - Tourists Gym - 101002I题意： 给出一棵树，计算所有两端其中一个是另一个倍数的路径长度和。思路： 计算树上路径自然要用到LCA，就是个倍增法板子题。I - 二维树状数组 ：单点修改，区间查询 Gym - 237040E题意： 见题目。思路： 见题目。K - Jzzhu and Cities CodeForces - 449B题意： 一个图中有条道路和条通往首都（标号为1的点）的铁路。问最多可以去掉多少铁路使得所有城市到首都的最短距离不变。思路： 把所有道路和铁路都放到图里，dijkstra是可以记录最短路路径条数的！（好像考试考过？），原理就是当更新距离的时候如果和当前最短路径一样长就路径条数+1，如果更短条数就置为1。最后遍历所有铁路，如果当前铁路比最短路长那么就可以去掉，如果和最短路一样的话就要看最短路还剩几条，如果大于1的话就可以去掉并且把最短路的条数-1。L - Alyona and the Tree CodeForces - 682C题意： 给出一棵边权点权树，问最少去掉几个点使得不存在这样的点：其子树上存在某点，其点权大于到的距离。思路： 计算树上所有的距离肯定超时，但是有这样一条性质，如果边权都是正数的话，如果那么，也就是说我们可以只计算到根节点的距离就行了，但是边权如果有负数上述性质就不成立了，但是我们可以稍加改动：当我们dfs的时候，如果当前点到根节点的距离小于0，那么我们就应该将距离置为0，然后接着dfs,这样就避免了前面的负权路径产生的干扰。"},{"id":"cugbacm3tutr","title":"CUGBACM18级训练#3 题解","content":"1.HDU1686题意： 给出两个串 ，问在中出现的次数。思路： kmp板子题，注意要用scanf。2.HDU2594题意： 给出两个字符串，求最长的既是前缀又是后缀的字符串。思路： 很明显就是把两个串拼起来然后求前缀函数，不过要注意的是拼起来的串的前缀函数有可能超过给出的串的长度，解决办法就是在两个串中间加一个符号。3.HDU6629题意： 给出字符串问用暴力算法求的Z函数（一个长度为n的数组，其中第i个元素为满足从位置i开始且为s前缀的字符串的最大长度。）需要的比较次数。思路： 求每一个位置的比较次数都等于这个位置的z函数+1，因为要往后面多比较一次发现不匹配了才会终止（如果比较到字符串末尾了即i+z[i]>=n就不用加1），求和就是答案。4.Codeforces 1200E题意： 给了你n个字符串，然后按照如下方式合并得到新串:如果为空串，则直接加入。否则，每次比较的后缀与前缀，取失配位置之后的后缀加入中求s′思路： 设答案串的长度为,需要合并的新串的长度为,将“新串+#+答案串后面长的子串”作为整体跑前缀函数，设整个串的最长公共前后缀的长度为,将新串下标为的子串加到答案串之后。5.HDU3613题意： 给出一字符串，其中每一种字符对应一个价值，将字符串切成两段，计算两段的价值和，方法如下：如果这一段是回文串，价值就是每一个字符对应的价值的和，否则该串价值为0。求两段价值之和的最大值。思路： 先跑一遍大可马拉车算法，然后遍历求出串的价值前缀和，然后枚举分割点，找到两个串的中心，判断中心的回文串是不是整个串，如果是就利用之前算的前缀和加那个串的价值，在枚举中不断更新答案即可。6. HDU2222题意：给出n个单词和一个长串，问有几个单词在长串中出现过。思路：AC自动机板子题，好像没什么好说的……7.HDU2896题意： 给出n个单词（病毒）和m个长串（源码）问每个长串中有哪些单词出现过以及有多少个源码中有病毒。思路： 和上个题类似，字符集不只是26个字母了……是所有ASCII可见字符，不过开到130就行，不用统计出现次数，新加一个数组记录病毒编号在字典树上的位置，查询的时候如果某个节点对应的病毒编号不为0就加入答案数组，排序之后输出，如果答案数组的大小不为0，总个数加1，最后输出总个数。"},{"id":"debugConfig","title":"VSCode C++ debug 配置","content":"task.json{\r\n  \"version\": \"2.0.0\",\r\n  \"tasks\": [\r\n    {\r\n      \"label\": \"task\",\r\n      \"type\": \"shell\",\r\n      \"command\": \"g++\",\r\n      \"args\": [\r\n        \"-g\",\r\n        \"${file}\",\r\n        \"-o\",\r\n        \"${fileDirname}/${fileBasenameNoExtension}.exe\"\r\n      ],\r\n      \"group\": {\r\n        \"kind\": \"build\",\r\n        \"isDefault\": true\r\n      }\r\n    }\r\n  ]\r\n}launch.json{\r\n  \"version\": \"0.2.0\",\r\n  \"configurations\": [\r\n    {\r\n      \"name\": \"C++ Launch\",\r\n      \"type\": \"cppdbg\",\r\n      \"request\": \"launch\",\r\n      \"program\": \"${workspaceRoot}/${fileBasenameNoExtension}.exe\",\r\n      \"stopAtEntry\": false,\r\n      \"externalConsole\": true,\r\n      \"cwd\": \"${workspaceFolder}\",\r\n      \"preLaunchTask\": \"task\",\r\n      \"windows\": {\r\n        \"MIMode\": \"gdb\",\r\n        \"miDebuggerPath\": \"replace this with your gdb path\"\r\n      }\r\n    }\r\n  ]\r\n}"},{"id":"debug_output_header","title":"使用自定义头文件在算法竞赛中辅助本地调试","content":"算法竞赛中主要有两种调试方式：调试器(debugger)和直接输出。调试器适合查看少量或者特定位置的信息，但可能比较费时间并且如果错过了某些信息就要重新运行,而且必须要吐槽gdb输出二维数组全挤在一行根本没法看；而直接输出适合跟踪大量的信息，并且可以方便的查看之前的信息，缺点就是需要在代码中添加额外的语句（可能会很多）并且要在提交之前删掉（即便是输出到标准错误流也会影响性能）。一种解决办法就是使用提前写好的代码/头文件，并结合宏和命令行define参数实现区分本地和评测环境，让调试代码在环境中失效。输出我直接用的现成的pretty printer，然后在代码中加入如下语句：#ifdef LOCAL\n#include<pprint.hpp> // https://github.com/p-ranav/pprint\npprint::PrettyPrinter _printer(std::cerr);\n#define de(...) _printer.compact(true).print('[', #__VA_ARGS__,\"] =\", __VA_ARGS__)\n#define de2(...) _printer.compact(false).print('[', #__VA_ARGS__,\"] =\", __VA_ARGS__)\n#else\n#define de(...)\n#define de2(...)\n#endif注意这样做需要把所在的目录加到环境变量里，或者编译时使用标记，或者将放到系统include目录里。如果你嫌太长的话，可以将此部分#ifdef LOCAL\n#include<pprint.hpp> // https://github.com/p-ranav/pprint\npprint::PrettyPrinter _printer(std::cerr);\n#define de(...) _printer.compact(true).print('[', #__VA_ARGS__,\"] =\", __VA_ARGS__)\n#define de2(...) _printer.compact(false).print('[', #__VA_ARGS__,\"] =\", __VA_ARGS__)\n#endif放入里，只在代码中留下#ifndef LOCAL\n#define de(...)\n#define de2(...)\n#endif编译时加上标记以定义，可以换成其他的词，只要保证oj里没有定义这个就行。"},{"id":"dfs_ordering","title":"DFS序/欧拉序的应用（持续更新）","content":"子树相关的应用由于子树的dfs序是连续的，所以很容易得到子树的信息。树上启发式合并用于删掉轻子树的信息vector<int> bch(n, -1);\nint cur_big=-1;\nauto get_big = [&](auto &dfs, int u, int p) -> int {\n    int sz = 1, mx = 0;\n    for (auto v : g[u]) {\n        if (v == p) continue;\n        int csz = dfs(dfs, v, u);\n        if (csz > mx) mx = csz, bch[u] = v;\n        sz += csz;\n    }\n    return sz;\n};\nauto add=[&](auto& slf, int u, int p, int x) -> void {\n    // update info of u here\n    for (auto v : g[u]) {\n        if (v==p || v==cur_big) continue;\n        slf(slf, v, u, x);\n    }\n};\nauto dfs = [&](auto &dfs, int u, int pa, bool keep) -> void {\n    int big = bch[u];\n    for (auto v : g[u])\n        if (v != pa && v != big)\n            dfs(dfs, v, u, 0);\n    if (big != -1) {\n        dfs(dfs, big, u, 1);\n        cur_big=big;\n    }\n    add(add, u, pa, 1);\n    // now you get all the info of subtree of u, answer queries about u here.\n    cur_big=-1;\n    if (!keep) add(add, u, pa, -1);\n};\n利用二分查询子树信息如果查询的信息是类似于子树中有多少个节点满足一定条件，比如：有多少个节点的颜色为x，此时我们可以为每个颜色开一个数组存，并且在dfs的时候将每个节点放入对应数组。由于子树的dfs序是连续的，在数组中的节点也是连续的，所以我们可以通过子树的根节点的进出时间戳，利用二分得到子树区间的长度。练习题：ABC202 E//#pragma GCC target(\"avx,avx2,fma\")\n//#pragma GCC optimize(\"unroll-loops,Ofast\")\n#include <algorithm>\n#include <bits/stdc++.h>\n\n/*{{{*/\nusing namespace std;\n#ifdef LOCAL\n#include<pprint.hpp> // https://github.com/p-ranav/pprint\npprint::PrettyPrinter P(cerr);\n#define de(...) P.compact(true);P.print(__VA_ARGS__)\n#define de_nc(...) P.compact(false);P.print(__VA_ARGS__)\n#else\n#define de(...)\n#define de_nc(...)\n#endif\n#define all(x) (x).begin(),(x).end()\nusing ll = long long;\nusing pii = pair<int, int>;\n\ninline namespace Traits {\n    // is iterable\n    template<typename T, typename = void> struct is_iterable : false_type {};\n    template<typename T>\n    struct is_iterable<T, void_t<decltype(begin(declval<T>())), decltype(end(declval<T>()))>> : true_type {};\n    template<typename T> constexpr bool is_iterable_v = is_iterable<T>::value;\n    // is readable\n    template<typename T, typename = void> struct is_readable : false_type {};\n    template<typename T>\n    struct is_readable<T, enable_if_t<is_same_v<decltype(cin >> declval<T&>()), istream&>>> : true_type {};\n    template<typename T> constexpr bool is_readable_v = is_readable<T>::value;\n    // is printable\n    template<typename T, typename = void> struct is_printable : false_type {};\n    template<typename T>\n    struct is_printable<T, enable_if_t<is_same_v<decltype(cout << declval<T>()), ostream&>>> : true_type {};\n    template<typename T> constexpr bool is_printable_v = is_printable<T>::value;\n}\ninline namespace Input {\n    template<typename T> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n    template<typename T, typename U> void re(pair<T, U>& p);\n    template<typename T> enable_if_t<is_readable_v<T>> re(T& x) { cin>>x; }\n    template<typename T> enable_if_t<needs_input_v<T>> re(T& v) { for (auto& x : v) re(x); }\n    template<typename... T> void re(T&... args) {(re(args), ...);}\n    template<typename T, typename U> void re(pair<T, U>& p) { re(p.first, p.second); };\n}\ninline namespace Output {\n    template<typename T> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n    template<int offset=0, typename... T> void wr(T... args);\n    template<int offset=0,typename T> enable_if_t<is_printable_v<T> && is_integral_v<T>> _W(const T& x) { cout<<x+offset; }\n    template<int offset=0,typename T> enable_if_t<is_printable_v<T> && !is_integral_v<T>> _W(const T& x) { cout<<x; }\n    template<int offset=0,typename T, typename U> void _W(const pair<T, U>& p) { wr<offset>(p.first, p.second); }\n    template<int offset=0,typename It> void _W(It f, const It& l) { for (;f!=l; ++f) { _W<offset>(*f); if (f!=l) cout<<' '; }}\n    template<int offset=0,typename T> enable_if_t<needs_output_v<T>> _W(const T& x) { _W<offset>(begin(x), end(x)); }\n    template<int offset, typename... T> void wr(T... args) { \n        int i=0; ((_W<offset>(args), ++i, cout<<(i==sizeof...(args) ? '\\n' : ' ')), ...);\n#ifdef LOCAL\n        cout.flush();\n#endif\n    }\n}\ntemplate<typename T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntemplate<typename T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }/*}}}*/\n\nvoid solve() {\n    int n;\n    re(n);\n    vector<vector<int>> g(n);\n    for (int i=1; i<n; i++) {\n        int p;\n        re(p);\n        g[p-1].push_back(i);\n    }\n    int timer=0;\n    vector<int> in(n), out(n), dep(n);\n    vector<vector<int>> pos(n);\n    auto dfs=[&](auto& dfs, int u) -> void {\n        in[u]=timer++;\n        pos[dep[u]].push_back(in[u]);\n        for (auto v : g[u]) {\n            dep[v]=dep[u]+1;\n            dfs(dfs, v);\n        }\n        out[u]=timer;\n    };\n    dfs(dfs, 0);\n    int q;\n    re(q);\n    while (q--) {\n        int u, d;\n        re(u, d);\n        u--;\n        auto& v=pos[d];\n        wr(lower_bound(all(v), out[u])-lower_bound(all(v), in[u]));\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt=1;\n    while (tt--) {\n        solve();\n    }\n    return 0;\n}路径相关应用如果信息是可逆的，比如说求和，我们可以结合欧拉序，第一次访问节点的时候在序列中放入正值，访问结束之后放入负值，这样不在dfs栈中的节点就会被抵消掉。总的来说，假设要求的路径是从u到v（v是u的祖先，如果不是就拆成和两条路径），那么路径和就是序列中到的和。"},{"id":"dijkExtention","title":"Dijkstra的一些扩展","content":"路径记录我们开一个用来记录某个点的前一个点，在更新距离的时候，如果当前距离更短就舍弃掉之前的记录，将当前点作为被更新点的前一个点；如果当前距离和最短距离相等就在数组里加上这个点。for(pii it:E[u]){\r\n    ll v=it.S,cost=it.F;\r\n    if(!vis[v]&&dis[v]>dis[u]+cost){\r\n        dis[v]=dis[u]+cost;\r\n        pre[v].clear();\r\n        pre[v].pb({cost,u});\r\n        q.push({dis[v],v});\r\n    }else if(dis[v]==dis[u]+cost)\r\n        pre[v].pb({cost,u});\r\n}最短路径的数量和路径记录类似，如果更短就让数目等于1,如果一样就加1。if(!vis[v]&&dis[u]+cost<dis[v]){\r\n    cnt[v]=1;\r\n    dis[v]=dis[u]+cost;\r\n}else if(dis[u]+cost==dis[v]){\r\n    cnt[v]++;\r\n}"},{"id":"dsu-on-tree","title":"树上启发式合并（DSU on Tree）总结","content":"树上启发式合并可以用  的时间（假设添加和删除节点都是 ）解决对于每个子树的统计问题（比如统计子树中有多少种颜色的节点）。算法概述对于一个节点 ，我们按以下的步骤进行遍历：先遍历  的轻（非重）儿子，并计算答案，但不保留遍历后它对统计的影响遍历它的重儿子，保留它对统计的影响再次遍历  的轻儿子的子树结点，加入这些结点的贡献，以得到  的答案模板vector<int> sz(n, 1), big(n, -1); // sz: 子树大小，big：重儿子\nauto cal_size = [&](auto& slf, int u, int p) -> void {\n    for (auto v : g[u]) {\n        if (v == p) continue;\n        slf(slf, v, u);\n        sz[u] += sz[v];\n        if (big[u] == -1 || sz[v] > sz[big[u]]) {\n            big[u] = v;\n        }\n    }\n};\ncal_size(cal_size, 0, 0);\n\nauto add = [&](auto& slf, int u, int p) -> void {\n    // 在此将 u 添加进统计结果\n    for (auto v : g[u]) {\n        if (v == p) continue;\n        slf(slf, v, u);\n    }\n};\n\nauto remove = [&](auto& slf, int u, int p) -> void {\n    // 在此将 u 从统计结果中移除\n    for (auto v : g[u]) {\n        if (v == p) continue;\n        slf(slf, v, u);\n    }\n};\n\nauto dfs = [&](auto& slf, int u, int p) -> void {\n    for (auto v : g[u]) {\n        if (v == p || v == big[u]) continue;\n        slf(slf, v, u); // 遍历轻儿子\n        remove(remove, v, u); // 移除轻儿子\n    }\n    if (big[u] != -1) {\n        slf(slf, big[u], u); // 遍历重儿子\n    }\n\n    for (auto v : g[u]) {\n        if (v == p || v == big[u]) continue;\n        add(add, v, u); // 再次添加轻儿子\n    }\n    // 在此将 u 添加进统计结果\n    // 此处的统计结果即为 u 子树的答案\n};\ndfs(dfs, 0, 0);时间复杂度证明如果一个节点为其父节点的轻儿子，那么我们称其为轻节点。所有轻节点会在清除统计时遍历一遍其子树，所以每个节点被遍历的次数为其到根节点路径上的轻节点的数量加一（加一是因为 dfs 本身会遍历一遍）。由于轻节点的子树大小至多为其父节点的的一半，所以任意节点到根节点的路径上的轻节点数量最多为 ，所以每个点被遍历的次数为 ，所以总体的时间复杂度为 。多说一嘴为什么这个算法没有任何合并操作却被叫做“启发式合并”，因为他和真正的“启发式合并”有着类似的过程：如果我们先遍历重儿子，那么合并时永远是从轻儿子合并到重儿子上，所以我们合并时就相当于遍历了一遍轻儿子的子树（类比于清除轻儿子统计），所以“启发式合并”的时间复杂度也是 。"},{"id":"easy-ssl-for-local-services","title":"让你的家庭服务器里的本地服务也用上 SSL 证书","content":"这个方法来自于 视频 ，由 Walfgang 的频道提供。这篇帖子仅为有经验的人提供对那个视频的笔记。关键点在于，你可以创建一个 DNS 记录，将其指向你的本地 IP 地址。先决条件：一个域名，一个反向代理（我在这里使用的是 Nginx Proxy Manager），用于域名的 SSL 证书。步骤 1：创建一个 A 类型的 DNS 记录，将其指向你服务器的本地 IP 地址，例如 。步骤 2：在你的反向代理中，将域名代理到你的本地服务，并可以使用你的 SSL 证书。就是这么简单！"},{"id":"file-browser","title":"File Browser (filebrowser)","content":"File Browser是一个网页端文件管理/浏览器，它很轻量但同时拥有丰富的功能。在GitHub上有1.7万的星星。为什么不用Nextcloud?Nextcloud功能很强大，但很多人只把他当作云存储用所以就显得比较臃肿。而且它的网页端用起来感觉有点慢而且播放器经常出bug。IOS端也卡卡的（可能也与我手机比较老有关），网页端在手机上更不好用。最重要的一点：文件单独存放在一个地方而且是以www-data用户管理，所以如果你要在服务器上导入、导出、下载文件的话来回切换用户很不方便。所以我就一直在找一个替代Nextcloud的方案，尝试了各种方案之后，File Browser也许是最符合我需求的。（主要痛点就是视频封面，其实File Browser也没有，但有别人的fork加上了，然后我又完善了一下并传到了docker hub上）安装version: '3'\nservices:\n  app:\n    container_name: filebrowser\n    #image: filebrowser/filebrowser\n    image: thallium54/filebrowser\n\n    restart: unless-stopped\n    user: 1000:1000\n    ports:\n    - \"8335:80\"\n    volumes:\n      - /path/to/manage:/srv\n      - /path/to/database/filebrowser.db:/database.db\n      - /path/to/cache:/cache镜像可以用我的或者官方的。volume根据你的情况修改，第一个是你要管理的目录，比如我直接把home目录挂上去了。第二个是数据库的位置，一定要自己创建这个文件，不然docker会把这个当成目录然后创建一个叫的目录。第三个是视频和图片预览的缓存目录，官方镜像没有开缓存所以如果用官方镜像的话就删掉这一行就行。如何自己构建以我自己的版本举例：（切换到有视频预览的branch)（编译可执行文件，如果你不打算用docker的话编译出来的就直接可以用了，具体用法见）（构建docker镜像）（如果在本地用的话可以不push）"},{"id":"game_theory","title":"博弈论入门学习笔记","content":"几个月前的笔记，才疏学浅，仅供参考~基本概念PN点什么是PN点P点：前一个选手（previous person)将取胜的点，即必败点。N点：下一个选手（next person)将取胜的点，即必胜点。注意：PN点是相对于某个点的属性，与先后手无关，所以我们可以说先手的P点或后手的P点，也就是说无论是先手还时后手，走到P点都是必败的。PN点的属性所有终结状态均为P点。从任何N点都至少有一种方法进入P点。（当前玩家的必胜点一定可以走到下一个玩家的必败点）从P点只能进入N点。（如果能走到P点的话就相当于胜负局势变化了，这样就不是必败的了）注意：这里说的都是走到最后状态的玩家获胜的游戏。SG函数如果游戏条件比较复杂，为了判断每个点的胜负状态，就需要引入SG函数。定义：其中v为u的后继状态，mex函数是作用于整数集合的函数，函数值是不属于该集合的最小自然数。那么，终止状态的SG值显然为0，并且SG值为0的状态就是P状态，SG值不为0的状态就是N状态。\n证明则非常显然，SG值为0的状态，说明它的所有后继状态都不为0，也就是它只能转移到非0状态，而SG值不为0的状态则不一样，后继状态一定有0，可能有其他非负整数。那么SG值为0的状态就是必败状态的定义，SG值不为0的状态就是必胜状态的定。求法从定义可以看出sg函数使用的递归定义，所以我们既可以从sg为0的状态递推，也可以采用递归的方法求。有些题目的sg函数的有规律的，通过打表或者思考可以发现规律;有些是没有规律的，需要自己写sg函数来打表。一般的sg函数打表模板：\n注：需要打表的一般是简单的取石子游戏，且在取石子的数量上有限制。这种问题的状态方便用数字表示，所以实现简单。bool flag[N];\nint sg[N];\nvoid getsg(){\n    for1(i,N){\n        ms(flag,0);\n        //枚举后继状态\n        for(int j=1;j<=K;j++){//K为能取不同个数石子的种类数\n            flag[sg[i-shizi[j]]]=1;\n        }\n        //找mex\n        forn(j,N){\n            if(flag[j]==0){\n                sg[i]=j;\n                break;\n            }\n        }\n    }\n}有规律的sg函数:HDU-1847打表可发现sg函数是0，1，2，0，1，2……变化的。稍微难一点找规律：LightOJ-1296规律：如果n是奇数gx(n)=gx(n/2),如果为偶数，gx(x)=x/2;需要打表的题：HDU-1848巴什博弈题目描述只有一堆n个石子，两个人轮流从这堆石子中取石子，规定每次至少取一个，最多取m个，最后取完的人获胜。分析当n = m+1 的时候，由于先手最多取走m个，无论其取走多少个，剩下的后手均可以一次取完，显然后手胜。根据以上分析，我们可以将n写成  的形式。对于先手玩家，我们可以取走r个，给对方造成剩下的情形。此时无论对手取走多少个，假设对手取走n个， 我们一定可以做到取走 个，此时剩下个，那么留给对方又是(m+1)的整数倍，如此就可以保证先手取胜。结论当时，先手胜，否则后手胜。威佐夫博弈题目描述有两堆各若干个石子，两个人轮流从某一堆或者两堆中取同样多的物品，规定每次至少取一个，多着不限，最后取完石子的人获胜。分析我们用 表示一种局势，先手必输的局势我们称为奇异局势，显然是一种奇异局势。那么必然是非奇异局势，因为可以通过一步到达奇异局势。我们可以发现不论如何操作都将成为非奇异局势，所以是下一个奇异局势，所以也都是非奇异局势，以此类推我们可以发现之后的几个奇异局势是。通过观察我们可以发现为前面没出现过的最小正整数，。奇异局势有以下三条性质任何正整数都包含在奇异局势中。任何操作都会将奇异局势变为非奇异局势。采取适当的操作可以将非奇异局势变为奇异局势。事实上，是一对beatty数列。Beatty数列取两个无理数使得。一对Beatty数列就是。Rayleigh定理(Beatty定理)划分正整数，也就是说每个正整数只在两个数列中出现一次。我们再回到这个问题，\n根据解得。我们可得到通项对于任意局势我们只需判断常见的几类问题给出局势判断是否是奇异局势。给出局势，判断是否先手赢，若赢，给出第一步走法。例题：HDU-2177先把所有奇异局势求出来，然后判断是不是，如果不是：先判断能否两堆同时取，设 判断如果成立就可以同时取到。判断取一堆的。先判断,如果成立就可以取到,如果不成立那么，此时，所以可以取到。Nim博弈题目描述有n堆石子，数量分别为每人每次可在任意一堆中取走任意数量（不少于1）的石子。结论Nim游戏中先手必败当且仅当时扩展事实上，我们可以将Nim游戏视做多个子游戏的合集，根据Nim定理，总游戏的sg值等于所有子游戏的sg值的异或和。证明异或有一条性质,，根据sg的定义，子游戏走一步，sg值必然发生改变，根据异或的性质所以总游戏的sg值也一定发生改变，0一定会变成非0，非0经过某一步可以变成0，所以当且仅当和游戏的sg为0时，先手必输，因为后手总可以控制sg值回到0。例题：HDU-2176"},{"id":"gcj2021_r2_matrygons","title":"Google Code Jam 2021 R2 Matrygons题解","content":"比赛的时候想错方向了:disappointed:Solution设从里向外多边形的边数为。不难发现必须是的倍\n数，因此我们可以把写成。所以\n如果我们知道最里面的多边形的边数，那么剩下的事情就是找到最长的序列 使得是的倍数并且。注意都是的倍数，所以如果我们把它们都除以就又得到\n了一个以开头的序列！也就是说我们得到了一个更小的子问题，所以我们可以用动态规\n划来解决：设为和为的上述序列的最大长度。因为我们可以把一个短的序列乘上\n一个数并在最前面放一个，从而得到一个更长的序列，所以状态转移就是：\n代码#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt = 1;\n    cin >> tt;\n    constexpr int N = 1e6;\n    vector<int> dp(N + 1, 1);\n    for (int i = 1; i <= N; i++) {\n        for (int j = 2 * i + 1; j <= N; j += i) {\n            dp[j] = max(dp[j], dp[i] + 1);\n        }\n    }\n    for (int cas = 1; cas <= tt; cas++) {\n        int x;\n        cin >> x;\n        int ans = 1;\n        cout << \"Case #\" << cas << \": \";\n        for (int f = 3; f <= x; f++) {\n            if (x % f == 0)  ans = max(ans, dp[x / f]);\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}"},{"id":"git","title":"Git小技巧","content":"正常显示中文文件名git config --global core.quotepath false用rebase合并commitsgit rebase -i HEAD~3数字为最后几个要编辑的commits然后根据情况编辑commits，如果是全部合并的话就第一行留下，其他全部改成。最后再编辑commit信息即可。如果只是合并成一个commit的话，可以直接然后再commit一次就好从index中移除文件git rm --cached removed_file"},{"id":"home-server-guide","title":"家庭服务器折腾记录","content":"简单记录自己服务器的配置过程，方便需要时查看以及但愿对你有所帮助。服务器配置整机Intel NUCCPUi7-10710U内存16G硬盘500G西数蓝盘+1TB希捷机械OSUbuntu 20.04.4 LTS通用远程访问：端口转发，DDNS...SSL证书：https://www.youtube.com/watch?v=c1t_OrIia1Uhttps://certbot.eff.org/instructions?ws=apache&os=ubuntufocal软件Nextcloud安装教程反向代理Pi-hole安装：使用官方安装脚本即可。注意：脚本有个bug，即使你已经装了其他web server（比如Apache）也要选择装lighttdp，否则重启服务的时候脚本会崩溃。。。（当你看到此的时候也许已经修复了）配置Apache以访问web UI一些黑名单：https://github.com/blocklistproject/Listshttps://anti-ad.net/domains.txtPhotoprism安装反向代理，把http中的photoprism换成localhostRSSHubdocker compose部署Minifluxdocker compose部署Navidromedocker-composeqBittorrent(-nox)在服务器由于没有xorg所以装的是nox版本[安装教程](https://github.com/qbittorrent/qBittorrent/wiki/Running-qBittorrent-without-X-server-(WebUI-only,-systemd-service-set-up,-Ubuntu-15.04-or-newer)不知道为啥用局域网也访问不到，一种解决办法是利用ssh建立通道（教程)，或者apache反向代理。"},{"id":"k-th-smallest-substring","title":"后缀自动机应用之求字典序第k小子串（包括与不包括相同子串）","content":"不包括相同子串后缀自动机中每一个路径都代表一个子串，所以第k小子串就对应第k小路径，所以我们可以先计算从每个状态开始有多少条路径，然后再根据k判断走哪条路径。计算路径的方法如下：\n包括相同子串由于标准的后缀自动机里是体现不出重复路径的信息的，所以我们要在上问的基础上维护每个状态代表的子串们出现的次数:如何理解？当前状态的子串们都是下一个状态子串们的前缀，所以下一个状态的出现次数应当加到当前状态上。特别的，如果当前状态是终止状态，它的出现次数应为1。路径数的计算与前面类似：\n例题：[TJOI2015]弦论代码：#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nint t;\nstruct SAM {\n    struct state {\n        int len = 0, link = -1;\n        unordered_map<char, int> next;\n        bool is_term;\n        ll occur = 0, path_cnt=0;\n    };\n    // the index of the equivalence class of the whole string\n    int last = 0;\n    vector<state> st;\n\n    void extend(char c) {\n        int cur = (int)st.size();\n        st.emplace_back();\n        st[cur].len = st[last].len + 1;\n\n        int p = last;\n        while (p != -1 && !st[p].next.count(c)) {\n            st[p].next[c] = cur;\n            p = st[p].link;\n        }\n        if (p == -1) st[cur].link = 0;\n        else {\n            int q = st[p].next[c];\n            if (st[p].len + 1 == st[q].len) {\n                st[cur].link = q;\n            } else {\n                int clone = (int)st.size();\n                st.push_back(st[q]);\n                st[clone].len = st[p].len + 1;\n                while (p != -1 && st[p].next[c] == q) {\n                    st[p].next[c] = clone;\n                    p = st[p].link;\n                }\n                st[q].link = st[cur].link = clone;\n            }\n        }\n        last = cur;\n    }\n\n    SAM() { st.emplace_back(); }\n\n    SAM(const string &s) : SAM() {\n        for (auto c : s)\n            extend(c);\n        int p = last;\n        while (p != 0) {\n            st[p].is_term = true;\n            p = st[p].link;\n        }\n    }\n\n    void dfs(int i) {\n        if (st[i].occur) return;\n        if (st[i].is_term) st[i].occur++;\n        for (auto [_, v] : st[i].next) {\n            dfs(v);\n            st[i].occur += st[v].occur;\n            st[i].path_cnt += st[v].path_cnt;\n        }\n        st[i].path_cnt += t ? st[i].occur : 1;\n    }\n\n    string query(ll k) {\n        string ans;\n        int cur = 0;\n        while (k > 0) {\n            for (char c = 'a'; c <= 'z'; c++) {\n                if (!st[cur].next.count(c)) continue;\n                auto &nxt = st[st[cur].next[c]];\n                if (nxt.path_cnt < k) k -= nxt.path_cnt;\n                else {\n                    ans += c;\n                    cur = st[cur].next[c];\n                    k -= t ? st[cur].occur : 1;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    int k;\n    cin >> s >> t >> k;\n    int len = (int)s.size();\n    SAM sa(s);\n    sa.dfs(0);\n    if (sa.st[0].path_cnt<k) cout<< -1 <<'\\n';\n    else cout << sa.query(k);\n    return 0;\n}"},{"id":"kattis-goldbandits","title":"NAIPC2014 F - Gold Bandits 题解","content":"很考验思维的一道题此题为North American Invitational Programming Contest (NAIPC) 2014 F题，题目链接。题意给出一张图，每个顶点有的金子，你要从顶点1沿最短路到顶点2，再沿任意路径返回。对于路径上的每个顶点，你可以选择抢劫他们的金子，但如果你抢了金子，返回的时候就不能经过这个顶点，问最多能抢多少金子。题解由于n很小，可以考虑暴力枚举每一条最短路。我们不妨换个角度思考：去的时候先把路径上的金子都抢了，回来的时候再把经过的顶点的金子还回去。这样回去的路径就可以看作是最短路：如果经过在来的路径上的点花费就是没，否则花费就是0.代码#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int i = 2; i < n; i++)\n        cin >> a[i];\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    queue<int> q;\n    q.push(0);\n    vector<int> dep(n, -1);\n    dep[0] = 0;\n    while (!q.empty()) {\n        auto u = q.front();\n        q.pop();\n        for (auto v : g[u]) {\n            if (dep[v] == -1) {\n                dep[v] = dep[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    int ans = 0;\n    vector<bool> vis(n);\n    auto dijkstra = [&]() {\n        vector<int> dis(n, -1);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> q;\n        dis[0] = 0;\n        q.emplace(0, 0);\n        while (!q.empty()) {\n            auto [d, u] = q.top();\n            q.pop();\n            if (d != dis[u]) continue;\n            for (auto v : g[u]) {\n                int nd = d + (vis[v] ? a[v] : 0);\n                if (dis[v] == -1 || nd < dis[v]) {\n                    dis[v] = nd;\n                    q.emplace(nd, v);\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i]) sum += a[i];\n        }\n        ans = max(ans, sum - dis[1]);\n    };\n    auto dfs = [&](auto &me, int u) -> void {\n        vis[u] = true;\n        for (auto v : g[u]) {\n            if (v == 1) dijkstra();\n            else if (dep[v] == dep[u] + 1 && dep[v] < dep[1])\n                me(me, v);\n        }\n        vis[u] = false;\n    };\n    dfs(dfs, 0);\n    cout << ans << '\\n';\n    return 0;\n}"},{"id":"kattis_fareysums","title":"Kattis - Farey Sums题解","content":"经过长时间思考并解决调问题的感觉太好了  ——xls题目链接网上的题解比较少而且都讲的比较跳跃，不知道是他们太聪明还是我太笨了。于是本着刨根问底的精神我详细推导了下过程。如果想麻烦了欢迎指正。首先，farey数列的分母构成的数列一定是对称的，因为如果分子与分母互质，那么分母与分子的差也一定与分母互质，这个可以用反证法证明：设分母是，分子是，如果与不互质，那么可以写成那么与也不互质，所以与要么都在数列里要么都不在数列里。其次，设当前的order是,那么当order增加到时，将会有个数被插入，这个道理很简单：如果不是互质的话就被约掉了。下面我们看一下插入的这些数对farey sums有什么影响：设插到了与之中，我看到的题解都直接给出了结论这个结论看起来很神奇（事实上还有），但我怎么也想不出来这个是怎么得到的，于是我上了维基百科得到了思路：首先要先证明与如果在order为中是相邻的两项（假设在后，写完才发现后面证明把两个弄反了，懒的改了……）那么有即，这个维基上也没给出证明，不过比较好想，依然是反证法：如果两个数之间还有其他的数，那么，如果 我们就看前面那个不等式，通分得，因为所以，但因为order为所以m不能大于，与假设矛盾。的情况与前面同理。有了这个我们就可以轻松证明当与之间有新的数插入时那么有移项得，最终得到明白了这关键的一步之后，原来farey sums中和（数列中对称的两项）就变成了，所以每插入两项，farey sums就增加3，一共插入了项，那么farey sums就增加了，又因为order从0变成1的时候只增加了1,比少了，所以最终答案应为代码#include <iostream>\r\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\r\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\r\nusing namespace std;\r\n\r\nconst int N = 10005;\r\nint phi[N], phisum[N];\r\nvoid phi_table(int n) {\r\n  phi[1] = 1;\r\n  for (int i = 2; i <= n; i++)\r\n    if (!phi[i])\r\n      for (int j = i; j <= n; j += i) {\r\n        if (!phi[j])\r\n          phi[j] = j;\r\n        phi[j] = phi[j] / i * (i - 1);\r\n      }\r\n}\r\nint main() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(0);\r\n  int n;\r\n  cin >> n;\r\n  phi_table(10000);\r\n  for1(i, 10000) phisum[i] = phisum[i - 1] + phi[i];\r\n  for1(i, n) {\r\n    int p, x;\r\n    cin >> x >> p;\r\n    cout << x << ' ' << (3 * phisum[p] - 1) << \"/2\\n\";\r\n  }\r\n  return 0;\r\n}"},{"id":"knapsack-binary-optimization","title":"二进制分组优化背包","content":"关于名字名字看不懂无所谓，我看有一篇博客这么叫感觉有点道理就也这么叫了，dls管这个叫数位背包，但那样叫就感觉有点自成一派，其实就是一种特殊的01背包。引入直接看一个例题：[HNOI2007]梦幻岛宝珠，题意就是一个容量很大的01背包问题，但能写成 的形式。这个特殊限制就开始暗示我们从二进制的角度考虑，我们要做的是将物品按分组，从大到小，每次考虑一个分组里我物品。当对分组进行dp时，设当前剩余的容量为，由于分组里物品重量都能写成的形式，所以只有容量的系数会变化，所以我们可以只用系数来代表当前剩余容量。其实最重要的限制是 ，因为任何数都能写成  的形式，只不过  很大罢了。 很小这个限制就确保了整个组里所有物品的重量之和不超过 （100来自于题目中最多有100个物品的限制）。再结合上一段中用系数表示容量的方法，这样重量的状态就从标准01背包做法的缩小到了1000！这就是本题的核心思想。接下来我们说状态转移，令为考虑完及以上的组之后，背包剩余容量为时能得到的最高价值（的上限为1000，因为再多了后面的物品也用不完）。在一个分组内dp时就是常规的01背包，重点在于从转移到：当前剩余容量 变成 ，其中代表背包总容量二进制表示的第位，现在加上是因为之前这部分容量太小了用不上，在考虑组的时候就能用上了。用代码表示一下转移的话就是dp[i - 1][j * 2 + s[i - 1]] = max(dp[i - 1][j * 2 + s[i - 1]], dp[i][j]);#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    while (cin >> n >> m) {\n        if (n == -1 && m == -1) break;\n\n        const int N = 31;\n        vector<int> s(N), weight(n), value(n);\n        vector<vector<int>> items(N);\n        vector dp(N, vector<int>(1001, -1e9));\n\n        for (int i = 0; i < N; i++) {\n            s[i] = m >> i & 1;\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> weight[i] >> value[i];\n            int b = 0;\n            while (weight[i] % 2 == 0) {\n                weight[i] /= 2;\n                b++;\n            }\n            items[b].push_back(i);\n        }\n\n        auto cmax = [](auto &x, auto y) { x = max(x, y); };\n\n        for (int i = N - 1; i >= 0; i--) {\n            cmax(dp[i][s[i]], 0);\n            for (auto item : items[i]) { // 组内dp\n                for (int j = 0; j + weight[item] <= 1000; j++) {\n                    cmax(dp[i][j], dp[i][j + weight[item]] + value[item]);\n                }\n            }\n            if (i) { // 转移到下一组\n                for (int j = 0; j <= 1000; j++) {\n                    cmax(dp[i - 1][min(j * 2 + s[i - 1], 1000)], dp[i][j]);\n                }\n            }\n        }\n        cout << *max_element(begin(dp[0]), end(dp[0])) << endl;\n    }\n}另一道题接下来看一道不是很“背包”的题CF1670F. Jee, You See?，核心思路不变。变了的地方及对应的解决方法：最大重量变成了方法数max变成+物品变成了数组中第位1的个数，可以选从0到n个相当于上面的题中的从0到各一个，遍历即可异或的限制如果当前位是，那就选个，如果是就选个#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate <int MOD>\nstruct ModInt {\n    int val;\n    ModInt(int v = 0) : val(v % MOD) { if (val < 0) val += MOD; };\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const {\n        auto a = val, m = MOD, u = 0, v = 1;\n        while (a != 0) { auto t = m / a; m -= t * a; swap(a, m); u -= t * v; swap(u, v); }\n        assert(m == 1);\n        return u;\n    }\n    ModInt pow(ll n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n    friend ModInt operator+ (ModInt lhs, const ModInt& rhs) { return lhs += rhs; }\n    friend ModInt operator- (ModInt lhs, const ModInt& rhs) { return lhs -= rhs; }\n    friend ModInt operator* (ModInt lhs, const ModInt& rhs) { return lhs *= rhs; }\n    friend ModInt operator/ (ModInt lhs, const ModInt& rhs) { return lhs /= rhs; }\n    ModInt& operator+=(const ModInt& x) { if ((val += x.val) >= MOD) val -= MOD; return *this; }\n    ModInt& operator-=(const ModInt& x) { if ((val -= x.val) < 0) val += MOD; return *this; }\n    ModInt& operator*=(const ModInt& x) { val = int64_t(val) * x.val % MOD; return *this; }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\nusing mint = ModInt<1'000'000'007>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    ll l, r, z;\n    cin >> n >> l >> r >> z;\n\n    vector<mint> choose(n + 1);\n    choose[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        choose[i] = choose[i-1] * (n - i + 1) / i;\n    }\n\n    auto solve = [&](ll r) {\n        vector<mint> dp(n + 1);\n        dp[0] = 1;\n        for (int i = 59; i >= 0; i--) {\n            int s = r >> i & 1;\n            vector<mint> ndp(n + 1);\n            for (int j = 0; j <= n; j++) {\n                int k = j * 2 + s;\n                for (int x = z >> i & 1; x <= n && x <= k; x += 2) {\n                    ndp[min(n, k - x)] += dp[j] * choose[x];\n                }\n            }\n            swap(dp, ndp);\n        }\n        return accumulate(begin(dp), end(dp), mint{});\n    };\n\n    cout << solve(r) - solve(l - 1) << endl;\n}"},{"id":"latex-pictures","title":"LaTex 插入图片","content":"包\\usepackage{graphicx}设定图片目录\\graphicspath{ {./images1/}{./images2/} }插入图片\\includegraphics{universe}参数scalewidthheightangle"},{"id":"longestPathOnDAG","title":"DAG上最长路","content":"vector<int> G[N];\nint dp[N];\n\nint get(int u){\n\tif(dp[u]) return dp[u];\n\tfor(auto it:G[u]){\n\t\tdp[u]=max(dp[u],get(it)+1);\n\t}\n\treturn dp[u];\n}"},{"id":"luatex-chinese-guide","title":"在LuaTex/LuaLaTex使用中文，附Font KaitiSC not found.解决方法","content":"如果是中文文档的话可以用ctex包：\\usepackage{ctex}\n\\setCJKmainfont{Source Han Sans SC} % 设置默认中文字体\n\\setCJKfamilyfont{songti}{FZShuSong-Z01S} % 设置默认宋体字体\n% 上面的songti也可以换成别的，默认定义了songti、heiti、fangsong\n\n\\begin{document}\n使用默认字体\n{\\heiti 使用特定字体}\n\\end{document}如果只加入少量中文的话可以直接调用中文字体：\\usepackage{fontspec}\n\\newfontfamily{\\han}{Source Han Sans SC}\n\n\\begin{document}\n{\\han 中文}\n\\end{document}附：macOS下“The font \"KaitiSC\" cannot be found.”解决方案详细情况请看原文, Monterey下执行sudo tlmgr conf texmf OSFONTDIR /System/Library/AssetsV2/com_apple_MobileAsset_Font7"},{"id":"manjaro-setup","title":"Manjaro 折腾记录","content":"随缘更新，想到啥就记啥配置触摸板一开始发现触摸板右键和左键效果是一样的，双指轻按还是中键……解决方法：编辑 Section \"InputClass\"\n    Identifier \"touchpad\"\n    MatchIsTouchpad \"on\"\n    MatchDevicePath \"/dev/input/event*\"\n    Driver \"libinput\"\n    Option \"Tapping\" \"on\"\n    Option \"ButtonMapping\" \"1 3 2\"\n    Option \"TappingButtonMap\" \"lmr\"\nEndSection映射caps+hjkl为方向键编辑clear lock\nkeycode  43 = h H Left H\nkeycode  44 = j J Down J\nkeycode  45 = k K Up K\nkeycode  46 = l L Right L\nkeycode  66 = Mode_switch Caps_Lock\nkeycode  31 = i I KP_Home I\nkeycode  32 = o O KP_End OThen update xmodmap:xmodmap ~/.Xmodmap解决挂起后失效的问题：sudo touch /usr/lib/systemd/system-sleep/xkeyboard\nsudo chmod 755 /usr/lib/systemd/system-sleep/xkeyboard编辑#!/bin/bash\n\ncase $1 in\n    pre)\n        exit 0\n    ;;\n    post)\n        export DISPLAY=:0\n        sleep 10\n        xmodmap /home/thallium/.Xmodmap\n    ;;\nesac主题arcsudo pacman -S arc-gtk-theme软件vim配置待更新fcitx码表待更新Autojump快速跳转文件夹，再也不用长长的cd了～安装yay autojumpSource the correct autojump fileecho \"/usr/share/autojump/autojump.bash\" >> ~/.bashrc\nchmod 755 /usr/share/autojump/autojump.bash\nsource ~/.bashrc注意事项快速跳转的文件夹需要正常访问一次。截图: Deepin screenshot一开始用的是火焰截图，但是不能自动识别窗口，后来偶然发现deepin screenshot感觉挺不错的。sudo pacman -S deepin-screenshot如果不能正常复制到剪贴板，安装词典Wudao dict安装：git clone https://github.com/chestnutheng/wudao-dict\ncd ./wudao-dict/wudao-dict\nsudo bash setup.sh问题解决修改导致循环登录2020.03.27一般的解决方法是从命令行登录然后恢复之前的修改，但我从命令行也是循环登录……于是想到能不能从windows修改然后发现有个软件叫linux file system for windows，然后问题就解决了。真的太不容易了，心态差点崩了……Gnome-shell内存泄漏问题gnome传统艺能，再输入可以重新启动shell。让gvim默认在新标签中启动编辑把Exec=gvim -f %F改成Exec=gvim -p --remote-tab-silent %Fi3wm下运行QQ/TIM/Wechat2020-04-13原作者nohup /usr/lib/gsd-xsettings > /dev/null 2>&1 &\ncd /opt/deepinwine/apps/Deepin-TIM\n./run.sh最后将第一步添加到i3启动项里。"},{"id":"math_model","title":"一些数学模型","content":"总结一些常见的数学模型。将直线上多个点移动到一个点的最小距离移动到最中间的那个点距离最小，或者说是移动到一点使得两侧的点一样多。将直线上多个点移动到连续的位置假设起点为, 也就是说最小化, 于是问题又转化成了将坐标为的点移动到一点的问题，取中间的坐标即可。Chicken McNugget Theorem假设互质，最大的不能被表示为的数是.source最小化一点到其他点距离的平方的和由于，而x和y可以独立改变，所以可以分别最小化两个坐标轴的距离，也就是坐标的平均数。"},{"id":"minimum_path_cover","title":"树和DAG的最小路径覆盖问题","content":"路径覆盖是一个路径的集合使得每个顶点都只被一条路径覆盖。最小路径覆盖问题要求集合中路径的条数是最小的。树的最小路径覆盖做法1：DP代表当u不为路径的端点的时候，u 的子树里最少的路径的数目，代表当u为路径的端点的时候，u 的子树里最少的路径的数目。设为u的儿子，状态转移时u不为端点的情况可以是之前u不为端点的情况加上v不为端点的情况，即:也可以是以u为端点的路与以v为端点 的路连成一条路，即:u为端点的情况类似，可以是之前u为端点的情况加上v不为端点的情况，即：也可以是前面所有儿子的不以儿子为端点的路径加上以v为端点的路径,即：综上所述：如果要记录方案的话只先在dp的过程中记录经过u的路径往下走的儿子，然后再跑一遍dfs构建路径。代码：vector dp(n, vector<int>(2));\nvector nxt(n, vector(2, pair{-1, -1}));\n\nauto dfs=[&](auto& dfs, int u, int p) -> void {\n    dp[u][0]=dp[u][1]=1;\n    int sum=0;\n    for (auto v : g[u]) {\n        if (v==p) continue;\n        dfs(dfs, v, u);\n        if (dp[u][0]+dp[v][0] > dp[u][1]+dp[v][1]-1) {\n            nxt[u][0]={nxt[u][1].first, v};\n        }\n        dp[u][0]=min(dp[u][0]+dp[v][0], dp[u][1]+dp[v][1]-1);\n        if (dp[u][1]+dp[v][0] > sum+dp[v][1]) {\n            nxt[u][1]={v, v};\n        }\n        dp[u][1]=min(dp[u][1]+dp[v][0], sum+dp[v][1]);\n        sum+=dp[v][0];\n    }\n};\n\nvector<vector<int>> end_point(n); //路径的端点\nvector<pii> remove; // 不在路径覆盖中的路径\nint tot{};\nauto dfs2=[&](auto& dfs2, int u, int p, int flag, int id) -> void { // id 为当前路径的编号\n    for (auto v : g[u]) {\n        if (v==p) continue;\n        if (v==nxt[u][flag].first || v==nxt[u][flag].second) {\n            dfs2(dfs2, v, u, 1, id);\n        } else {\n            remove.emplace_back(u, v);\n            tot++;\n            int nflag=dp[v][0]<dp[v][1] ? 0 : 1;\n            if (nflag) end_point[tot].push_back(v);\n            dfs2(dfs2, v, u, nflag, tot);\n        }\n    }\n    if (nxt[u][flag]==pair{-1, -1}) end_point[id].push_back(u);\n};做法2：贪心贪心做法更加简单，只用一个dfs就能实现。如果u有两个儿子是路径的端点那么就连接那两条路，否则就将u做为端点。代码：vector<pii> end_points, remove;\nauto dfs=[&](auto& dfs, int u, int p) -> int { // 返回-1代表u不是端点，否则返回以u为端点的路径的另一端。\n    vector<int> next;\n    for (auto v : g[u]) {\n        if (v==p) continue;\n        int end_v=dfs(dfs, v, u);\n        if (end_v>=0) {\n            if (next.size() <= 1) {\n                next.push_back(end_v);\n            } else {\n                remove.emplace_back(u, v);\n                end_points.emplace_back(end_v, v);\n            }\n        } else {\n            remove.emplace_back(u, v);\n        }\n    }\n\n    if (next.empty()) next.push_back(u);\n    if (next.size()==1) {\n        if (p!=-1) return next[0];\n        end_points.emplace_back(next[0], u);\n        return -1;\n    } else {\n        end_points.emplace_back(next[0], next[1]);\n        return -1;\n    }\n};练习题CF1521D - Nastia Plays with a TreeDAG的最小路径覆盖我们把原图上的每个点拆成两个点（对于点，可以把从它拆出去的点记为），其中一个点与源点相连，另一个与汇点相连。对于原DAG上的边，在新图中连接 ，所有边的容量均为1。跑一遍最大流（本质上是二分图匹配），得到的最大流（或者最大匹配）便是被覆盖的边数，由于路径上的点数等于边数+1，所以点数减被覆盖的边数便是路径的数目。也可以理解为最大流经过的每一条边对应原图中有一条向边的起点，所以路径的终点是没有对应的边的，所以点数减被覆盖的边数便是终点的数目也就是路径的数目。如何记录路径？可以在增广途中记录每个点的下一个点。如何找起点？如果到汇点的剩余容量为1，说明没有点流向，也就说明是起点。模板题：洛谷P2764 最小路径覆盖问题代码：#include <bits/stdc++.h>\nusing namespace std;\nstruct Flow {\n    static constexpr int INF = 1e9;\n    int n;\n    struct Edge {\n        int to, cap;\n        Edge(int to, int cap) : to(to), cap(cap) {}\n    };\n    std::vector<Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h, nxt; \n\n    Flow(int n) : n(n), g(n), nxt(n) {}\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t) return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t) return f;\n        int r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i) {\n            int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (a) nxt[u] = v; // 增广成功便记录路径\n                if (r == 0) return f;\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, int c) {\n        g[u].push_back((int)e.size());\n        e.emplace_back(v, c);\n        g[v].push_back((int)e.size());\n        e.emplace_back(u, 0);\n    }\n    void maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        n = (n - 2) / 2;\n        for (int i = n + 1; i <= 2 * n; i++) {\n            if (e[g[i].back()].cap == 1) {\n                int u = i - n;\n                while (u > 0) {\n                    cout << u << ' ';\n                    u = nxt[u] - n;\n                }\n                cout << '\\n';\n            }\n        }\n        cout << n - ans << '\\n';\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    Flow g(2 * n + 2);\n    while (m--) {\n        int u, v;\n        cin >> u >> v;\n        g.addEdge(u, v + n, 1);\n    }\n    for (int i = 1; i <= n; i++) {\n        g.addEdge(0, i, 1);\n        g.addEdge(i + n, 2 * n + 1, 1);\n    }\n    g.maxFlow(0, 2 * n + 1);\n    return 0;\n}参考资料https://zhuanlan.zhihu.com/p/125759333"},{"id":"monotonic_stack","title":"单调栈常见模型","content":"总结一下加深印象左边第一个比当前小严格单调递增栈，如果求的是数字栈内就存数字，如果求距离栈内就存数字+下标或者数字+到栈内前一个元素的距离。举例 空栈，说明2之前没有比2小的元素，然后2入栈 为了保持单调递增，需要把2弹出，变成空栈，说明1前面也没有比1小的，然后1入栈 6比1大，直接入栈，先把比4大的元素弹出,然后入栈 5直接入栈 求距离： ->  ->  ->  ->  -> 代码求元素：stack<int> stk\nvector<int> ans(n);\nfor(int i=0;i<n;i++){\n    while(!stk.empty()&&stk.top()>=a[i]) stk.pop();\n    ans[i]=stk.top();\n    stk.push(a[i]);\n}求距离:stack<pair<int,int>> stk;\nvector<int> ans(n);\nfor(int i=0;i<n;i++){\n    int res=1;\n    while(!stk.empty()&&stk.top().first>=a[i]){\n        res+=stk.top().second;\n        stk.pop();\n    }\n    ans[i]=res;\n    stk.push({a[i],res});\n}左边第一个大，第一个大于等于，第一个小于等于严格单调递减栈，非严格递减栈，非严格递增右边第一个大等等从右往左处理即可"},{"id":"multi-pattern-matching","title":"多模式串匹配的3种方法","content":"例题： Another Substring Query Problem由于次题中模式串有重复，会影响时间复杂度，所以我们要提前处理相同的字符串。下面的方法均假设无重复模式串。并以为模式串的总长度，为文本串的长度。方法一：字符串哈希由于总长为的模式串最多只有种长度，所以我们可以遍历每种长度然后遍历每个位置然后判断从开始长度为的子串是否是模式串。时间复杂度为。#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nstruct PolyHash {\n    static constexpr int mod = (int)1e9 + 123;\n    static vector<int> pow;\n    static constexpr int base = 233;\n\n    vector<int> pref;\n    PolyHash(const string &s) : pref(s.size() + 1) {\n        assert(base < mod);\n        int n = (int)s.size();\n        while ((int)pow.size() <= n) {\n            pow.push_back((ll)pow.back() * base % mod);\n        }\n        for (int i = 0; i < n; i++) {\n            pref[i + 1] = ((ll)pref[i] * base + s[i]) % mod;\n        }\n    }\n\n    int get_hash() { return pref.back(); }\n\n    int substr(int pos, int len) {\n        return (pref[pos + len] - (ll)pref[pos] * pow[len] % mod + mod) % mod;\n    }\n};\nvector<int> PolyHash::pow{1};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin >> s;\n    int len = (int)s.size();\n    PolyHash ha(s);\n    int q;\n    cin >> q;\n    vector<string> qstr(q);\n    vector<int> qk(q);\n    vector<vector<int>> lens(len + 1);\n    vector<int> ans(q);\n    for (int i = 0; i < q; i++) {\n        cin >> qstr[i] >> qk[i];\n        if ((int)qstr[i].size() <= len)\n            lens[qstr[i].size()].push_back(i);\n        else\n            ans[i] = -1;\n    }\n    for (int l = 1; l <= len; l++) {\n        if (lens[l].empty()) continue;\n        unordered_map<int, vector<int>> mp, poss;\n        for (auto i : lens[l]) {\n            mp[PolyHash(qstr[i]).get_hash()].push_back(i);\n        }\n        for (int p = 0; p + l <= len; p++) {\n            if (mp.count(ha.substr(p, l))) {\n                poss[ha.substr(p, l)].push_back(p);\n            }\n        }\n        for (auto &[h, v] : mp) {\n            auto &pos = poss[h];\n            for (auto i : v) {\n                if (pos.size() >= qk[i]) ans[i] = pos[qk[i] - 1] + 1;\n                else\n                    ans[i] = -1;\n            }\n        }\n    }\n    for (auto x : ans)\n        cout << x << '\\n';\n}方法二：AC自动机先将所有模式串加入AC自动机，然后再匹配文本串。注意AC自动机中要维护output link（沿fail link跳转时第一个模式串）。时间复杂度。#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct AhoCorasick {\n    enum { alpha = 26, first = 'a' }; // change this!\n    struct Node {\n        // (nmatches is optional)\n        int back, end = -1, nmatches = 0, output = -1;\n        array<int, alpha> next;\n        Node(int v = -1) { fill(next.begin(), next.end(), v); }\n    };\n    vector<Node> N;\n\n    AhoCorasick() : N(1) {}\n\n    void insert(string &s, int j) { // j: id of string s\n        assert(!s.empty());\n        int n = 0;\n        for (char c : s) {\n            int &m = N[n].next[c - first];\n            if (m == -1) {\n                n = m = (int)N.size();\n                N.emplace_back();\n            } else\n                n = m;\n        }\n        N[n].end = j;\n        N[n].nmatches++;\n    }\n\n    void build() {\n        N[0].back = (int)N.size();\n        N.emplace_back(0);\n\n        queue<int> q;\n        q.push(0);\n        while (!q.empty()) {\n            int n = q.front();\n            q.pop();\n            for (int i = 0; i < alpha; i++) {\n                int pnx = N[N[n].back].next[i];\n                auto &nxt = N[N[n].next[i]];\n                if (N[n].next[i] == -1) N[n].next[i] = pnx;\n                else {\n                    nxt.back = pnx;\n                    nxt.output = N[pnx].end == -1 ? N[pnx].output : pnx;\n                    q.push(N[n].next[i]);\n                }\n            }\n        }\n    }\n\n    vector<vector<int>> find(const string &text) {\n        int n = 0;\n        vector<vector<int>> res(text.size()); // ll count = 0;\n        for (int i = 0; i < (int)text.size(); i++) {\n            n = N[n].next[text[i] - first];\n            if (N[n].end != -1) {\n                res[i].push_back(N[n].end);\n            }\n            for (int ind = N[n].output; ind != -1; ind = N[ind].output) {\n                res[i].push_back(N[ind].end);\n            }\n        }\n        return res;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin >> s;\n    AhoCorasick ac;\n    int q;\n    cin >> q;\n    unordered_map<string, int> mp;\n    vector<string> qstr(q);\n    vector<int> qk(q), ans(q);\n    vector<vector<int>> same(q);\n    for (int i = 0; i < q; i++) {\n        cin >> qstr[i] >> qk[i];\n        if (!mp.count(qstr[i])) {\n            mp[qstr[i]] = mp.size();\n            ac.insert(qstr[i], mp.size() - 1);\n        }\n        same[mp[qstr[i]]].push_back(i);\n    }\n    ac.build();\n    auto v = ac.find(s);\n    vector<vector<int>> pos(mp.size());\n    for (int i = 0; i < (int)v.size(); i++) {\n        for (auto p : v[i]) {\n            pos[p].push_back(i);\n        }\n    }\n    for (int i = 0; i < (int)mp.size(); i++) {\n        for (auto qi : same[i]) {\n            if (pos[i].size() >= qk[qi]) {\n                ans[qi] = pos[i][qk[qi] - 1] - qstr[qi].size() + 2;\n            } else {\n                ans[qi] = -1;\n            }\n        }\n    }\n    for (auto x : ans)\n        cout << x << '\\n';\n}方法三：后缀数据结构后缀数据结构也能是很擅长字符串匹配的，后缀树和后缀自动机都可以解决本题，由于没学过后缀树就只写后缀自动机的做法了：英文原文中文翻译注意后缀自动机是这三种做法中唯一可以在线处理询问的做法，处理单次询问的时间复杂度为，occurrence为出现次数。整体时间复杂度。#include <bits/extc++.h>\nusing namespace std;\n\nstruct SAM {\n    struct state {\n        int len = 0, link = -1;\n        unordered_map<char, int> next;\n        bool is_clone;\n        int first_pos;\n        vector<int> inv_link;\n    };\n\n    int last = 0; // the index of the equivalence class of\n                  // the whole string\n    vector<state> st;\n\n    void extend(char c) {\n        int cur = (int)st.size();\n        st.emplace_back();\n        st[cur].len = st[last].len + 1;\n        st[cur].first_pos = st[cur].len - 1;\n\n        int p = last;\n        while (p != -1 && !st[p].next.count(c)) {\n            st[p].next[c] = cur;\n            p = st[p].link;\n        }\n        if (p == -1) st[cur].link = 0;\n        else {\n            int q = st[p].next[c];\n            if (st[p].len + 1 == st[q].len) {\n                st[cur].link = q;\n            } else {\n                int clone = (int)st.size();\n                st.push_back(st[q]);\n                st[clone].len = st[p].len + 1;\n                st[clone].is_clone = true;\n                while (p != -1 && st[p].next[c] == q) {\n                    st[p].next[c] = clone;\n                    p = st[p].link;\n                }\n                st[q].link = st[cur].link = clone;\n            }\n        }\n        last = cur;\n    }\n\n    SAM() { st.emplace_back(); }\n\n    SAM(const string &s) : SAM() {\n        for (auto c : s)\n            extend(c);\n        for (int v = 1; v < (int)st.size(); v++) {\n            st[st[v].link].inv_link.push_back(v);\n        }\n    }\n    vector<int> get_all_occur(const string &s) {\n        vector<int> pos;\n        int cur = 0;\n        for (auto c : s) {\n            if (!st[cur].next.count(c)) return pos;\n            cur = st[cur].next[c];\n        }\n        auto dfs = [&](auto &slf, int v) -> void {\n            if (!st[v].is_clone)\n                pos.push_back(st[v].first_pos - s.size() + 1);\n            for (int u : st[v].inv_link)\n                slf(slf, u);\n        };\n        dfs(dfs, cur);\n        return pos;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin >> s;\n    SAM sam(s);\n    int q;\n    cin >> q;\n    unordered_map<string, vector<int>> mp;\n    vector<string> qstr(q);\n    vector<int> qk(q), ans(q);\n    for (int i = 0; i < q; i++) {\n        cin >> qstr[i] >> qk[i];\n        mp[qstr[i]].push_back(i);\n    }\n    for (auto &[str, idxs] : mp) {\n        auto pos = sam.get_all_occur(str);\n        sort(pos.begin(), pos.end());\n        for (auto i : idxs) {\n            if (pos.size() >= qk[i]) ans[i] = pos[qk[i] - 1] + 1;\n            else\n                ans[i] = -1;\n        }\n    }\n    for (auto x : ans)\n        cout << x << '\\n';\n    return 0;\n}总结三种做法各有各的优缺点，就本题来看三种做法的时间复杂度相同，时间如下：AC自动机 2.55秒 （但我有一种很愚蠢的写法竟然只要1.32秒）哈希 3.41秒后缀自动机 4.83秒 (可能因为后缀自动机本身常数比较大)"},{"id":"nginx-proxy-manager","title":"Nginx Proxy Manager","content":"Nginx Proxy Manager(以下简称NPM)可以实现反向代理（reverse proxy），即只暴露80和443端口然后由代理根据域名将请求发送给对应的服务。NPM集成了Let's Encrypt所以可以很简单的申请到SSL证书。安装使用dock-compose，根据情况修改路径（尤其是如果你用portainer的话）version: '3'\nservices:\n  app:\n    image: 'jc21/nginx-proxy-manager:latest'\n    restart: unless-stopped\n    ports:\n      - '80:80'\n      - '81:81'\n      - '443:443'\n    volumes:\n      - ./data:/data\n      - ./letsencrypt:/etc/letsencryptWeb UI在81端口，初始账号邮箱：admin@example.com 密码：changeme申请通配符SSL证书SSL Certificates -> Add SSL Certificate -> Let's EncryptDomain names:  (换成你的域名）打开Use a DNS Challenge，选择你的提供商，Credentials File Content的填写可以参照申请通配SSL证书。添加配置Hosts -> Proxy Hosts -> Add Proxy HostDomain Names没什么好说的。Forward Hostname / IP 填服务器的内网IP，不要填127.0.0.1因为会访问到NPM容器内网络Forward Port：对应应用的端口，如果有防火墙请确保端口是打开的，如果不想动防火墙设置请看Tips建议打开Cache Assets和Block Common ExploitsSSL证书里选前面申请到的证书打开Force SSL, HTTP/2 Support, HSTS Enabled。Tips利用docker网络在docker-compose文件最后加上networks:\n  default:\n    external:\n      name: nginx-proxy-manager_default让应用加入NPM的网络，这样就相当于让NPM和容器处于同一个docker网络，于是就避免了前面所说的防火墙的问题。这样的话添加配置时host要填应用的名字（不是很确定，也可能是sevice的名字，不过一般情况两个名字是一样的，比如nextcloud)，端口要填内部端口，比如一个应用的端口映射是90:8080那么你应该填8080.参考资料https://nginxproxymanager.com/"},{"id":"nowcoder-Agnej","title":"2023牛客多校10 D - Agnej 题解","content":"考虑每一层的 SG 函数，最终结果由每一层的 SG 函数的异或和决定。如果  为偶数，设左右各有  个积木，显然 。如果  为奇数，设最中间的位置左右各有  个积木，SG 函数记作 ：如果最中间没有积木：等价于  为偶数的情况否则，如果  或 ，只能从一边取，否则，如果  或 ，不妨记作 ，我们可以到达  三种状态。注意到  和  的 SG 函数必然一个为  一个为 。但  的 SG 函数不容易看出规律，我们观察一下  比较小的情况：，可以发现 否则，观察到 ，通过数学归纳法可以推出 #include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        int mid = 0, l = 0, r = 0;\n        if (m % 2) {\n            mid = s[m / 2] - '0';\n        }\n\n        for (int j = 0; j < m / 2; j++) {\n            l += s[j] - '0';\n        }\n\n        for (int j = (m + 1) / 2; j < m; j++) {\n            r += s[j] - '0';\n        }\n\n        int sg = 0;\n        if (mid == 0) {\n            sg = (l + r) % 2;\n        } else {\n            if (l == 0 || r == 0) {\n                sg = (l + r) % 2;\n            } else if (l == 1 || r == 1) {\n                sg = 2 + (l + r) % 2;\n            } else {\n                sg = (l + r + 1) % 2;\n            }\n        }\n\n        ans ^= sg;\n    }\n\n    cout << (ans ? \"Alice\" : \"Bob\") << endl;\n    return 0;\n}"},{"id":"nvim-plugins-for-no-lsp","title":"方便无 Language Server 开发的 Neovim 插件","content":"最近实习工作开始写C/C++了，由于项目结构过于复杂导致 VSCode 的 language server 几乎是不可用的状态，所以心想不如换回最顺手的 neovim，但从来没有用 neovim 做过大项目，所以要研究如何实现我在 VSCode 里常用的一些功能：搜索这里用的是 nvim-spectre，用起来和 VSCode 差不多，默认搜索用的是ripgrep所以速度很快，目前在用的快捷键：local map = vim.keymap.set -- 之后不再重复\n\nmap('n', '<leader>S', require('spectre').open)\nmap('n', '<leader>fw', function() require('spectre').open_visual({select_word=true}) end) -- 查找函数定义或引用很有用文件相关VSCode 里(Windows)/(MacOS) 可以呼出文件跳转，在 Neovim 里可以用 telescope 的 find_files picker 实现，唯一美中不足就是不会优先显示最近打开的文件且没有缓存所以加载会稍慢一点点。map('n', '<Leader>ff', require\"telescope.builtin\".find_files)常用文件跳转可以用harpoonmap('n', '<Leader>fm', require(\"harpoon.ui\").toggle_quick_menu)\nmap('n', '<Leader>ma', require(\"harpoon.mark\").add_file)大纲/Symbol之前用的 symbols-outline.nvim 但可惜不支持 treesitter，然后发现了更好用的 aerial：不仅支持 treesitter 还有lualine扩展（显示当前函数），telescope picker（比telescope自带的symbol picker）好用。require('telescope').load_extension('aerial')\n\nmap('n', '<Leader>s', require'telescope'.extensions.aerial.aerial)终端用nvim-toggleterm.lua管理终端，一个很好用的功能是自定义终端，比如定义一个默认打开lazygit的终端：local Terminal  = require('toggleterm.terminal').Terminal\nlocal lazygit = Terminal:new({\n    cmd = \"lazygit\",\n    hidden = true,\n    direction = 'float',\n    float_opts = {\n        border = 'double'\n    }\n})\nmap('n', '<Leader>g', function() lazygit:toggle() end)"},{"id":"palindrome-partition","title":"一个关于将字符串划分为符合条件的回文子串的结论","content":"如果遇到了关于将字符串划分为符合条件的回文（比如长度为偶数的回文）子串，有可能会用到这个定理：如果字符串可以被划分的话，它的最大划分是唯一的，并且可以通过从左往右贪心地选择最短的回文子串来得到最大划分。这里的“最大”指划分为回文子串的个数。第一次接触到这个结论是在 Codeforces 1827C 的题解中，后面会附上题解里证明的翻译。最近又在23年牛客多校第二场的G题遇到了这个结论。后面会简单地讨论这两个题。证明假设字符串  当前有一个划分的第一部分是 ， 是最短的前缀回文子串。我们要证明如果 ，我们可以构造出子串数量更多的划分。考虑两种情况：：很明显  都是回文子串，我们可以将  替换成它们。： 是回文子串（因为关于重心对称），其在  中的对称部分为 ，所以  也是回文子串，与我们的假设矛盾，所以不会出现这种情况。如何运用对于 Codeforces 的那个题，我们对于每个位置找到最短在此结束的回文子串，然后进行状态转移。对于牛客那个题（以及一般的判断能否划分的问题），我们维护最长的可以被划分的前缀，如果以当前位置为中心的回文子串可以扩展该前缀，我们就扩展该前缀。这本质就是贪心地选择最短的回文子串。"},{"id":"paperless-ngx","title":"Paperless-ngx","content":"使用linuxserver.io的镜像感觉比官方镜像做的好一些，因为用官方的镜像一直报错。。。GitHub仓库我修改后的docker-compose文件：---\nversion: \"2.1\"\nservices:\n  paperless-ngx:\n    image: lscr.io/linuxserver/paperless-ngx\n    container_name: paperless-ngx\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - TZ=America/Toronto\n      - REDIS_URL= #optional\n      - PAPERLESS_URL= #如果你要通过互联网访问的话，设置这个环境变量为你的URL\n      - PAPERLESS_OCR_LANGUAGES=chi-sim # 貌似没作用\n      - PAPERLESS_OCR_LANGUAGE=eng+chi_sim\n\n    volumes:\n      - config:/config\n      - data:/data\n    ports:\n      - 8010:8000\n    restart: unless-stopped\nvolumes:\n  data:\n  config:\nnetworks:\n  default:\n    external:\n      name: nginx-proxy-manager_default默认用户名和密码都是。已知bug官方镜像缺导致文件上传后无法被处理，目前GitHub上的已经修复但镜像还没更新，可以自己本地构建。环境变量似乎没用，并不会自动安装对应的ocr包，需要自己添加到中，然后自己构建。使用官方镜像官方docker-compose文件创建默认超级用户:上面的docker-compose文件里有但我还是要写一下提醒自己。打开容器列表，选择paperless_webserver_1点'Console'然后'Connect'来打开命令行运行以创建用户"},{"id":"parallel_bsearch","title":"整体二分学习笔记","content":"整体二分在国外称为 parallel binary search，是一种用于解决多个二分搜索的离线算法，其核心思想是将一个状态用于多个询问中。适用的问题/核心思想一般的二分套路为：二分一个“指标”，对于当前要检查的指标，应用所有符合指标的操作，每个操作会产生一些贡献，最后判断贡献是否符合条件。如果我们要处理很多个二分问题而且应用操作的时间开销很大，每一个二分问题单独计算就会很慢。但经常应用完操作后的状态可以用于多个二分问题的条件检查，这就是整体二分的核心思想。思路对于如何重复利用操作之后的状态，一般有两种思路：一种最常见的思路是根据当前二分的指标从小到大进行检查，这样可以在之前操作之后状态上继续应用新的操作然后再进行检查。如果因为一些因素使得无法应用第一种思路，但操作的贡献满足可加性的话，那么我们可以考虑第二种思路：记录下当前的状态的贡献，这样下一轮二分的时候我们可以在记录下的贡献上加上新的贡献。这样说可能有点抽象，下面我们结合一个例子来说明具体的实现是怎样的。例题静态数组区间第k小题目链接这个题二分的指标就是第 k 大的大小，即我们要检查：这个区间  的第 k 大是否至少为 ，这可以通过判断  内小于等于  的元素的个数来实现。我们可以用一个权值数组  记录所有所有小于等于  的位置，即 ，那么符合指标的操作就是将权值数组中的某个位置加一。显然对于大的指标我们可以在小指标操作的基础上加入新的操作，所以我们可以应用第一种思路。对于第一种思路，一种比较简单的写法是用两个数组  记录当前每个询问的答案所处的范围，在每一轮二分中根据  从小到大遍历每个询问// 树状数组代码省略已省略，见 https://github.com/thallium/acm-algorithm-template/blob/master/src/data_structure/fenwick.hpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> a(n);\n    for (auto &x : a)\n        cin >> x;\n\n    vector<int> compress{a};\n    sort(begin(compress), end(compress));\n    compress.erase(unique(begin(compress), end(compress)), end(compress));\n    const int N = (int)size(compress);\n\n    vector<vector<int>> pos(N);\n    for (int i = 0; i < n; i++) {\n        int idx = int(lower_bound(begin(compress), end(compress), a[i]) - begin(compress));\n        pos[idx].push_back(i);\n    }\n\n    vector<array<int, 3>> query(m);\n    for (auto &[l, r, k] : query) {\n        cin >> l >> r >> k;\n        l--;\n    }\n\n    vector<int> l(m, 0), r(m, N - 1);\n    while (true) {\n        vector<vector<int>> s(N);\n        int empty = 1;\n        for (int i = 0; i < m; i++) {\n            if (l[i] <= r[i]) {\n                int mid = (l[i] + r[i]) / 2;\n                s[mid].push_back(i);\n                empty = 0;\n            }\n        }\n\n        if (empty) {\n            break;\n        }\n\n        Fenwick<int> tr(n);\n        for (int i = 0; i < N; i++) {\n            for (auto j : pos[i]) {\n                tr.add(j, 1);\n            }\n\n            for (auto j : s[i]) {\n                auto [ql, qr, k] = query[j];\n                if (tr.get(ql, qr) >= k) {\n                    r[j] = i - 1;\n                } else {\n                    l[j] = i + 1;\n                }\n            }\n        }\n    }\n\n    for (auto i : l) {\n        cout << compress[i] << '\\n';\n    }\n    return 0;\n}我们再次也将介绍第二种思路的写法，这样有助于理解下面动态区间第 k 小的做法。假设一个询问的答案在  中，指标为 ，询问的区间中有  个小于等于  的数， 即为当前所有操作的总贡献，如果 ，说明答案在  中。如果我们记录下当前的贡献，下次二分的指标为 ，我们只要知道询问的区间里大小在  中的元素的个数，再加上之前记录的贡献，这样就相当于知道了小于等于  的元素的个数。所以说在下一轮二分的时候我们只需要影响  中的元素个数的操作， 的情况类似。所以我们每次二分之后要将操作分成左右两组给下一轮二分用。#include <bits/stdc++.h>\n#include \"data_structure/fenwick.hpp\"\nusing namespace std;\n\nstruct modify {\n    int val, pos;\n};\n\nstruct query {\n    int l, r, k, i;\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> a(n);\n    for (auto &x : a)\n        cin >> x;\n\n    // 离散化\n    vector<int> compress{a};\n    sort(begin(compress), end(compress));\n    compress.erase(unique(begin(compress), end(compress)), end(compress));\n    const int N = (int)size(compress);\n\n    using op = variant<modify, query>;\n    vector<op> ops; // 为了方便实现我们把询问和修改放到一起\n\n    for (int i = 0; i < n; i++) {\n        int val = int(lower_bound(begin(compress), end(compress), a[i]) - begin(compress));\n        ops.push_back(modify{val, i});\n    }\n\n    for (int i = 0; i < m; i++) {\n        int l, r, k;\n        cin >> l >> r >> k;\n        l--;\n        ops.push_back(query{l, r, k, i});\n    }\n\n    vector<int> ans(m);\n\n    Fenwick<int> tr(n);\n    auto solve = [&](auto& slf, int l, int r, vector<op>& ops) -> void {\n        if (l == r) { // 二分结束，答案确定\n            for (const auto& o : ops) {\n                if (holds_alternative<query>(o)) { // 如果是询问的话\n                    ans[get<query>(o).i] = compress[l];\n                }\n            }\n            return;\n        }\n\n        int x = (l + r) / 2;\n\n        vector<op> left, right;\n        for (auto o : ops) {\n            if (holds_alternative<query>(o)) { // 询问\n                auto& [ql, qr, k, i] = get<query>(o);\n                int c = tr.get(ql, qr); // 贡献\n                if (c >= k) { // 根据贡献判断询问的答案该如何改变\n                    left.push_back(o);\n                } else {\n                    k -= c; // 在目标上减掉贡献和记录贡献是一样的\n                    right.push_back(o);\n                }\n            } else { // 修改\n                auto [val, pos] = get<modify>(o);\n                if (val <= x) {\n                    tr.add(pos, 1);\n                    left.push_back(o);\n                } else {\n                    right.push_back(o);\n                }\n            }\n        }\n\n        for (auto o : left) {\n            if (holds_alternative<modify>(o)) { // 还原树状数组到初始状态\n                tr.add(get<modify>(o).pos, -1);\n            }\n        }\n\n        vector<op>{}.swap(ops); // 释放空间\n\n        slf(slf, l, x, left);\n        slf(slf, x + 1, r, right);\n    };\n\n    solve(solve, 0, N - 1, ops);\n\n    for (auto x : ans) cout << x << '\\n';\n    return 0;\n}可以看出第一种思路的实现往往比较好写，其实大部分整体二分的题目都是用第一种思路解决的。动态区间第k小题目链接因为询问和修改有先后顺序，所以不能用第一种思路。其实如果你理解了上一题的第二种思路的话，修改无非就是把原来的数删掉（在辅助数组中减1），再加上修改之后的数。#include <bits/stdc++.h>\n#include \"data_structure/fenwick.hpp\"\n\nusing namespace std;\n\nstruct modify {\n    int val, pos, add;\n};\n\nstruct query {\n    int l, r, k, i;\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    using op = variant<modify, query>;\n    vector<op> ops; // 为了方便实现我们把询问和修改放到一起\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        ops.push_back(modify{a[i], i, 1});\n    }\n\n    // 离散化\n    vector<int> comp{a};\n\n    int qcnt = 0;\n    for (int i = 0; i < m; i++) {\n        char ch;\n        cin >> ch;\n        if (ch == 'Q') {\n            int l, r, k;\n            cin >> l >> r >> k;\n            l--;\n            ops.push_back(query{l, r, k, qcnt});\n            qcnt++;\n        } else {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            ops.push_back(modify{a[x], x, -1});\n            comp.push_back(y);\n            a[x] = y;\n            ops.push_back(modify{a[x], x, 1});\n        }\n    }\n\n    sort(begin(comp), end(comp));\n    comp.erase(unique(begin(comp), end(comp)), end(comp));\n    const int N = (int)size(comp);\n\n    for (auto& o : ops) {\n        if (holds_alternative<modify>(o)) {\n            auto& v = get<modify>(o).val;\n            v = int(lower_bound(begin(comp), end(comp), v) -  begin(comp));\n        }\n    }\n\n    vector<int> ans(qcnt);\n\n    Fenwick<int> tr(n);\n    auto solve = [&](auto& slf, int l, int r, vector<op>& ops) -> void {\n        if (l == r) { // 二分结束，答案确定\n            for (const auto& o : ops) {\n                if (holds_alternative<query>(o)) { // 如果是询问的话\n                    ans[get<query>(o).i] = comp[l];\n                }\n            }\n            return;\n        }\n\n        int x = (l + r) / 2;\n\n        vector<op> left, right;\n        for (auto o : ops) {\n            if (holds_alternative<query>(o)) { // 询问\n                auto& [ql, qr, k, i] = get<query>(o);\n                int c = tr.get(ql, qr); // 贡献\n                if (c >= k) { // 根据贡献判断询问的答案该如何改变\n                    left.push_back(o);\n                } else {\n                    k -= c; // 在目标上减掉贡献和记录贡献是一样的\n                    right.push_back(o);\n                }\n            } else { // 修改\n                auto [val, pos, add] = get<modify>(o);\n                if (val <= x) {\n                    tr.add(pos, add);\n                    left.push_back(o);\n                } else {\n                    right.push_back(o);\n                }\n            }\n        }\n\n        for (auto o : left) {\n            if (holds_alternative<modify>(o)) { // 还原树状数组到初始状态\n                auto [val, pos, add] = get<modify>(o);\n                tr.add(pos, -add);\n            }\n        }\n\n        vector<op>{}.swap(ops); // 释放空间\n\n        slf(slf, l, x, left);\n        slf(slf, x + 1, r, right);\n    };\n\n    solve(solve, 0, N - 1, ops);\n\n    for (auto x : ans) cout << x << '\\n';\n    return 0;\n}[ZJOI2013]K大数查询题目链接此题同样因为有先后顺序所以也不能用第一种思路，但思路和上题类似。  中每个集合加入一个数就相当于在辅助数组中  的位置上加1，所以我们需要一个可以区间加的数据结构，最简单的就是树状数组啦。实现细节详见代码。#include <bits/stdc++.h>\n#include \"data_structure/fenwick_range_update.hpp\"\nusing namespace std;\n\nstruct modify {\n    int val, l, r;\n};\n\nstruct query {\n    int l, r;\n    int64_t k;\n    int i;\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    using op = variant<modify, query>;\n    vector<op> ops; // 为了方便实现我们把询问和修改放到一起\n\n    int qcnt = 0;\n\n    for (int i = 0; i < m; i++) {\n        int op, l, r, c;\n        cin >> op >> l >> r >> c;\n        l--;\n        if (op == 1) {\n            ops.push_back(modify{c, l, r});\n        } else {\n            ops.push_back(query{l, r, c, qcnt++});\n        }\n    }\n\n    vector<int> ans(qcnt);\n\n    fenwick_rg tr(n);\n    auto solve = [&](auto& slf, int l, int r, vector<op>& ops) -> void {\n        if (l == r || ops.empty()) { // 二分结束，答案确定\n            for (const auto& o : ops) {\n                if (holds_alternative<query>(o)) { // 如果是询问的话\n                    ans[get<query>(o).i] = l;\n                }\n            }\n            return;\n        }\n\n        int x = (l + r) / 2;\n\n        vector<op> left, right;\n        for (auto o : ops) {\n            if (holds_alternative<query>(o)) { // 询问\n                auto& [ql, qr, k, i] = get<query>(o);\n                int64_t c = tr.get(ql, qr); // 贡献\n                if (c >= k) { // 根据贡献判断询问的答案该如何改变\n                    right.push_back(o);\n                } else {\n                    k -= c; // 在目标上减掉贡献和记录贡献是一样的\n                    left.push_back(o);\n                }\n            } else { // 修改\n                auto [val, ql, qr] = get<modify>(o);\n                if (val > x) {\n                    tr.add(ql, qr, 1);\n                    right.push_back(o);\n                } else {\n                    left.push_back(o);\n                }\n            }\n        }\n\n        for (auto o : right) {\n            if (holds_alternative<modify>(o)) { // 还原树状数组到初始状态\n                auto [val, ql, qr] = get<modify>(o);\n                tr.add(ql, qr, -1);\n            }\n        }\n\n        vector<op>{}.swap(ops); // 释放空间\n\n        slf(slf, l, x, left);\n        slf(slf, x + 1, r, right);\n    };\n\n    solve(solve, 0, n, ops);\n\n    for (auto x : ans) cout << x << '\\n';\n    return 0;\n}Meteors题目链接此题的修改操作为区间加，而且修改和询问没有前后顺序，所以可以用第一种思路。#include <bits/stdc++.h>\n#include \"data_structure/fenwick.hpp\"\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> pos(n);\n    for (int i = 0; i < m; i++) {\n        int x;\n        cin >> x;\n        pos[x - 1].push_back(i);\n    }\n\n    vector<int> target(n);\n    for (auto& x : target) {\n        cin >> x;\n    }\n\n    int k;\n    cin >> k;\n    vector<array<int, 3>> meteors(k);\n    for (auto& [l, r, x] : meteors) {\n        cin >> l >> r >> x;\n        l--, r--;\n    }\n\n    vector<int> l(n, 0), r(n, k - 1);\n\n\n    while (true) {\n        vector<vector<int>> to_check(k);\n        bool done = 1;\n        for (int i = 0; i < n; i++) {\n            if (l[i] <= r[i]) {\n                int mid = (l[i] + r[i]) / 2;\n                to_check[mid].push_back(i);\n                done = false;\n            }\n        }\n\n        if (done) {\n            break;\n        }\n\n        Fenwick<int64_t> tr(m + 1);\n        auto range_add = [&](int l, int r, int x) {\n            tr.add(l, x);\n            tr.add(r, -x);\n        };\n        auto apply_meteor = [&](int i) {\n            auto [l, r, x] = meteors[i];\n            if (l <= r) {\n                range_add(l, r + 1, x);\n            } else {\n                range_add(l, m, x);\n                range_add(0, r + 1, x);\n            }\n        };\n        for (int i = 0; i < k; i++) {\n            apply_meteor(i);\n            for (auto j : to_check[i]) {\n                uint64_t sum = 0;\n                for (auto p : pos[j]) {\n                    sum += tr.get(p + 1);\n                }\n                if (sum >= target[j]) {\n                    r[j] = i - 1;\n                } else {\n                    l[j] = i + 1;\n                }\n            }\n        }\n    }\n\n    for (auto x : l) {\n        if (x == k) cout << \"NIE\\n\";\n        else cout << x + 1 << '\\n';\n    }\n    return 0;\n}AGC002D Stamp Rally题目链接这题思路其实不难，修改就是在并查集里连边，贡献就是连通块的大小，用第一种思路解决。#include <bits/stdc++.h>\n#include \"data_structure/union_find.hpp\"\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n\n    vector<array<int, 2>> edges(m);\n    for (auto& [u, v] : edges) {\n        cin >> u >> v;\n        u--, v--;\n    }\n\n    int q;\n    cin >> q;\n    vector<array<int, 3>> query(q);\n    for (auto& [l, r, x] : query) {\n        cin >> l >> r >> x;\n        l--, r--;\n    }\n\n    vector<int> l(q, 0), r(q, m - 1);\n\n    while (true) {\n        vector<vector<int>> to_check(q);\n        bool done = 1;\n        for (int i = 0; i < q; i++) {\n            if (l[i] <= r[i]) {\n                int mid = (l[i] + r[i]) / 2;\n                to_check[mid].push_back(i);\n                done = false;\n            }\n        }\n\n        if (done) {\n            break;\n        }\n\n        UF uf(n);\n        for (int i = 0; i < m; i++) {\n            uf.join(edges[i][0], edges[i][1]);\n\n            for (auto j : to_check[i]) {\n                auto [u, v, z] = query[j];\n                int sz = uf.size_of(u);\n                if (!uf.same(u, v)) {\n                    sz += uf.size_of(v);\n                }\n                if (sz >= z) {\n                    r[j] = i - 1;\n                } else {\n                    l[j] = i + 1;\n                }\n            }\n        }\n    }\n\n    for (auto x : l) {\n        cout << x + 1 << '\\n';\n    }\n    return 0;\n}"},{"id":"pb_ds-segment-tree","title":"用PB_DS实现简单线段树","content":"用PB_DS实现一个只能单点修改的线段树，但又能动态插入和删除，现场赛的时候在对时间要求不大的情况下可以节约敲代码时间。原理原理就是PB_DS里的tree的最后一个模板参数定义了节点如何更新，我们可以通过自定义类让节点维护额外的信息（子树大小之类的）。需要定义额外信息类为，然后重载括号运算符来定义节点如何合并。通过树分裂实现区间查询，但有个问题就是分裂之后的树的大小是通过来计算的，对于tree的迭代器来说时间复杂度是的，所以我们还要重载 例子：RMQ#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\n\nstruct Node {\n    int size, min;\n};\ntemplate<typename node_const_iterator, typename node_iterator, typename cmp_fn, typename _Alloc>\nstruct tree_max {\n    typedef Node metadata_type;\n \n    inline void operator() (node_iterator it, node_const_iterator null) const\n    {\n        auto& n = (Node&)it.get_metadata();\n        n.size=1;\n        n.min=(*it)->second;\n        for (auto& c : {it.get_l_child(), it.get_r_child()}) {\n            if (c != null) {\n                n.size+=c.get_metadata().size;\n                n.min=min(n.min, c.get_metadata().min);\n            }\n        }\n    }\n};\n\nusing Tree = __gnu_pbds::tree<int, int, std::less<int>, __gnu_pbds::splay_tree_tag, tree_max>;\nusing ti = Tree::iterator;\nTree *other;\nnamespace std {\n    template<> iterator_traits<ti>::difference_type distance<ti>(ti a, ti b) {\n        return other->node_begin().get_metadata().size; \n    }\n}\nvoid split(Tree& a, Tree& b, int x) {\n    other = &b;\n    a.split(x, b);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n, q;\n    cin >> n >> q;\n    Tree tr;\n    for (int i=0; i<n; i++) {\n        int x;\n        cin >> x;\n        tr.insert({i, x});\n    }\n    while (q--) {\n        int l, r;\n        cin >> l >> r;\n        Tree B, C;\n        split(tr, C, r-1);\n        split(tr, B, l-1);\n        cout << B.node_begin().get_metadata().min<<'\\n';\n        tr.join(B);\n        tr.join(C);\n    }\n}非分裂做法对于可逆的信息（如区间和）我们可以通过在树上行走获得前缀信息，然后通过前个前缀信息得到区间信息。目前先贴个别人的链接，还没研究如何写的短点。"},{"id":"portainer","title":"Portainer","content":"Portainer是一个Docker和Kubernetes管理软件（本文只涉及Docker)。安装先创建一个volumndocker volume create portainer_data安装docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.11.1其中9443是web ui的端口，可以根据情况修改。使用docker-composestacks -> add stack -> 复制docker-compose文件 -> deploy the stackQuick Actions常用两个quick actions:Logs: 查看logExec Console: 连进container里面干一些骚操作，比如装个包什么的。。。Tips设置内网IP左侧边栏Environment -> 选择服务器（默认叫Local）-> Public IP里填入服务器的内网IP这样点击端口就能自动跳转到正确的地址了。参考资料https://docs.portainer.io/v/ce-2.11/start/install/server/docker/linuxhttps://www.youtube.com/watch?v=ljDI5jykjE8#1"},{"id":"pro-micro-dfu-bootloader","title":"用两个Pro Micro互相给对方刷上DFU bootloader","content":"一篇如何用两个pro micro当作ISP(In-System Programmer)互相给对方刷上DFU bootloader.众所周知，一般pro micro自带的bootloader是caterina，有一个比较烦人的缺点就是一次reset之后只有8秒的时间在dfu模式里。而dfu bootloader就不会有这个问题。免责声明本人并不是学电子专业的，只是以一个客制化键盘爱好者的角度写的此教程，如有不慎或意外可能会导致pro micro变砖。纯小白请谨慎考虑。本文如有错误欢迎指正。工具软件Arduino IDEQMK toolboxbootloader文件硬件两个 pro micro，6根导线步骤给两个pro micro刷bootloader的步骤稍有不同给第一个pro micro刷打开Arduino IDE, Tools -> Arduino Leonardo, Tools -> Port 并记住端口号，File -> Examples -> ArduinoISP -> ArduinoISP 然后点upload，这样一个pro micro就变成了ISP。接线：每行左右两侧脚位相连:ISP目标VCCVCCGNDGNDSCLKSCLKMISOMISOMOSIMOSI10RST刷入Win+R然后输入cmd打开命令行，然后进到QMK Toolbox的目录，用到的程序在这个目录里。下面的要换成你QMK Toolbox 的版本号(写这个教程时最新的版本为0.1.1)，所以不要直接复制粘贴。cd AppData\\Local\\QMK\\QMK Toolbox\\0.x.x\\然后运行刷入的命令，其中换成第一步中的端口号，换成bootloader文件的地址avrdude.exe -c arduino -p atmega32u4 -P <PORT> -U flash:w:\"<PATH>\":a -U hfuse:w:0xD9:m -U efuse:w:0xC3:m -U lock:w:0x3F:m如果运行成功的话你就成功将dfu bootloader刷到pro micro上了。给另一个pro micro刷由于arduino不支持dfu，所以我们需要用另一个程序（也在QMK Toolbox的目录下）来将刷入dfu的那个pro micro再变成ISP。首先要找到ArduinoISP编译后的hex文件:(xxxxxx是一串数字，每个人的不一样)。接下来就准备刷入了，还是在QMK Toolbox的目录下，执行下面3条命令：(其中换成刚才提到的ArduinoISP.ino.hex的路径)dfu-programmer.exe atmega32u4 erase\ndfu-programmer.exe atmega32u4 flash <PATH>\ndfu-programmer.exe atmega32u4 reset最后再重复上一个部分的2、3步即可。参考资料https://www.reddit.com/r/olkb/comments/9ctx37/qmk_burn_dfu_bootloader_into_keyboard_with/\nhttps://www.reddit.com/r/olkb/comments/8sxgzb/replace_pro_micro_bootloader_with_qmk_dfu/"},{"id":"rime-flypy","title":"Rime配置码表输入法（以小鹤音形为例）","content":"rime输入法框架配置码表输入法的简单教程，以windows上小鹤音形为例。最近由于wayland有点受不了了，决定换成windows+wsl试试，虽说windows上有现成的小鹤音形，但相信大多数码表用户和我一样在标准词库上有所删减，所以需要一个输入法框架。用linux的时候久闻rime之大名，但并没有找到很好配置码表的教程，而官方文档有点长再加上是繁体写的读起来有点费事，遂决定记录一下自己配置的过程供大家参考。其实码表配置起来很简单，一共只需要两个文件：名为的方案定义文件和名为的码表文件。方案定义文件一般都有现成的，比如小鹤音形的在这(挂接第三方平台里)。码表格式要求看这，如果你像我一样之前是用fcitx格式的码表，可以很简单的用修改格式。然后将两个文件放入默认文件夹（windows上默认为），并修改:在里加一行。最后右键输入法图标点“重新部署”即可。"},{"id":"rime","title":"RIME简介与小鹤音形","content":"码表下载为了最大限度的自定义，我们肯定要找到纯文本码表，官方给的Rime挂接都只有二进制文件，但是我找了找竟然发现搜狗五笔是纯文本码表：下载链接码表去重以及转换为Rime格式#include <iostream>\n#include <fstream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ifstream in{\"sougou.txt\"};\n    string code, text;\n    multimap<string, pair<string, int>> mp;\n    int order = 0;\n    auto is_substr = [&](const string& a, const string& b) {\n        return a.substr(0, size(b)) == b || b.substr(0, size(a)) == a;\n    };\n    while (in >> code >> text) {\n        if (!mp.count(text)) {\n            mp.emplace(text, pair{code, order});\n        } else if (size(text) == 3) { // 单字保留多音字\n            auto it = mp.find(text);\n            bool dup = 0;\n            while (it!=end(mp) && it->first == text) {\n                if (is_substr(it->second.first, code)) {\n                    dup = true;\n                    if (size(code) < size(it->second.first))\n                        it->second = {code, order};\n                }\n                ++it;\n            }\n            if (!dup)\n                mp.emplace(text, pair{code, order});\n        } else if (size(text) == 6) { //两字词两码和四码优先\n            auto it = mp.find(text);\n            if (size(code) % 2 == 0 &&\n                    (size(it->second.first) % 2 || it->second.first.size() > code.size()))\n                it->second = {code, order};\n        } else { //其他词短码优先\n            auto it = mp.find(text);\n            if (it->second.first.size() > code.size())\n                it->second = {code, order};\n        }\n        order++;\n    }\n    vector<tuple<string, int, string>> v;\n    for (const auto& [text, code] : mp)\n        v.emplace_back(code.first, code.second, text);\n    sort(begin(v), end(v));\n\n    ofstream out{\"flypy.dict.yaml\"};\n    out << R\"(---\nname: flypy\nversion: \"0.1\"\nsort: original\nuse_preset_vocabulary: false\n...\n)\";\n    for (const auto& [code, odder, text] : v) {\n        out << text << '\\t' << code << '\\n';\n    }\n}Rime官方输入方案设计书schema.yaml详解常用的文件有:输入方案头文件 定义一个输入方案输入方案码表 输入方案的码表（如果用到码表的话）自定义全局设定 比如开启了哪些输入法针对不同发行版的设定 比如输入法皮肤示例# Rime schema settings\n# encoding: utf-8\n\nschema:\n  schema_id: flypy\n  name: 小鹤音形\n  version: \"10.8.4\"\n  author:\n    - 方案设计：何海峰 <flypy@qq.com>\n  description: |\n    小鹤音形输入法\n\npunctuator:\n  import_preset: default\n\nswitches:\n  - name: ascii_mode\n    reset: 0\n    states: [ 中文, 英文 ]\n  - name: full_shape\n    states: [ 半角, 全角 ]\n  - name: ascii_punct\n   # states: [ 。，, ．， ]\n    reset: 0\n\nengine:\n  processors:\n    - ascii_composer\n    - recognizer\n    - key_binder\n    - speller\n    - punctuator\n    - selector\n    - navigator\n    - express_editor\n  segmentors:\n    - ascii_segmentor\n    - matcher\n    - abc_segmentor\n    - punct_segmentor\n    - fallback_segmentor\n  translators:\n    - punct_translator\n    - table_translator\n    - table_translator@user_dict\n    - history_translator@history\n  filters:\n    - simplifier\n    - reverse_lookup_filter\n    - uniquifier\n\nspeller:\n  alphabet: \"abcdefghijklmnopqrstuvwxyz;'\"\n  initials: ';abcdefghijklmnopqrstuvwxyz'\n  finals: \"'\"\n  #delimiter: \" '\"\n  max_code_length: 4\n  auto_select: true   #顶字上屏\n  auto_select_pattern: ^;.$|^\\w{4}$\n  auto_clear: max_length #manual|auto|max_length 空码按下一键确认清屏|空码自动清|达到最长码时后码顶上清屏\n\ntranslator:\n  dictionary: flypy\n  enable_charset_filter: false\n  enable_sentence: false\n  enable_completion: false # 编码提示开关\n  enable_user_dict: false\n \n\nhistory:\n   input: ;f\n   size: 1 #重复前几次上屏\n   initial_quality: 1 #首选\n\n\nuser_dict:\n  dictionary: \"\"\n  user_dict: user_dict\n  db_class: tabledb\n  enable_sentence: false\n  enable_completion: false\n  initial_quality: -1 #优先级\n\n\nkey_binder:\n  import_preset: default #方案切换相关\n  bindings:\n    - {accept: bracketleft, send: Page_Up, when: paging} # [上翻页\n    - {accept: bracketright, send: Page_Down, when: has_menu} # ]下翻页\n    - {accept: comma, send: comma, when: paging} #注销逗号翻页\n    - {accept: period, send: period, when: has_menu} #注销句号翻页\n    - {accept: semicolon, send: 2, when: has_menu} #分号次选\n    # - {accept: Release+semicolon, send: semicolon, when: has_menu} #如启用此行，则分号引导符号功能无效\n    - {accept: Release+period, send: period, when: composing} #句号顶屏\n    - {accept: Release+comma, send: comma, when: composing} #逗号顶屏\n    - {accept: \"Tab\", send: Escape, when: composing}\n    - {accept: \"Shift_R\", send: Escape, when: composing}\n    # - {accept: \"Shift+space\", toggle: full_shape, when: always} #切换全半角\n    - {accept: \"Control+period\", toggle: ascii_punct, when: always} #切换中英标点\n    # - {accept: \"Control+j\", toggle: simplification, when: always} #切换简繁\n\nrecognizer:\n  import_preset: default\n  patterns:\n    # reverse_lookup: \"[a-z`]*`+[a-z`]*\"反查应该不需要\n\nmenu:\n  page_size: 5 #候选项数\n  \nstyle:\n  horizontal: true #竖排为false"},{"id":"rust-BTreeSet","title":"Rust BTreeSet","content":"有用的函数range()返回set中一段区间的迭代器，可以当C++中或者用，举例：use std::ops::Bound::*;\nlet mut set = BTreeSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(3);\nassert_eq!(set.range(2..).next(), Some(&2));\nassert_eq!(set.range((Excluded(2), Unbounded)).next(), Some(&3));\nassert_eq!(set.range(..2).last(), Some(&1));\nassert_eq!(set.range(..=2).last(), Some(&2));"},{"id":"rust-iterator","title":"Rust 迭代器（Iterator）","content":"实用函数, "},{"id":"rust-pattern","title":"Rust 模式（Pattern）","content":"匹配字面量let x = 1;\nmatch x {\n    1 => println!(\"one\") ,\n    2 => println!(\"two\"),\n    3 => println!(\"three\") ,\n    _ => println!(\"anything\"),\n}匹配变量let x = Some(5);\nmatch x {\n    Some(50) => println!(\"Got 50\"),\n    Some(y) => println!(\"Got {:?}\", y),\n    _ => println!(\"Got something else {:?}\", x),\n}一个分支多个模式let x = 1;\nmatch x {\n    1 | 2 => println!(\"one or two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}用..=匹配范围目前只支持..=let x = 5;\n\nmatch x {\n    1..=5 => println!(\"one through five\"),\n    _ => println!(\"something else\"),\n}\n\nlet x = 'c';\n\nmatch x {\n    'a'..='j' => println!(\"early ASCII letter\"),\n    'k'..='z' => println!(\"late ASCII letter\"),\n    _ => println!(\"something else\"),\n}分解结构体（Destructing Structs）struct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x: a, y: b } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n}当变量名称与field名称相同时可以简写：struct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x, y } = p;\n    assert_eq!(0, x);\n    assert_eq!(7, y);\n}匹配部分：struct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } => println!(\"On the x axis at {}\", x),\n        Point { x: 0, y } => println!(\"On the y axis at {}\", y),\n        Point { x, y } => println!(\"On neither axis: ({}, {})\", x, y),\n    }\n}分解Enumsenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println!(\"The Quit variant has no data to destructure.\")\n        }\n        Message::Move { x, y } => {\n            println!(\n                \"Move in the x direction {} and in the y direction {}\",\n                x, y\n            );\n        }\n        Message::Write(text) => println!(\"Text message: {}\", text),\n        Message::ChangeColor(r, g, b) => println!(\n            \"Change the color to red {}, green {}, and blue {}\",\n            r, g, b\n        ),\n    }\n}分解嵌套的结构体或者Enumsenum Color {\n    Rgb(i32, i32, i32),\n    Hsv(i32, i32, i32),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(Color),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n\n    match msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) => println!(\n            \"Change the color to red {}, green {}, and blue {}\",\n            r, g, b\n        ),\n        Message::ChangeColor(Color::Hsv(h, s, v)) => println!(\n            \"Change the color to hue {}, saturation {}, and value {}\",\n            h, s, v\n        ),\n        _ => (),\n    }\n}分解结构体和元组fn main() {\n    struct Point {\n        x: i32,\n        y: i32,\n    }\n\n    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });\n}忽略模式中的值用忽略整个值：fn foo(_: i32, y: i32) {\n    println!(\"This code only uses the y parameter: {}\", y);\n}\n\nfn main() {\n    foo(3, 4);\n}用嵌套的忽略值的部分：fn main() {\n    let mut setting_value = Some(5);\n    let new_setting_value = Some(10);\n\n    match (setting_value, new_setting_value) {\n        (Some(_), Some(_)) => {\n            println!(\"Can't overwrite an existing customized value\");\n        }\n        _ => {\n            setting_value = new_setting_value;\n        }\n    }\n\n    println!(\"setting is {:?}\", setting_value);\n}忽略元组的部分值：fn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, _, third, _, fifth) => {\n            println!(\"Some numbers: {}, {}, {}\", first, third, fifth)\n        }\n    }\n}忽略剩余部分：fn main() {\n    struct Point {\n        x: i32,\n        y: i32,\n        z: i32,\n    }\n\n    let origin = Point { x: 0, y: 0, z: 0 };\n\n    match origin {\n        Point { x, .. } => println!(\"x is {}\", x),\n    }\n}匹配第一个和最后一个：fn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) => {\n            println!(\"Some numbers: {}, {}\", first, last);\n        }\n    }\n}利用Match Guards实现更多的条件fn main() {\n    let num = Some(4);\n\n    match num {\n        Some(x) if x % 2 == 0 => println!(\"The number {} is even\", x),\n        Some(x) => println!(\"The number {} is odd\", x),\n        None => (),\n    }\n}多模式：fn main() {\n    let x = 4;\n    let y = false;\n\n    match x {\n        4 | 5 | 6 if y => println!(\"yes\"), // 等价于 (4 | 5 | 6) if y =>\n        _ => println!(\"no\"),\n    }\n}@绑定@允许我们在创建变量的同时测试变量的值fn main() {\n    enum Message {\n        Hello { id: i32 },\n    }\n\n    let msg = Message::Hello { id: 5 };\n\n    match msg {\n        Message::Hello {\n            id: id_variable @ 3..=7,\n        } => println!(\"Found an id in range: {}\", id_variable),\n        Message::Hello { id: 10..=12 } => {\n            println!(\"Found an id in another range\")\n        }\n        Message::Hello { id } => println!(\"Found some other id: {}\", id),\n    }\n}Reference:\nPattern Syntax"},{"id":"rust-slice","title":"Rust Slice","content":"实用函数, "},{"id":"rvalue-reference","title":"关于右值引用的一些知识点","content":"感觉一直都没怎么搞明白，遂决定仔细学一下并记录一些零散的知识点。（包含个人理解，不一定严谨正确）值类别与类型C++ 表达式具有值类别与类型两种属性。C++ 有三种基本类别：左值，纯右值，亡值。纯右值和亡值统称为右值，右值不能由内建的取址运算符取地址。大部分右值都是纯右值，与这篇文章关系比较大的亡值有：返回类型是对象的右值引用的函数调用或重载运算符表达式，例如 转换到对象的右值引用类型的转型表达式，例如 类型有基础类型：、等，复合类型。我们这里主要讨论复合类型中的引用类型，引用类型又包含左值引用类型与右值引用类型。注意区别值类别与类型，比如 ，变量  的类型是右值引用类型，但是  这个表达式是左值。不是  都是右值引用只有确定的类型加才是右值引用，否则被称为 universal reference(万能引用)/forwarding reference(转发引用？)，万能引用可能会被推导为做左值引用。int x = 1;\nint& lref = x;\nint&& rref = 1;\nauto&& y = lref;\nauto&& z = std::move(rref);\nauto& yy = lref;\nconst auto& zz = std::move(rref);\nstatic_assert(is_same_v<decltype(y), int&>);\nstatic_assert(is_same_v<decltype(z), int&&>);\nstatic_assert(is_same_v<decltype(yy), int&>);\nstatic_assert(is_same_v<decltype(zz), const int&>); 与  本质就是无条件转换成右值引用， 是有条件的类型转换：如果  是右值引用类型，函数表达式为右值否则  为左值引用类型或非引用类型，函数表达式为左值注意我们不能通过简单的赋值来实现右值引用的转发，即：void foo(int&& x) {}\n\nvoid bar(int&& x) {\n    foo(x);\n}会导致编译错误，因为在  中，表达式  是左值，不能作为  的参数。"},{"id":"software-misc","title":"软件杂项","content":"用cue文件分割flac并标记shnsplit -f <cuefile> -t %n-%t -o flac <flacfile>\ncuetag <cuefile> *.flac"},{"id":"switch-to-hello-friend","title":"记又一次给博客换主题","content":"鬼知道我已经换了多少次主题了。。。大概每过一阵子我就会被某个极简的网站刺激一下，这次是这个，真的好喜欢白纸黑字的感觉，再加上其实也不是很喜欢之前用的 wowchemy，虽说比较简洁了但总感觉哪不对劲（丑的一批的红色行内代码字体就是之一，想改发现不用还不行），隧果断决定换主题。本来想自己从头做一个模仿这个的主题，但看了1个小时Hugo文档之后感觉还是搞不太明白就放弃了，幸好找到这个，看起来就很舒服，而且可以写首页的内容于是也就起到了 portfolio 的效果。这次搬迁花的时间尤其长，主要用在做新的东西上，加了如下新特性：样式改动语言切换菜单（弄了好久，前端菜鸡的痛）Katex评论系统代码高量亮色与暗色主题Tabler icon支持希望这次能多用一段时间。。。"},{"id":"tarjan-lowlink","title":"关于Tarjan算法中的low link的另类定义与更新","content":"Tarjan的论文中指出LOWLINK(v) is the smallest vertex which is in the same component as v and is reachable by traversing zero or more tree arcs followed by at most one [back edge] or [cross edge].也就是说u的lowlink是在dfs树中u的子树中的节点经过最多一条返祖边（back edge,也叫反向边）能到达最低的dfs序。所以在dfs的时候对于已访问和未访问的节点要用不同的更新：对于未访问的节点v我们用，对于访问过的节v点用。但这样也许有一点麻烦，增加了记忆难度，一不小心也可能写错。如果我们稍微修改一下定义，忽略返祖边的数量限制，得到的算法依然是对的！因为我们只关心lowlink是否是u的祖先，至于哪个祖先无所谓。所以这种定义在保证正确性的同时简化了代码，可以考虑使用。代码见此"},{"id":"tarjans-algorithm","title":"Tarjan算法（强连通，割点，桥）对比总结","content":"Tarjan算法中定义了两个数组：: 节点u的前序遍历编号，如果是有向图还要规定在到根节点的路径上，无向图不用这个是因为无向图中的反向边一定指向到根节点路径中的某一个点。换言之，就是的子树中的节点经过最多一条反向边能到达节点的最小值。在强连通分量以及点双连通分量算法中，还要在遍历的时候用一个栈维护遍历过的节点，在特定的时候将栈中的某些节点弹出形成所对应的分量。强连通分量当时，将以及之后的节点弹出，这些节点属于同一个强连通分量。割点与点双连通分量割点与点双连通分量个关系：一个割点会属于多个点双连通分量，且两个点双连通分量的交集中最多只有一个点。当(为在dfs树中的一个直接儿子)时，已经之后的节点属于同一个点双连通分量，将以及之后的节点弹出。如果属于至少两个点双连通分量则为割点。桥与边双连通分量桥与边双连通分量的关系：桥将图分割为边双连通分量，即一条边为桥当且仅当边的两端属于不同的分量。一条边为桥当且仅当。松弛low数组定义在强连通分量以及边双连通分量中，去掉数组中最多一条反向边的限制并不会影响算法的正确性，而且可以简化编码和记忆难度。假设存在一个点，其两种定义的不同，也就是说所对应的节点处还有一条反向边，设该反向边的另一节点为。由于考虑以下两种情况：情况1：，所以我们可以利用的反向边得到更小的，与的定义矛盾。情况2：，松弛定义之后依然小于，这并不影响两个算法的判定。也就是说当且仅当时，两种定义的才会不同。在强连通分量中，这种情况不会影响条件的判定。在边双连通分量中，当时，（因为是到根节点路径上值最大的节点）所以边已经是桥了，不会影响判定。然而，在点双连通分量中，当时，如果处有反向边，松弛定义之后，使得前后两种判定结果不一致导致算法的正确性无法得到保证。"},{"id":"tree-path-technique","title":"树上路径技巧","content":"求u到v路径的第二个节点出处如果v不在u的子树里，显然第二个节点是u的父亲，当v在u的子树里时，有以下两种做法：以dfs前序遍历的顺序建st表，比较时取深度较小的点，如果深度相同则取dfs序较大的点，第二个节点即为区间的值。第二个节点是值小于等于的节点中值最大的节点，用二分即可。代码：int next_vertex_in_path(int u, int v) {\n    int l = 0, r = (int)size(g[u]) - 1;\n    while (l < r) {\n        int mid = (l + r) / 2;\n        if (pre[g[u][mid]] <= pre[v]) {\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return g[u][l];\n}O(1)询问路径最大值构造Kruskal重构树，路径中权值最大的边即为重构树中u与v的lca所代表的边。"},{"id":"update-2022-04-26","title":"一些更新","content":"好久没写东西了，考试也基本完事了，大概说一下最近的一些变化，主要就两个：1. 博客换了个主题，主要是想吧portfolio和博客合并到一个网站上，而之前那个主题扩展性太差了，而且自己又不写前端代码，于是研究了其他各种解决方案。其实notion我还挺喜欢的，可惜不开源而且没法导出数据。Ghost看起来不错但又增加新的学习成本，而且感觉是用来做订阅服务的。最后还是决定继续hugo，wowchemy看起来不错，扩展性和定制性兼具。2. 前段时间弄了个wiki单独记录一些以后可能会经常查阅的东西，要是发在博客里就会分散在各个地方不方便检索。链接就在菜单栏上。"},{"id":"vertex-cover","title":"点覆盖，独立集，以及团的关系","content":"点覆盖的补集是独立集，因为在点覆盖中，任意一条边都被至少选了一个顶点，所以对于其点集的补集，任意一条边都被至多选了一个顶点，所以不存在边连接两个点集中的点。所以最小点覆盖是最大独立集点补集。独立集是补图中的一个团，这个显而易见。所以最大独立集是补图中的最大团。下面介绍一种在  时间求最大团的做法。考虑如下暴力做法：设  返回点集  能构成点最大团，我们找到  中标号最小的点 ，有两种情况： 不在最大团里，此时我们把  从  中除去，调用  在最大团里，接下来我们只需考虑和  相邻的点，调用 ，其中  是与  相邻的点的集合。 即返回以上两种情况的最大值。以上暴力做法显然是  的，但如果我们加入记忆化，以上做法就会神奇的变成 。为什么呢？考虑递归树以及所有不包含前  个顶点的集合，因为每一次递归调用的集合大小至少减一，所以递归树会在至多  层计算这些集合，第一次计算这些集合总共用的时间为 ，之后会直接返回，而递归树前  层有  个节点，所以两部分加起来时间依然是 。代码：static long long max_clique(const std::vector<long long>& g, const std::vector<int>& cost) {\n    int n = (int)size(g);\n\n    std::map<long long, long long> memo{{0, 0}};\n    auto solve = [&](auto& slf, long long mask) {\n        if (memo.count(mask)) {\n            return memo[mask];\n        }\n        int first = __builtin_ctzll(mask);\n        return memo[mask] = std::max(slf(slf, mask ^ (1LL << first)), \n                g[first] >> first & 1 ? slf(slf, (mask & g[first]) ^ 1LL << first) + cost[first] : 0);\n    };\n    return solve(solve, (1LL << n) - 1);\n}注意：在这个实现里我们强制每个团中的每个顶点都包含自环，这样我们就可以正确求解含自环的图的最小点覆盖/最大独立集问题。例题：CF1105E. Helping Hiasat （最大独立集）CF1767E. Algebra Flash （最小权点覆盖）"},{"id":"wezterm","title":"WezTerm 折腾记录","content":"最近把终端模拟器从 Kitty 换成了 WezTerm，主要是因为 WezTerm 有随系统自动切换深色主题的能力。作为一个白天用亮色主题晚上用暗色主题的人，终端主题的切换一直是一大痛点（虽说可以通过一个简单的脚本手动切换，但还是有点麻烦，不够优雅），看到 WezTerm 有这个能力之后果断换成了 WezTerm。主题随系统自动切换和是两个table，其中包含和。注意也会再次触发事件，所以一定要在当前主题需要改变的时候才调用，不然会死循环。local function get_color()\n    local appearance = wezterm.gui.get_appearance()\n    if appearance:find 'Dark' then\n        return tokyonight_storm\n    else\n        return tokyonight_day\n    end\nend\n\nwezterm.on('window-config-reloaded', function (window, pane)\n    local overrides = window:get_config_overrides() or {}\n    local target = get_color()\n    if overrides.colors ~= target.colors then\n        overrides.colors = target.colors\n        overrides.window_frame = target.window_frame\n        window:set_config_overrides(overrides)\n    end\nend)正常渲染Neovim中的波浪线详见官方文档中的F.A.Q.tempfile=$(mktemp) \\\n  && curl -o $tempfile https://raw.githubusercontent.com/wez/wezterm/master/termwiz/data/wezterm.terminfo \\\n  && tic -x -o ~/.terminfo $tempfile \\\n  && rm $tempfile然后设置环境变量。"},{"id":"wildcard-ssl","title":"通配符SSL证书","content":"安装certbot官方网页上说用snap（虽说我不是很喜欢snap）：sudo snap install --classic certbot安装完还需要这两条命令:sudo ln -s /snap/bin/certbot /usr/bin/certbot\nsudo snap set certbot trust-plugin-with-root=ok获取证书为了获得通配SSL证书，你必须展示出对域名的所有权，常见的做法是DNS记录挑战（即设定指定的TXT记录）。挑战可以手动完成，也可以通过DNS插件自动完成（推荐）。DNS插件DNS插件的作用在于可以自动话挑战过程，所以也就可以实现证书自动续期。在此查看所有支持的dns提供商，如果不支持的话就只能手动验证了。下面以cloudflare举例，其他DNS提供商只要把下面出现的cloudflare单词替换成对应的名字就好。安装插件sudo snap install certbot-dns-cloudflare获取API令牌（以cloudflare为例）到 https://dash.cloudflare.com/profile/api-tokens，点「API令牌」-> 「编辑区域 DNS」，选择域名，「继续以显示摘要」，「创建令牌」，复制生成的令牌。配置插件将上一步的令牌放到一个ini文件中（比如~/certbot-creds.ini），格式如下：dns_cloudflare_token = <your token>修改文件权限chmod 600 ~/certbot-creds.ini申请证书sudo certbot certonly \\\n  --dns-cloudflare \\\n  --dns-cloudflare-credentials ~/certbot-creds.ini \\\n  -d '*.example.com'手动验证sudo certbot certonly --manual -d '*.example.com' --agree-tos --no-bootstrap --manual-public-ip-logging-ok --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory然后根据提示完成挑战即可。查看证书sudo certbot certificates测试自动续期sudo certbot renew --dry-run参考资料：https://certbot.eff.org/instructions?ws=apache&os=ubuntufocalhttps://www.digitalocean.com/community/tutorials/how-to-create-let-s-encrypt-wildcard-certificates-with-certbot"},{"id":"york2tutr","title":"York University programming contest 2 题解","content":"还算顺利的一场题目链接A - 3D Printed Statues题意： 你有1个3D打印机，打印机每天可以打印出1个打印机或者1个雕塑，你需要打印出n个雕塑，问最少需要几天。思路： 不难想出，只用一天打印雕塑就够了，因为如果要需要更多的天数，不如先打印打印机然后再打印雕塑，所以思路就是一开始疯狂打印打印机直到打印个数大于等于n，然后天数加一。B - Digital display题意： 给出一个时间，用7段显示的方式输出（格式看题目就行）思路： 当时写麻烦了，其实可以把端点和中间的线合起来写成一个函数的，这样就只用写画横着和竖着的线的函数，用二维数组存整个图案，根据数字和第几位数确定横线和竖线的起点坐标，调用对应的画线函数就行了。最坑的是这个oj没有格式错误，当时少了一个空行却以为是别的错，wa了好几发……这个题耽误了贼长时间。C - Eight Queens题意： 给出一个棋盘，判断是不是合法的八皇后放法。思路： 遍历棋盘，碰到皇后就进行判断其4个方向上有没有别的皇后。但是题目里有一点没说就是皇后的数量可能不为8，还好wa了一次就想到这个了，不然可能要自闭……D - Eko题意： 给出棵树的高度，你可以选择某一个高度，然后把所有在此高度之上的木头都砍掉，对于给出的单位的树木，找出至少能获得这些数量的最高高度。思路： 因为随着高度从低到高，砍掉的树木的数量单调递增，所以可以用二分搜索。推荐一种二分的写法，很好记，可以对付各种类型的二分。代码#include <bits/stdc++.h>\r\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\r\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\r\n#define fore(i, a, b) for (int i = int(a); i <= b; ++i)\r\n#define ms(a, x) memset(a, x, sizeof(a));\r\ntypedef long long ll;\r\nusing namespace std;\r\nconst int N = 1e6 + 5;\r\nll a[N];\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(0);\r\n    ll n, m;\r\n    cin >> n >> m;\r\n    ll r = 0;\r\n    forn(i, n) {\r\n        cin >> a[i];\r\n        r = max(a[i], r);\r\n    }\r\n    ll l = 0;\r\n    while (l <= r) {\r\n        ll tot = 0;\r\n        ll mid = (l + r) / 2;\r\n        forn(i, n) {\r\n            if (a[i] > mid) tot += a[i] - mid;\r\n        }\r\n        if (tot >= m) l = mid + 1;\r\n        else\r\n            r = mid - 1;\r\n    }\r\n    cout << r;\r\n    return 0;\r\n}E - Election题意： 有个人投票，已经知道第一个人有票，第二个人有票，已知每个人投票都是随机的，判断是以下哪三种情况：1、第一个人的胜出的概率超过, 2、第一个人必输，3、剩下的情况。思路： 排列组合的问题，一直被卡到结束，到第二天才发现是算组合数的时候爆了因为用了最为弱智的算法。算时应乘一个除一个，分子的部分应从开始乘，分母的部分应从开始除，如果最终结果在long long之内的话这样算就不会爆。还好最多只有50个人投票，最多只有种情况。代码#include <iostream>\r\ntypedef long long ll;\r\n\r\nll calc(int a, int b) {\r\n  if (a - b < b) b = a - b;\r\n  ll ans = 1;\r\n  for(int i=1,i<=b;i++) \r\n    ans = ans*(a -b+ i)/i;\r\n  return ans;\r\n}\r\n\r\nusing namespace std;\r\nint main() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(0);\r\n  int n, v1, v2, w;\r\n  int T;\r\n  cin >> T;\r\n  while (T--) {\r\n    cin >> n >> v1 >> v2 >> w;\r\n    if (n - v2 <= v2)\r\n      cout << \"RECOUNT!\\n\";\r\n    else {\r\n      ll ans = 0;\r\n      int lef = n - v1 - v2;\r\n      for (int i = 0; i <= lef; i++) {\r\n        if (v1 + i > v2 + lef - i) {\r\n          ans += calc(lef, i);\r\n        }\r\n      }\r\n      if (ans * 100.0 / (1ll << lef) > w)\r\n        cout << \"GET A CRATE OF CHAMPAGNE FROM THE BASEMENT!\\n\";\r\n      else\r\n        cout << \"PATIENCE, EVERYONE!\\n\";\r\n    }\r\n  }\r\n  return 0;"},{"id":"yorku1totr","title":"York Univeristy programming contest 第一场题解","content":"这是一场关于身残志坚的比赛。那天晚上切菜时切着手了，去了医院，没想到挂个急诊还要等这么久，心想晚上的比赛肯定泡汤了，等待之余想起自己包里还有iPad和蓝牙键盘，虽然比赛已经开始半小时了，而且自己只有9根指头能用，就当玩玩吧，于是我连上键盘，打开koder，在iPad上打起了比赛，没想到最后出了三个题，排名第三，手指和比赛都保住了……题目链接A. Cold-puter Science题意： 给出个数问有几个数小于0。思路： 这就不用说了吧，基本上是我见过的最水的签到题了。B. Are You Listening?题意： 给出自己的坐标以及个敌放监听点的坐标和监听半径，对方最少需要3个点探测到你才能确定你的位置，问自己广播的最大半径是多少（答案可能是0，向下取整）。思路： 设监听点的与你的距离是，半径是，那么就是不被检测到的最大广播半径。于是每读入一组监听点的数据就计算出并存入数组中，最后对数组排序，如果第三个数小于0就输出0否则输出向下取整后的数。C. Chewbacca题意： 给出一棵有个节点的满树，每个节点最多有个子节点，节点的需要从上往下、从左往右排列，给出个询问，问树上两个点的最短路径的长度。思路： 当时想到是求LCA了，但因为没学过而且排到我了就没做，其实这题很简单，因为题目很特殊：是一棵满树并且父亲与儿子之间的距离是1，所以可能采用比较暴力的算法，经过实验可以发现：如果一个节点的序号是，那么就是其父节点的坐标，由此我们就可以通过不断除得到两个节点的深度(其实好像也可以直接求)，先使深度比较大的节点跳转到深度比较小的节点的深度，然后令两个点同时向上跳转直到重合。D. Bike Gears题意： 给出自行车所有前变速轮和后变速轮的齿数，定义一组齿轮组合的gear值为前齿轮数除以后齿轮数，要求按照gear值从小到大输出所有齿轮的组合。思路： 由于齿轮数可大至，即使是用long double来存gear值也会出现精度问题。所以只能存gear的最简分数，在排序的时候用通分来比较，注意虽然单个齿轮的值没有超过int但通分的时候相乘就可能爆，所以要用long long来存储。还有一点比较坑的就是题目里没说如果两组齿轮的gear相同怎么办，只能从样例里来推断是先输出小的。\r\nsolution: As the number of sprockets can be as large as , even long double is not precise enough to store the number of gear. Therefore, the only way to do it is to store the simplified fraction of the gear and the numerator and denominator should be stored in long long variable in case the product exceed the int-max. Another thing to be noticed is that the sequence of two sets of sprockets with the same gear is not mentioned in the question, but as the sample suggested the sets with smaller front and back sprockets should be output first."}]