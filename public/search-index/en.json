[{"id":"2019_ECNA_K","title":"Tutorial for 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","content":"Feels pretty standard, but I was too bad at that time. Good problem.SolutionFor brevity, let's use  denote A, E, I, O, U.Let  be the cost to put all the bins of type  consecutively to where ends at .For the 5 types of bins, there's are  combinations of relative order. Let   be the best cost to put  types of bins such that the last type of bins ends at . Obviously,  can be one of of .For ,  can be calculated from :Time complexity:  (correct me if I'm wrong).Code#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin>>s;\n    int n=(int)s.size();\n    vector<int> a(n), bins(n);\n    for (auto& i : a) cin>>i;\n    map<char, int> mp{{'A', 0}, {'E', 1}, {'I', 2}, {'O', 3}, {'U', 4}};\n    int cnt[5]{}, totalCost[5]{};\n    int d;\n    cin>>d;\n    while (d--) {\n        int x;\n        cin>>x;\n        x--;\n        a[x]=0;\n        s[x]='X';\n    }\n    for (int i=0; i<n; i++) {\n        auto c=s[i];\n        if (c!='X') {\n            cnt[mp[c]]++;\n            totalCost[mp[c]]+=a[i];\n            bins[i]=mp[c];\n        } else bins[i]=-1;\n    }\n    string t;\n    cin>>t;\n    if (t!=\"X\") for (auto c : t) cnt[mp[c]]++;\n    constexpr int INF=1e9;\n    vector endCost(5, vector(n, INF));\n    auto bestCost=endCost;\n    for (int bin=0; bin<5; bin++) {\n        for (int i=0; i<n; i++) {\n            if (i>=cnt[bin]-1) {\n                endCost[bin][i]=totalCost[bin];\n                for (int j=0; j<cnt[bin]; j++) {\n                    if (bins[i-j]==bin) endCost[bin][i]-=a[i-j];\n                }\n            }\n        }\n    }\n    int ans=1e9;\n    vector<bool> available(5, true);\n    auto solve=[&](auto& solve, int level) -> void{\n        if (level==0) {\n            for (int o=0; o<5; o++) {\n                available[o]=false;\n                bestCost[0]=endCost[o];\n                solve(solve, 1);\n                available[o]=true;\n            }\n        } else if (level==5) {\n            ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end()));\n        } else {\n            for (int o=0; o<5; o++) {\n                if (available[o]) {\n                    available[o]=false;\n                    int spaceNeeded=0;\n                    for (int o2=0; o2<5; o2++) {\n                        if (!available[o2]) spaceNeeded+=cnt[o2];\n                    }\n                    for (int i=0; i<n; i++) {\n                        bestCost[level][i]=INF;\n                        if (i>=spaceNeeded-1) {\n                            for (int j=0; j<i-cnt[o]+1; j++) {\n                                bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]);\n                            }\n                        }\n                    }\n                    solve(solve, level+1);\n                    available[o]=true;\n                }\n            }\n        }\n\n    };\n    solve(solve, 0);\n    cout<<ans;\n    return 0;\n}"},{"id":"2020_SWERC_K","title":"Solution for 2020 ICPC SWERC K - Unique Activities","content":"Solution 1: Suffix ArrayFor each suffix starting from , the length of the shortest unique substring which is a prefix of that suffix is  where  and  is defined to be . Note that if that length is greater than the length of suffix, it's an invalid substringCode:#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nvector<int> suffix_array(string s) {\n    s+=\"#\";\n    int n = s.size(), N = n + 256;\n    vector<int> sa(n), ra(n);\n    for(int i = 0; i < n; i++) sa[i] = i, ra[i] = s[i];\n    for(int k = 0; k < n; k ? k *= 2 : k++) {\n        vector<int> nsa(sa), nra(n), cnt(N);\n        for(int i = 0; i < n; i++) nsa[i] = (nsa[i] - k + n) % n;\n        for(int i = 0; i < n; i++) cnt[ra[i]]++;\n        for(int i = 1; i < N; i++) cnt[i] += cnt[i - 1];\n        for(int i = n - 1; i >= 0; i--) sa[--cnt[ra[nsa[i]]]] = nsa[i];\n \n        int r = 0;\n        for(int i = 1; i < n; i++) {\n            if(ra[sa[i]] != ra[sa[i - 1]]) r++;\n            else if(ra[(sa[i] + k) % n] != ra[(sa[i - 1] + k) % n]) r++;\n            nra[sa[i]] = r;\n        }\n        ra = nra;\n    }\n    sa.erase(sa.begin());\n    return sa;\n}\n\nvector<int> build_lcp(const string& s, const vector<int>& sa) {\n    int n=s.size();\n    vector<int> pos(n);\n    for (int i = 0; i < n; i++) pos[sa[i]] = i;\n\n    vector<int> lcp(n);\n    int k = 0;\n    for (int i = 0; i < n; i++) {\n        if (pos[i]==0) continue;\n        if (k) k--;\n        while (s[i+k] == s[sa[pos[i]-1]+k]) k++;\n        lcp[pos[i]] = k;\n    }\n    return lcp;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin>>s;\n    auto sa=suffix_array(s);\n    auto lcp=build_lcp(s, sa);\n    lcp.push_back(0);\n    int ans=s.size();\n    int l=0;\n    for (int i=1; i<(int)s.size(); i++) {\n        int len=max(lcp[i], lcp[i+1])+1;\n        if (len>s.size()-sa[i]) continue;\n        if (len<ans) {\n            ans=len;\n            l=sa[i];\n        } else if (len==ans) l=min(l, sa[i]);\n    }\n    cout<<s.substr(l, ans);\n}Solution 2: Binary Search + String HashingNote that if a substring is unique, then all the other substrings containing that substring is also unique. So we can binary search the length of the substring.For each length, we check if there is a unique substring in all the substrings of that length using hashing. One way of calculating hash value of a substring efficiently is to precalculate hash value of all prefixes (like prefix sum). Note that in the implementation, we let the left position be more significant bit in order to avoid division.Code:#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin>>s;\n    int n=(int)s.size();\n    constexpr int mod=1e9+7;\n    vector<ll> pow(n+1), ha(n+1);\n    pow[0]=1;\n    for (int i=1; i<=n; i++) {\n        pow[i]=pow[i-1]*233%mod;\n        ha[i]=(ha[i-1]*233+s[i-1])%mod;\n    }\n    auto get_hash=[&](int l, int r) {\n        l++, r++;\n        return (ha[r]-ha[l-1]*pow[r-l+1]%mod+mod)%mod;\n    };\n    auto check=[&](int len) {\n        unordered_map<int, int> cnt;\n        for (int i=0; i+len-1<n; i++) {\n            cnt[get_hash(i, i+len-1)]++;\n        }\n        for (int i=0; i+len-1<n; i++) {\n            if(cnt[get_hash(i, i+len-1)]==1) return i;\n        }\n        return -1;\n    };\n    int l=1, r=n;\n    while (l<=r) {\n        int mid = (l+r)/2;\n        if (check(mid)!=-1) {\n            r=mid-1;\n        } else {\n            l=mid+1;\n        }\n    }\n    int ans=check(l);\n    cout<<s.substr(ans, l);\n}"},{"id":"ABC165F","title":"Solution for AtCoder beginner contest 165F - LIS on Tree","content":"Very interesting problem.SolutionThe problem is not hard if you know to find the LIS in  time. Combining LIS and tree problem is quite interesting.The key part of this problem is how to backtrack. I used  so the backtrack part is a little bit more cumbersome than regular array's since you have to record whether you add a new element or replace a element. My approach is that if we add a new element, set  to -1 otherwise set  to the old number.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... Args> void rd(Args&... args) {((cin >> args), ...);}\ntemplate<typename... Args> void write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nvector<int> a,ans;\nconst int N=2e5+5;\nvector<int> G[N];\nvoid dfs(int u,int fa,vector<int>& lis){\n    int flag;\n    int pos=lower_bound(all(lis),a[u])-lis.begin();\n    if(pos==lis.size()) lis.push_back(a[u]),flag=-1;\n    else flag=lis[pos],lis[pos]=a[u];\n    ans[u]=lis.size();\n    for(auto it:G[u]){\n        if(it==fa) continue;\n        dfs(it,u,lis);\n    }\n    if(flag==-1) lis.pop_back();\n    else lis[pos]=flag;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    a=ans=vector<int>(n+1);\n    for1(i,n) cin>>a[i];\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    vector<int> v{};\n    dfs(1,-1,v);\n    for1(i,n) cout<<ans[i]<<endl;\n    return 0;\n}"},{"id":"CF1280C","title":"Tutorial for Codeforces 1280C/1281E Jeremy Bearimy","content":"SolutionFirst let's minimize the answer. The key observation is that at most one pair passes through the edge . This is because if two or more pair pass that edge, we can pair two vertices in the same side of that edge and get a better answer.Furthermore, the number of pairs that pass through  is , where  the size of the component on a's side.For the maximized answer, the strategy is similar. The observation is that nodes of one component are paired with node of the other component. We can do the reversed thing in the minimized answer to prove this. Thus, each edge is counted  times.Both the maximized answer and the minimized answer can be calculated at the same time in one DFS.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\nvector<vector<pii>> G;\nll mx,mn;\nint n;\nint dfs(int u,int fa){\n    int sz=1;\n    for(auto [to,w]:G[u]){\n        if(to==fa) continue;\n        int csz=dfs(to,u);\n        mx+=(ll)w*min(csz,2*n-csz);\n        mn+=ll(w)*(csz%2);\n        sz+=csz;\n    }\n    return sz;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int   tt;\n    cin>>tt;\n    while(tt--){\n        cin>>n;\n        G=vector<vector<pii>>(2*n+1);\n        mx=mn=0;\n        forn(i,2*n-1){\n            int x,y,z;\n            cin>>x>>y>>z;\n            G[x].pb({y,z});\n            G[y].pb({x,z});\n        }\n        dfs(1,0);\n        cout<<mn<<' '<<mx<<endl;\n    }\n    return 0;\n}"},{"id":"CF1284D","title":"Tutorial for Codeforces 1284D - New Year and Conference","content":"SolutionThe problem can be described as checking if there exists a pair of conferences that overlap in one dimension but not in the other dimension. In order to get all the segments that overlap with each other, we should know for all time points, which segments cover it. Specifically, we need some arrays  and  which store the segments that start at  and close at . So how can we know if there's a pair of segments that doesn't overlap on another dimension? We can maintain two multisets, one is the starting points of the current segments, the other is the end points. If the rightmost starting is bigger than the leftmost end point, this means that there exists a pair of segments that doesn't overlap.Note that we need to compress the time points and check both dimension.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n\ntypedef vector<int> vi;\nbool check(vi& sa,vi& ea,vi& sb,vi& eb,int m){\n    vector<vector<int>> l(m),r(m);\n    int n=sa.size();\n    forn(i,n){\n        l[sa[i]].pb(i);\n        r[ea[i]].pb(i);\n    }\n    multiset<int,greater<int>> lmax;\n    multiset<int> rmin;\n    forn(i,m){\n        for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]);\n        if(!empty(lmax)&& *lmax.begin()> *rmin.begin()) return 0;\n        for(auto id:r[i]){\n            lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id]));\n        }\n    }\n    return 1;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> sa(n),sb(n),ea(n),eb(n);\n    forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]);\n    vector<int> time;time.reserve(4*n);\n    for(auto it:sa) time.pb(it);\n    for(auto it:ea) time.pb(it);\n    for(auto it:sb) time.pb(it);\n    for(auto it:eb) time.pb(it);\n    sort(all(time));\n    time.resize(unique(all(time))-time.begin());\n    forn(i,n){\n        sa[i]=lower_bound(all(time),sa[i])-time.begin();\n        ea[i]=lower_bound(all(time),ea[i])-time.begin();\n        sb[i]=lower_bound(all(time),sb[i])-time.begin();\n        eb[i]=lower_bound(all(time),eb[i])-time.begin();\n    }\n    if(check(sa,ea,sb,eb,time.size())&& check(sb,eb,sa,ea,time.size())) cout<<\"YES\";\n    else cout<<\"NO\";\n\n    return 0;\n}"},{"id":"CF1285C","title":"Solution for Codeforces 1285C - Fadi and LCM","content":"SolutionIt's quite obvious that  and  must be coprime. Now let's prime factorize  and there will be at most 11 distinct primes since the product of the first 12 primes is greater than . To find the answer we can simply distribute them between  and  with bruteforce.Another solution is loop over all divisors  of , check if  is 1 and minimize the answer.CodePrime factorization:#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e12;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tll x;\n    cin>>x;\n    vector<ll> vec;\n    for(ll f=2;f*f<=x;f++){\n        ll tmp=1;\n        while(x%f==0){\n            tmp*=f;\n            x/=f;\n        }\n        if(tmp!=1) vec.pb(tmp);\n    }\n    if(x>1)vec.pb(x);\n    ll aa=INF,ab=INF;\n    for(ll i=0;i<(1<<vec.size());i++){\n        ll a=1,b=1;\n        forn(j,vec.size()){\n            if((i&(1<<j))>0) a*=vec[j];\n            else b*=vec[j];\n        }\n        if(max(a,b)<max(aa,ab)){\n            aa=a;\n            ab=b;\n        }\n    }\n    cout<<ab<<' '<<aa;\n    return 0;\n}Looping factors:#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF=1e15;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tll x;\n    cin>>x;\n    ll ansa=INF,ansb=INF;\n    for(ll f=1;f*f<=x;f++){\n        if(x%f==0){\n            if(__gcd(f,x/f)==1){\n                if(x/f<ansb){\n                    ansa=f;\n                    ansb=x/f;\n                }\n            }\n        }\n    }\n    cout<<ansa<<' '<<ansb;\n    return 0;\n}"},{"id":"CF1285D","title":"Solution for Codeforces 1285D - Dr. Evil Underscores","content":"AlmostSolutionLet's start with the highest bit since it's the most significant. We need to divide elements into two groups, one with elements which is  on this bit and the other with elements which is  on this bit. If either group is empty, we can always assign 0 or 1 to this bit to make this bit 0 in the answer and we can just proceed to the next bit, otherwise this bit is always 1. In order to know which value to assign we will solve the same problem recursively for each of the groups for the next bit. Let the answer for the two groups be  and  and the current bit is  the answer would be .Code#include <bits/stdc++.h>\n\nusing namespace std;\nvector<int> a;\nint dfs(vector<int> v,int idx){\n    if(v.empty()) return 0;\n    if(idx==-1) return 0;\n    vector<int> a,b;\n    for(auto it:v){\n        if(it&(1<<idx)) a.pb(it);\n        else b.pb(it);\n    }\n    if(a.empty()) return dfs(b,idx-1);\n    if(b.empty()) return dfs(a,idx-1);\n    return min(dfs(a,idx-1),dfs(b,idx-1))+(1<<idx);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n    cin>>n;\n    a.resize(n);\n    for(int& it:a) cin>>it;\n    cout<<dfs(a,30);\n    return 0;\n}"},{"id":"CF1286B","title":"Tutorial for Codeforces 1286B/1287D - Numbers on Tree","content":"SolutionFirst, if  is greater than the size of the subtree of node , there's no answer.For each node we build an array containing all the nodes from the its subtree bottom-up, and these nodes are in ascending order of value written on them (i.e. ) even though we don't know the exact value for now. We only care about their relative relationship. The next question is how to combine all the arrays of the children. The answer is quite simple: we can simply glue then together since each subtree is independent. The last step is to put the node in the array. Since we already know , so  should be put in the -th position of the array.Now we have that array containing all the nodes. Let's call it . We can assign  to .Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\n\nvector<vector<int>> G;\nvector<int> c;\nvector<int> dfs(int u){\n    vector<int> order;\n    for(auto it:G[u]){\n        auto child_order=dfs(it);\n        order.insert(order.end(),all(child_order));\n    }\n    if(size(order)<c[u]){\n        cout<<\"NO\";\n        exit(0);\n    }\n    order.insert(order.begin()+c[u],u);\n    return order;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    G.resize(n+1);\n    c.resize(n+1);\n    int R;\n    for1(i,n){\n        int pa;\n        cin>>pa>>c[i];\n        if(pa==0) R=i;\n        G[pa].push_back(i);\n    }\n    auto order=dfs(R);\n    vector<int> ans(n+1);\n    forn(i,n) ans[order[i]]=i+1;\n    cout<<\"YES\\n\";\n    for1(i,n) cout<<ans[i]<<' ';\n    return 0;\n}"},{"id":"CF1288E","title":"Tutorial for Codeforces 1288E - Messenger Simulator","content":"TutorialA faster way to simulate the process is that instead of moving the hole array, we can add some extra space in front of the array and simply move the element to the extra space. For example, in the sample input:5 4\n3 5 1 4The process would look like_ _ _ _ 1 2 3 4 5\n_ _ _ 3 1 2 _ 4 5\n_ _ 5 3 1 2 _ 4 _\n_ 1 5 3 _ 2 _ 4 _\n4 1 5 3 _ 2 _ _ _We can use a fenwick tree to simulate the process: mark a position with 1 if it's occupied by some number and the prefix sum is how many elements is in front of it (i.e. the real position in the simulator). In the end, don't forget to update the position of all the elements in case some are not moved.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... Args> void rd(Args&... args) {((cin >> args), ...);}\ntemplate<typename... Args> void wr(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nstruct fenwick{\n    int n;\n    vector<ll> t;\n    fenwick(int n_):n(n_),t(n+1){}\n    void add(int i,int x){\n        for(i++;i<=n;i+=i&-i){\n            t[i]+=x;\n        }\n    }\n    int query(int i){\n        ll res=0;\n        for(i++;i>0;i-=i&-i) res+=t[i];\n        return res;\n    }\n    int query(int l,int r){\n        return query(r)-query(l-1);\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,m;\n    cin>>n>>m;\n    vector<int> l(n),r(n);\n    iota(all(l),0);\n    r=l;\n    vector<int> pos(n);\n    forn(i,n) pos[i]=i+m;\n    fenwick tree(n+m+1);\n    forn(i,n) tree.add(i+m,1);\n    forn(i,m){\n        int x;\n        cin>>x;\n        x--;\n        l[x]=0;\n        r[x]=max(r[x],tree.query(pos[x]-1));\n        tree.add(pos[x],-1);\n        pos[x]=m-i-1;\n        tree.add(pos[x],1);\n    }\n    forn(i,n) r[i]=max(r[i],tree.query(pos[i]-1));\n    forn(i,n) wr(l[i]+1,r[i]+1);\n    return 0;\n}"},{"id":"CF1294D","title":"Solution for CodeForces 1294D - MEX maximizing","content":"TutorialBy adding  or subtracting , we can obtain any number in the same residue class so we only care about . To maximize the mex, we need to obtain consecutive numbers starting from 0 as many as possible. In the perspective of modular, that means we need . Therefore, we should store the size of each residue class and try to increase the answer when we have a new number.Code#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint q,x;\n\tcin>>q>>x;\n\tvector<int> cnt(x);\n\tint ans=0;\n\twhile(q--){\n\t\tint n;\n\t\tcin>>n;\n\t\tcnt[n%x]++;\n\t\twhile(cnt[ans%x]){\n\t\t\tcnt[ans%x]--;\n\t\t\tans++;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n    return 0;\n}"},{"id":"CF1295D","title":"Solution for CodeForces 1295D - Same GCDs","content":"FMLSolutionLet , so we have ,first observation is that if we want ,  has to be a multiple of , let . Furthermore,  and  have to be coprime, so we need to find how many numbers ranging from  to  are coprime with . For numbers bigger than , if , then . Since , what we actually need to find is the number of numbers that are coprime with  and smaller than , i.e. .Code#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll Phi(ll m){\n\tll ans=m;\n\tfor(ll i=2;i*i<=m;i++){\n\t\tif(m%i==0){\n\t\t\tans-=ans/i;\n\t\t\twhile(m%i==0) m/=i;\n\t\t}\n\t}\n\tif(m>1) ans-=ans/m;\n\treturn ans;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint tt;\n\tcin>>tt;\n\twhile(tt--){\n\t\tll a,m;\n\t\tcin>>a>>m;\n\t\tcout<<Phi(m/gcd(a,m))<<endl;\n\n\t}\n    return 0;\n}"},{"id":"CF1296F","title":"Solution for CodeForces 1296F - Berland Beauty and what I learned","content":"Learned a lot.In this blog I would like to put emphasis on what I learned from other's implementation. The idea is quite simple: for every edge E find the maximum number that appears in the paths that contain E and set that number for E, then check if there's a contradiction. However, the implementation seems to be not easy.I want to talk about two techniques in this code.The first one is how to find the index of the edge that we are visiting.Instead of using  the author uses the lower vertex of each edge to denote that edge and label them when doing the DFS. This reduces both time and space complexity.The second one is how to find the path between two vertices.In a rooted tree, we can find the path by finding the LCA of the two vertices. The algorithm is quite naive: jump up over and over until the two vertices meet. The author uses very short codes to achieve this:while (u != v) {\n    if (dep[u] < dep[v]) swap(u, v);\n    //do something...\n    u = fa[u];\n}Overall, the question is good and what I learned is also amazing which I think is worth writing a blog."},{"id":"CF1300E","title":"Solution for CodeForces 1300E - Water Balance","content":"Monotone stack is such an interest stuff.SolutionTo be honest, I don't really know how to explain the solution clearly. It's kind of a \"greedy\" solution: for each tank, you try to use this to reduce the water in previous tanks. Specifically, you can see water tanks as a succession of groups, if the current group has a smaller average value than the left one, then merge them. The stack is used to store the number of tanks and the sum of water.Code#include <bits/stdc++.h>\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<ll> a(n);\n\tfor(auto& it:a) scanf(\"%lld\",&it);\n\tvector<double> ans(n);\n\tstack<pair<ll,ll>> st;\n\tforn(i,n){\n\t\tll sum=a[i],num=1;\n\t\twhile(!st.empty()&&(1.0*sum/num)<=(1.0*st.top().F/st.top().S)){\n\t\t\tsum+=st.top().F;\n\t\t\tnum+=st.top().S;\n\t\t\tst.pop();\n\t\t}\n\t\tst.push({sum,num});\n\t}\n\tint cnt=n-1;\n\twhile(!st.empty()){\n\t\tfor(int i=0;i<st.top().S;i++,cnt--){\n\t\t\tans[cnt]=1.0*st.top().F/st.top().S;\n\t\t}\n\t\tst.pop();\n\t}\n\tfor(auto it:ans) printf(\"%.9lf\\n\",it);\n\treturn 0;\n}"},{"id":"CF1307D","title":"Solution for CodeForces 1307D - Cow and Fields","content":"SolutionFirst let's use BFS to find the distance from node  and node  to all nodes. Let  be the distance to node  and  be the distance to node .Now we want to choose two nodes  and  such that  is maximized. Without losing generality, assume . That is to say we want to maximize  subject to . So we can sort by  and iterate over  while keeping the maximum value of  before .Also note that the answer cannot be bigger than the distance between node  and .Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n#define de(x) cout<<#x<<\" = \"<<(x)<<endl\n#define de2(x,y) cout<<#x<<\" = \"<<(x) <<' '<< #y<<\" = \"<<y<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconstexpr int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst int N=2e5+5;\nvector<int> G[N];\nvoid bfs(vector<int>& dis,int s){\n\tqueue<int> q;\n\tq.push(s);\n\tdis[s]=0;\n\twhile(!q.empty()){\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int next:G[now]){\n\t\t\tif(dis[next]==INF){\n\t\t\t\tdis[next]=dis[now]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tvector<int> sp(k);\n\tfor(auto& it:sp) cin>>it;\n\tforn(i,m){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tvector<int> dis1(n+1,INF),dis2(n+1,INF);\n\tbfs(dis1,1);\n\tbfs(dis2,n);\n\tvector<pii> data(k);\n\tforn(i,k) data[i]={dis1[sp[i]]-dis2[sp[i]],sp[i]};\n\tsort(all(data));\n\tint best=0,mx=-INF;\n\tfor(auto it:data){\n\t\tint a=it.S;\n\t\tbest=max(best,mx+dis2[a]);\n\t\tmx=max(mx,dis1[a]);\n\t}\n\tcout<<min(dis1[n],best+1);\n\treturn 0;\n}"},{"id":"CF1312D","title":"Solution for CodeForces 1312D - Count the Arrays","content":"My math is sh!t.Adapted from the original tutorial.SolutionFirst of all, there will be  distinct elements in the array and there are ways to choose.Next, there are  elements we could choose to duplicate. Finally, some elements will appear before the maximum and some will appear after. However, the duplicated elements will appear on both sides, so there are  ways to choose their positions.In summary, the answer is .Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define de(x) cout<<#x<<\" = \"<<(x)<<endl\n#define de2(x,y) cout<<#x<<\" = \"<<(x) <<' '<< #y<<\" = \"<<y<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst int mod=998244353;\nll bipow(ll a,int b){\n\tll ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n,m;\n\tcin>>n>>m;\n\tif(n==2) return cout<<0,0;\n\tll ans=1,r=1;\n\tfor1(i,m) ans=ans*i%mod;\n\tfor1(i,n-1) r=r*i%mod;\n\tfor1(i,m-n+1) r=r*i%mod;\n\tans=ans*bipow(r,mod-2)%mod*(n-2)%mod;\n\tans=ans*bipow(2,n-3)%mod;\n\tcout<<ans;\n    return 0;\n}"},{"id":"CF1313C2","title":"Solution for CodeForces 1313C2 - Skyscrapers (hard version)","content":"Time to learn monotone stack.SolutionIt's quite obvious that the answer goes non-decreasing from the start and at some point turns to non-increasing. We want to find the optimal turning point.We can build two arrays  and  of length n. The ith element of  represents the maximum sum of floors from 1 to i if the floors are non-decreasing. Similar definition for . The turning point t is where  is maximum.For example: let 01234pre13675suf57631m12321pre+suf-m58985We can build the arrays by maintaining a mono-increasing stack  to find the rightest number smaller than . The second element is the number of floors and first element is the number of buildings with the same height. You will understand it better in the detailed  buildings process of :i=0nothing in the stack.Push to the stack and now the stack:i=1First set Since , no pop.now Push  to the stack and the stack is now:i=2Similar to i=1.i=3 which means that we need to change the height of previous buildings to keep the monotonicity. Keep popping out the bigger element and  is popped. The  should be decreased by 1*3 and is 3 now. Then the height of 2,3 should be 2 and . Finally we push  to the stack.i=4Similarly, we pop out  and  and  and now . Then the height of 1,2,3,4 should be 1 and . Finally push  to the stack.We could build  in the similar way but go from right to left.Code#include <bits/stdc++.h>\r\n\r\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\r\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\r\n#define F first\r\n#define S second\r\n\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nint main() {\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(nullptr);\r\n\tint n;\r\n\tcin>>n;\r\n\tvector<ll> a(n);\r\n\tfor(auto& it:a) cin>>it;\r\n\tvector<ll> pre(n),suf(n);\r\n\tstack<pair<ll,ll>> stk;\r\n\tforn(i,n){\r\n\t\tint now=1;\r\n\t\tif(i) pre[i]=pre[i-1];\r\n\t\twhile(!stk.empty()&&stk.top().S>a[i]){\r\n\t\t\tnow+=stk.top().F;\r\n\t\t\tpre[i]-=stk.top().F*stk.top().S;\r\n\t\t\tstk.pop();\r\n\t\t}\r\n\t\tpre[i]+=a[i]*now;\r\n\t\tstk.push({now,a[i]});\r\n\t}\r\n\tstk=stack<pair<ll,ll>>();\r\n\tford(i,n){\r\n\t\tint now=1;\r\n\t\tif(i!=n-1) suf[i]=suf[i+1];\r\n\t\twhile(!stk.empty()&&stk.top().S>a[i]){\r\n\t\t\tnow+=stk.top().F;\r\n\t\t\tsuf[i]-=stk.top().F*stk.top().S;\r\n\t\t\tstk.pop();\r\n\t\t}\r\n\t\tsuf[i]+=a[i]*now;\r\n\t\tstk.push({now,a[i]});\r\n\t}\r\n\tll mx=0,pos;\r\n\tforn(i,n){\r\n\t\tif(pre[i]+suf[i]-a[i]>mx){\r\n\t\t\tmx=pre[i]+suf[i]-a[i];\r\n\t\t\tpos=i;\r\n\t\t}\r\n\t}\r\n\tfor(int i=pos-1;i>=0;i--){\r\n\t\ta[i]=min(a[i+1],a[i]);\r\n\t}\r\n\tfor(int i=pos+1;i<n;i++) a[i]=min(a[i-1],a[i]);\r\n\tfor(auto it:a) cout<<it<<' ';\r\n\treturn 0;\r\n}"},{"id":"CF1324F","title":"Solution for CodeForces 1324F - Maximum White Subtree","content":"SolutionThe solution consists of two DFS, first DFS is to calculate : the max difference of the subgraph in subtree of . Note that we treat the graph as a rooted tree, so the subtree means the part that is lower than node . This is pretty naive DFS.The second dfs is to find the answer of each vertex. Since we only considered the contribution of the subtree, we need to add the contribution of other part the graph. How to find this contribution? We always get the answer of higher nodes first. Let  be the children of node , if , the contribution is  since we don't want to count the contribution of subtree twice. If , we don't need to subtract  since we didn't count it in . If , it's useless for . Thus, the contribution of other part is .Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=2e5+5;\nvector<int> G[N];\nint ans[N],a[N],dp[N];\nvoid dfs1(int u,int fa){\n\tdp[u]=a[u];\n\tfor(auto it:G[u]){\n\t\tif(it!=fa){\n\t\t\tdfs1(it,u);\n\t\t\tdp[u]+=max(0,dp[it]);\n\t\t}\n\t}\n}\nvoid dfs2(int u,int fa,int pd){\n\tans[u]=dp[u]+pd;\n\tfor(auto v:G[u]){\n\t\tif(v!=fa){\n\t\t\tdfs2(v,u,max(ans[u]-max(dp[v],0),0));\n\t\t}\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tcin>>n;\n\tfor1(i,n) {\n\t\tcin>>a[i];\n\t\tif(!a[i]) a[i]=-1;\n\t}\n\tforn(i,n-1){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tdfs1(1,-1);\n\tdfs2(1,-1,0);\n\tfor1(i,n) cout<<ans[i]<<' ';\n\treturn 0;\n}"},{"id":"CF1334E","title":"Editorial of Codeforces 1334E - Divisor Paths","content":"SolutionFirst let's factor , so . According to the definition, to factors are connected iff they differ by only one prime factor. And the weight of the edge is  where  is the number of factors of . So the length of a path where  is There are only two types of paths between  and , one is  and the other is . The length of the path of the first type isThe length of the second type isIntuition tells us first type is always the shortest path.All we need now is to calculate the number of shortest paths. Let . The number of shortest path between  and  isSimilarly we can calculate the number of paths between  and .Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate<typename... Args>\nvoid write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nconstexpr ll mod=998244353;\nll binpow(ll a,int b){\n    ll res=1;\n    for(;b;b>>=1){\n        if(b&1) res=res*a%mod;\n        a=a*a%mod;\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ll n;\n    cin>>n;\n    vector<ll> factor;\n    for(ll f=2;f*f<=n;f++){\n        if(n%f==0){\n            factor.push_back(f);\n            while(n%f==0) n/=f;\n        }\n    }\n    if(n>1) factor.push_back(n);\n    array<ll,1000> fac,inv;\n    fac[0]=inv[0]=1;\n    for(int i=1;i<1000;i++) fac[i]=fac[i-1]*i%mod;\n    inv[999]=binpow(fac[999],mod-2);\n    for(int i=998;i>0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n\n    auto count=[&](ll x,ll y){\n        x/=y;\n        ll ret=1,sum=0;\n        for(auto it:factor){\n            int tmp=0;\n            while(x%it==0){\n                tmp++;\n                x/=it;\n            }\n            ret=ret*inv[tmp]%mod;\n            sum+=tmp;\n        }\n        ret=ret*fac[sum]%mod;\n        return ret;\n    };\n    int q;\n    cin>>q;\n    while(q--){\n        ll x,y;\n        cin>>x>>y;\n        ll g=gcd(x,y);\n        cout<<count(x,g)*count(y,g)%mod<<endl;\n    }\n    return 0;\n}"},{"id":"CF1349C","title":"Solution for Codeforces 1349C/1350E - Orac and Game of Life","content":"SolutionLet's call a cell bad if no adjacent cell has the same color, otherwise that cell is good.If a good cell and a bad cell are adjacent, according to the definition, the good cell will change color in the next iteration while the bad cell not. As the result, the bad cell will turn into a good cell. Therefore, a bad cell won't change if all the cells are bad cells, otherwise it will become good when the nearest good cell reaches it. The left thing is to find the nearest good cell for all cells. This can be done using multi-source bfs.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\nconst vector<pii> dir{{1,0,},{-1,0},{0,1},{0,-1}};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,m,t;\n    cin>>n>>m>>t;\n    vector<string> G(n);\n    for(auto& it:G) cin>>it;\n    queue<pii> q;\n    auto cango=[&](int x,int y){\n        return x>=0&&x<n&&y>=0&&y<m;\n    };\n    vector<vector<int>> dis(n,vector<int>(m,-1));\n    forn(i,n){\n        forn(j,m){\n            bool ok=0;\n            for(auto [dx,dy]:dir){\n                int x=i+dx,y=j+dy;\n                if(cango(x,y)&&G[x][y]==G[i][j]) ok=1;\n            }\n            if(ok){\n                dis[i][j]=0;\n                q.emplace(i,j);\n            }\n        }\n    }\n    while(!q.empty()){\n        auto [i,j]=q.front();\n        q.pop();\n        for(auto [dx,dy]:dir){\n            int x=i+dx,y=j+dy;\n            if(cango(x,y)&&dis[x][y]==-1){\n                dis[x][y]=dis[i][j]+1;\n                q.emplace(x,y);\n            }\n        }\n    }\n    while(t--){\n        int i,j;\n        ll p;\n        cin>>i>>j>>p;\n        i--,j--;\n        if(dis[i][j]==-1) cout<<G[i][j]<<endl;\n        else if(dis[i][j]>=p) cout<<((G[i][j]-'0'))<<endl;\n        else cout<<((G[i][j]-'0')^((p-dis[i][j])&1))<<endl;\n    }\n    return 0;\n}"},{"id":"CF1358E","title":"Tutorial for Codeforces 1358E - Are You Fired?","content":"SolutionFirst, let's define the function , i.e. the sum of  consecutive months starting at .Now, let's prove that if  is one answer and , then  is also an answer: . Thus we can always find an answer greater than .Then, consider the case where . If  is an answer, since ,  is also an answer. Thus it's sufficient to check if  is the answer.Lastly, when , we need the help of the prefix sum. Define  and . We want to find a  such that for each , we have:Since , the numbers after the window must be , so the formula can be rewrite as:For each , the corresponding  is , this means if the max value of the LHS is smaller than , then  is a answer.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<ll> a(n);\n    forn(i, (n + 1) / 2) {\n        cin >> a[i];\n    }\n    int x;\n    cin >> x;\n    for (int i = (n + 1) / 2; i < n; i++) a[i] = x;\n    vector<ll> ps(n + 1);\n    partial_sum(all(a), ps.begin() + 1);\n    if (ps.back() > 0) return cout << n, 0;\n    if (x >= 0) return cout << -1, 0;\n    ll N2 = n / 2, N1 = n - N2, sum = ps.back();\n    ll mx = -1e18;\n    for (int i = 0; i <= N1; i++) {\n        mx = max(mx, ps[i] + x * ll(n - i));\n        if (mx < sum + x * ll(n - i)) {\n            cout << n - i;\n            return 0;\n        }\n    }\n    cout << -1;\n    return 0;\n}"},{"id":"CF1367F2","title":"Tutorial for Codeforces 1367F2 - Flying Sort (Hard Version)","content":"Don't be intimidated by the official solution.SolutionFirst let's introduce \"sorted subsequence\": a sorted subsequence is a subsequence that is a subarray of the sorted array. It's easy to see that the unmoved elements form a sorted subsequence. So if we find the longest sorted subsequence, the answer is minimized.Since we only care about the relative order of numbers, we can compress the number which makes it easier to program. Then for each number we make an array storing all the indices of this number.Now let's iterate over each number. If the smallest index of the current number is greater than the biggest index of the previous number, we can simply add all the index to our subsequence. Otherwise, we need to start a new subsequence. There are two things we should notice:Part of the indices of the current number can be added to the old subsequence. E.g. , the second 2 can be added so we have .The new subsequence can also include part of the indices of the previous number. E.g.  we can add the first 1 to the front so we have  .There is one special case: the subsequence consists indices of two numbers and indices of both numbers are incomplete. E.g. , it's easy to see that we need a prefix of the fist number the a suffix of the second number. So we can iterate over each prefix of the first number and find the corresponding suffix of the second number.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define size(x) int(x.size())\n#define pb push_back\n\nusing namespace std;\nusing ll=long long;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt;\n    cin>>tt;\n    for1(T,tt){\n        int n;\n        cin>>n;\n        vector<int> a(n),d(n);\n        forn(i,n){\n            cin>>a[i];\n            d[i]=a[i];\n        }\n        //coord compression \n        sort(all(d));\n        d.resize(unique(all(d))-d.begin());\n        vector<vector<int>> pos(size(d));\n        forn(i,n){\n            a[i]=lower_bound(all(d),a[i])-d.begin();\n            pos[a[i]].push_back(i);\n        }\n\n        int r=-1,mxlen=0,curlen=0;\n        forn(i,size(d)){\n            if(pos[i][0]>r){\n                curlen+=size(pos[i]);\n            }else{\n                //extend to the right for the old sequence\n                auto j=lower_bound(all(pos[i]),r);\n                mxlen=max(mxlen,curlen+int(pos[i].end()-j));\n                //extend to the left for the new sequence\n                auto it=lower_bound(all(pos[i-1]),pos[i][0]);\n                curlen=int(it-pos[i-1].begin())+size(pos[i]);\n            }\n            mxlen=max(mxlen,curlen);\n            r=pos[i].back();\n        }\n        //check the special case: sequence containing only two numbers\n        forn(i,size(d)-1){\n            forn(j,size(pos[i])){\n                auto it=lower_bound(all(pos[i+1]),pos[i][j]);\n                mxlen=max(mxlen,j+1+int(pos[i+1].end()-it));\n            }\n        }\n        cout<<n-mxlen<<endl;\n    }\n    return 0;\n}"},{"id":"CF1369E","title":"Tutorial for Codeforces 1369E - DeadLee","content":"SolutionFirst let's find : the number of friends who love food . For some food , if , we can see that all the friends who love  will have food to eat no matter what order you call them. So we want to call them as late as possible.The solution is like doing a topological sort or BFS: we start from all the  that . When visiting a new vertex , decrease  by one and then if , put  in the queue and put it in the call list. Finally we reverse our call list and that's the answer.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define pb push_back\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,m;\n    cin>>n>>m;\n    vector<int> a(n),deg(n);\n    for(auto& i:a) cin>>i;\n    vector<vector<pii>> G(n);\n    forn(i,m){\n        int x,y;\n        cin>>x>>y;\n        x--,y--;\n        deg[x]++,deg[y]++;\n        G[x].pb({y,i});\n        G[y].pb({x,i});\n    }\n    vector<int> ans;\n    vector<int> vis(m);\n    queue<int> q;\n    forn(i,n){\n        if(deg[i]<=a[i]){\n            q.push(i);\n        }\n    }\n    while(!q.empty()){\n        int u=q.front();\n        q.pop();\n        for(auto [to,i]:G[u]){\n            if(!vis[i]){\n                ans.pb(i+1);\n                vis[i]=1;\n                deg[to]--;\n                if(deg[to]<=a[to]) q.push(to);\n            }\n        }\n    }\n    if(sz(ans)!=m) return cout<<\"DEAD\",0;\n    reverse(all(ans));\n    cout<<\"ALIVE\\n\";\n    for(auto it:ans) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF1407D","title":"Tutorial for CodeForces 1407D","content":"SolutionFirst let's consider the case where .  could be lower or higher than . There can be multiple  that satisfies the condition and we can observe the leftmost  is the first that , let's denote this , other  between  must satisfy that  is the maximum value among . This can be solved using monotonic stack. Assume we store the indices in the stack, when adding a new index , all the indices that will be removed are a valid position to jump to , so we can do dp and update the minimum number of moves. The time complexity is .The second case is similar.Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> a(n);\n    for(auto& it:a) cin>>it;\n    vector<int> dp(n,n);\n    dp[0]=0;\n    vector<int> h{0},l{0};\n    for(int i=1;i<n;i++){\n        dp[i]=min(dp[i],dp[i-1]+1);\n        while(!h.empty()&&a[i]>=a[h.back()]){\n            int x=a[h.back()];\n            h.pop_back();\n            if(a[i]>x&&!h.empty()) dp[i]=min(dp[i],dp[h.back()]+1);\n        }\n        while(!l.empty()&&a[i]<=a[l.back()]){\n            int x=a[l.back()];\n            l.pop_back();\n            if(a[i]<x&&!l.empty()) dp[i]=min(dp[i],dp[l.back()]+1);\n        }\n        h.push_back(i);\n        l.push_back(i);\n    }\n    cout<<dp[n-1];\n    return 0;\n}"},{"id":"CF205C","title":"Solution for Codeforces 205D - Little Elephant and Interval","content":"SolutionIt's kinda obvious that we need to write a function  which solves the problem  and the answer will be .One tricky way to write  is that we can get the required number by appending the first digit to the end of an arbitrary number. If x is less than 10, the answer is x, otherwise the answer is x without last digit (divide x by 10) plus 9. What's more, if the last digit is smaller than the first digit we have to decrease the answer by 1.Code#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll cal(ll x){\n\tif(x<10) return x;\n\tstring st=to_string(x);\n\tll ans=9;\n\tif(st[0]>st.back()) ans--;\n\tans+=x/10;\n\treturn ans;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tll l,r;\n\tcin>>l>>r;\n\tcout<<cal(r)-cal(l-1);\n    return 0;\n}"},{"id":"CF208B","title":"Solution for Codeforces 208B - Solitaire","content":"SolutionIn this problem, we could use DFS with memorization, the state is the following four elements: the number of left piles, the top cards on the three rightmost piles. If we could have one pile in the end, the answer is yes. BFS also works for this problem using the same state which might be more intuitive.Code#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=60;\nstring s[N];\nint dp[N][N][N][N];\nbool dfs(int n,int i,int j,int k){\n\tif(n==0) return true;\n\tint& d=dp[n][i][j][k];\n\tif(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false;\n\tif(s[i][0]==s[j][0]||s[i][1]==s[j][1]){\n\t\tif(dfs(n-1,i,k,n-3)){\n\t\t\treturn d=1;\n\t\t}\n\t}\n\tif(n>=3&&(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){\n\t\tif(dfs(n-1,j,k,i)){\n\t\t\treturn d=1;\n\t\t}\n\t}\n\td=-1;\n\treturn false;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n\tcin>>n;\n\tforn(i,n) cin>>s[i];\n\tcout<<(dfs(n-1,n-1,n-2,n-3)?\"YES\":\"NO\");\n    return 0;\n}"},{"id":"CF486D","title":"Tutorial for Cdoeforces 486D - Valid Sets","content":"SolutionFirstly, let's ignore the third condition for now. Consider the tree is rooted at node 1. Let  be the number of valid sets contain node  and other nodes in the subtree of . This can be easily calculated using a dfs: Now consider the third condition. We can set each node to be the smallest value in the valid set respectively. After setting the smallest value, start dfs from node  and only visit nodes  such that . In this case, the third condition is satisfied so we can calculate the answer using the formula above. Also be careful with the duplicate counting, i.e. if , only visit node  such that .Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\nvector<int> a;\nvector<vector<int>> G;\nint d,n;\nconst int mod=1e9+7;\nint dfs(int u,int root,int fa){\n    int sz=1;\n    for(auto to:G[u]){\n        if(to==fa) continue;\n        if(a[to]<a[root]||a[to]>a[root]+d) continue;\n        if(a[to]==a[root]&&to<root) continue;\n        sz=ll(sz)*(dfs(to,root,u)+1)%mod;\n    }\n    return sz;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>d>>n;\n    G.resize(n+1);\n    a.resize(n+1);\n    for1(i,n) cin>>a[i];\n    forn(i,n-1){\n        int x,y;\n        cin>>x>>y;\n        G[x].pb(y);\n        G[y].pb(x);\n    }\n    int ans=0;\n    for1(i,n){\n        ans=(ans+dfs(i,i,0))%mod;\n    }\n    cout<<ans;\n    return 0;\n}"},{"id":"CF56E","title":"Tutorial for Codeforces 56E - Domino Principle","content":"SolutionEach element in the stack represents a consecutive group of dominos such that if one domino can reach , all the dominos starting from the i-th position until the next group will fall. So when we move to a new domino, we should firstly pop out all the domino that within the reach of the current domino. Then the top domino would be the closest domino that won't fall if we pull of the current domino, i.e. the answer for the current domino.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\nusing pii= pair<int, int>;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<int> x(n),h(n),id(n);\n    iota(all(id),0);\n    forn(i,n){\n        cin>>x[i]>>h[i];\n    }\n    sort(all(id),[&](int a,int b){return x[a]<x[b];});\n    vector<int> ans(n);\n    stack<pii> stk;\n    stk.push({1e9,n});\n    for(int i=n-1;i>=0;i--){\n        int ii=id[i];\n        while(!stk.empty()&&x[ii]+h[ii]>stk.top().F) stk.pop();\n        ans[ii]=(stk.empty()?1:stk.top().S-i);\n        stk.push({x[ii],i});\n    }\n    for(auto it:ans) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF650B","title":"Tutorial for Codeforces 650B/651D Image Preview","content":"SolutionIt's obvious that the images we opened is a sub-segment of all images. We can loop over all the possible left endpoints and use two pointers to find the rightmost endpoint.Code#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,a,b,T;\n    string s;\n    rd( n,a,b,T,s);\n    int ans=0;\n    vector<ll> t(2*n);\n    forn(i,n){\n        t[i]=t[i+n]=(s[i]=='w'?b+1:1);\n    }\n    for(int i=1;i<2*n;i++) t[i]+=t[i-1];\n    int r=n;\n    auto f=[&](int l,int r){\n        ll res=t[r]-t[l-1];\n        ll di=r-l+min(r-n,n-l);\n        return res+di*a;\n    };\n    for(int l=1;l<=n;l++){\n        while(r+1<l+n&&f(l,r+1)<=T) r++;\n        if(f(l,r)<=T) ans=max(ans,r-l+1);\n    }\n    cout<<ans;\n    return 0;\n}"},{"id":"CF689D","title":"Tutorial for Codeforces - Friends and Subsequences","content":"SolutionThe key observation is that if we fix  then we have . So we can use binary search to find the min and the max value  such that  and add max-min+1 to the answer. We need a RMQ data structure and sparse table can do this in  per query.Also this can be done using monotone queue but I haven't figured it out.Code#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\n\nstruct sparse{\n    int logn;\n    vector<vector<int>> f,g;\n    sparse(int n){\n        logn=__lg(n);\n        f=g=vector(n,vector(logn+1,0));\n        for(int i=0;i<n;i++) cin>>f[i][0];\n        for(int i=0;i<n;i++) cin>>g[i][0];\n        for (int j = 1; j <= logn; j++)\n            for (int i = 0; i + (1 << j) - 1 < n; i++){\n                f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);\n                g[i][j] = min(g[i][j - 1], g[i + (1 << (j - 1))][j - 1]);\n            }\n    }\n    int geta(int x,int y){\n        int s = __lg(y - x + 1);\n        return max(f[x][s], f[y - (1 << s) + 1][s]);\n    }\n    int getb(int x,int y){\n        int s = __lg(y - x + 1);\n        return min(g[x][s], g[y - (1 << s) + 1][s]);\n    }\n\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    sparse st(n);\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        int l=i,r=n-1;\n        while(l<=r){\n            int mid=(l+r)/2;\n            if(st.geta(i,mid)<st.getb(i,mid)) l=mid+1;\n            else r=mid-1;\n        }\n        int left=r;\n        l=i,r=n-1;\n        while(l<=r){\n            int mid=(l+r)/2;\n            if(st.geta(i,mid)<=st.getb(i,mid)) l=mid+1;\n            else r=mid-1;\n        }\n        ans+=r-left;\n    }\n    cout<<ans;\n    return 0;\n}"},{"id":"CF733D","title":"Solution for CodeForces 733D - Kostya the Sculptor","content":"SolutionWLOG, assume . If we choose only one stone, the diameter of the sphere is . If we want to choose two stones, we should find another stone whose two of its edges are  and , since we must expand the shortest side to get a bigger sphere. We can use a set to maintain the length of the edge and the index.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate<typename... Args>\nvoid write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n;\n    cin>>n;\n    vector<int> ans;\n    int best=0;\n    map<pii,pii> mp;\n    for1(i,n){\n        int a[3];\n        forn(i,3) cin>>a[i];\n        sort(a,a+3);\n        if(a[0]>best){\n            ans={i};\n            best=a[0];\n        }\n        if(mp.count({a[1],a[2]})){\n            auto p=mp[{a[1],a[2]}];\n            int now=min({a[1],a[2],a[0]+p.F});\n            if(now>best){\n                best=now;\n                ans={i,p.S};\n            }\n        }\n        mp[{a[0],a[1]}]=max(mp[{a[0],a[1]}],{a[2],i});\n        mp[{a[0],a[2]}]=max(mp[{a[0],a[2]}],{a[1],i});\n        mp[{a[1],a[2]}]=max(mp[{a[1],a[2]}],{a[0],i});\n    }\n    cout<<ans.size()<<endl;\n    for(auto it:ans) cout<<it<<' ';\n    return 0;\n}"},{"id":"CF743D","title":"Solution for Codeforces 743D - Chloe and pleasant prizes","content":"Good DFS problem.SolutionWe need to calculate (sum of all the numbers in the subtree of vertex ) and  and  (the maximum and second maximum from all  in the subtree of vertex  except ). Update answer after calculating  and  for each vertex. This can be done using one DFS, refer to my code for the detailed implementation.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e18+1;\ntypedef pair<int, int> pii;\n\nconst int N=2e5+5;\nvector<int> G[N];\nll a[N],sum[N],mx[N];\n\nll ans=-INF;\nvoid dfs1(int v,int p){\n    sum[v]=a[v];\n    mx[v]=-INF;\n    ll m1=-INF,m2=-INF;\n    for(auto it:G[v]){\n        if(it==p) continue;\n        dfs1(it,v);\n        sum[v]+=sum[it];\n        mx[v]=max(mx[v],mx[it]);\n        ll val=mx[it];\n        if(val>m1) swap(m1,val);\n        if(val>m2) swap(m2,val);\n    }\n    if(m2> -INF) ans=max(ans,m1+m2);\n    mx[v]=max(mx[v],sum[v]);\n    return;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\tint n;\n    cin>>n;\n    for1(i,n){\n        cin>>a[i];\n    }\n    forn(i,n-1){\n        int u,v;\n        cin>>u>>v;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    dfs1(1,1);\n    if(ans==-INF) cout<<\"Impossible\";\n    else cout<<ans;\n    return 0;\n}"},{"id":"CF747D","title":"Tutorial for Codeforces 747D - Winter Is Coming","content":"SolutionFirst, let's force Vasya to change tire on everyday with negative temperature (even on consecutive days) so she will change tire for  time where  is the number of days with negative temperature. If  obviously the answer is -1, otherwise the winter tire can still last for some extra days. Now let's see if we can use the winter tire on days with non-negative temperature. We can sort all the length of the consecutive days with non-negative temperature, so we can greedily use winter tires on those segments. For each segment we use, we save tire change twice. Finally let's see if we can use the winter tire until the last day after the last negative-temperature day.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... Args> void rd(Args&... args) {((cin >> args), ...);}\ntemplate<typename... Ar> void wr(Ar... ar) {((cout<<ar<<\" \"),...);cout<<endl;}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,k;\n    cin>>n>>k;\n    vector<int> a(n),neg;\n    forn(i,n){\n        cin>>a[i];\n        if(a[i]<0) neg.push_back(i);\n    }\n    if(neg.empty()) return cout<<0,0;\n    if(neg.size()>k) return cout<<-1,0;\n    vector<int> xs;\n    for(int i=1;i<(int)size(neg);i++) xs.push_back(neg[i]-neg[i-1]-1);\n    sort(all(xs));\n    int ans=int(size(neg))*2;\n    k-=size(neg);\n    for(auto i:xs){\n        if(k>=i){\n            k-=i;\n            ans-=2;\n        }else break;\n    }\n    if(n-neg.back()-1<=k) ans--;\n    cout<<ans;\n    return 0;\n}"},{"id":"CF762D","title":"Tutorial for Codeforces 762D - Maximum Path","content":"SolutionThe problem would be a standard dp problem if we can't go to the left. So we need to handle that extra case. However, we can observe that we don't need to go more than one cell to the left. Here is a quick proof:\nSo we only need to consider two more transition. Here is all the transition:Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\nvoid inline cmax(ll& a,ll b){\n    if(b>a) a=b;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    vector<vector<ll>> a(n+2,vector<ll>(3)),dp(n+2,vector<ll>(3,-1e18));\n    forn(j,3) for1(i,n) cin>>a[i][j];\n    dp[0][0]=0;\n    for(int i=1;i<=n;i++){\n        cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]);\n        cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]);\n        cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]);\n        cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]);\n        cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]);\n    }\n    cout<<dp[n][2];\n    return 0;\n}"},{"id":"CF762E","title":"Tutorial for Codeforces 762E - Radio stations","content":"SolutionIterate over each frequency. Suppose now we are on frequency . Put all stations with frequency  in the  vector and all radio stations with frequency  into the  vector.Now we want to calculate the number of pairs such that the left radio station is from the  vector and the right station is from  vector.Sort the  vector by position and sort the  vector by the left bound of the stations' range. Iterator the stations in the  vector and put all the stations in the  vector which can reach the current station in the axis(actually we need to put them in some data structure). Now we need to know how many stations in the axis can be reached by the current station. This can be done with some range-sum-query data structure(like fenwick tree): we add one on the position for each new station and use range query to find the stations we want. However, since the positions are up to  we also need to compress the coordinate, which is really annoying, so a simpler way to do this is to use a balanced BST in pb_ds library to find the order directly.The lesson learnt is that when we want to find the order, especially with coordinate compression, consider pb_ds.Code#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\nusing namespace __gnu_pbds;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\nusing ordered_set = tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,k;\n    cin>>n>>k;\n    vector<pii> fre[10005];\n    forn(i,n){\n        int x,r,f;\n        cin>>x>>r>>f;\n        fre[f].pb({x,r});\n    }\n    ll ans=0;\n    auto solve=[&](vector<pii>& left,vector<pii>& right){\n        sort(all(left));\n        sort(all(right),[](pii a,pii b){return a.F-a.S<b.F-b.S;});\n        ll res=0;\n        int i=0;\n        ordered_set tree;\n        for(auto it:left){\n            while(i<right.size()&&right[i].F-right[i].S<=it.F){\n                tree.insert(right[i].F);\n                i++;\n            }\n            res+=tree.order_of_key(it.F+it.S+1)-tree.order_of_key(it.F+1);\n        }\n        return res;\n    };\n    for(int i=1;i<=1e4;i++){\n        if(fre[i].empty()) continue;\n        vector<pii> left(all(fre[i])),right;\n        for(int j=max(1,i-k);j<=i+k&&j<=10000;j++){\n            right.insert(right.end(),all(fre[j]));\n        }\n        ans+=solve(left,right);\n    }\n    cout<<ans;\n    return 0;\n}"},{"id":"CF802I","title":"Tutorial for Codeforces 801I - Fake News (hard)","content":"SolutionConsider the contribution to the answer of the each occurrence of each substring. Suppose this substring has appeared  times. For a new occurrence of this substring, the answer would change from  to , that is to say, each new occurrence contributes  to the answer. Since there are  substrings, the answer is at least  , now what we left is to focusing on finding the occurrence of the substrings. You will see why it's more handy to do this.Let's build the suffix array and the LCP array first. You will notice that the occurrence of some substring is a subsegment in the suffix array. so is it in the LCP array and the min value of the subsegment in the LCP array is the length of that substring. We can process each of the LCP value in the descending order. This is because each LCP value  can represent  substrings, so if we process them in the descending order, we can assure that all the substrings have appeared before."},{"id":"CF813E","title":"Solution for CodeForces 813E - Army Creation","content":"Interesting technique.SolutionWe create an auxiliary array  where  is the index of the next -th occurrence of , or   if such occurrence doesn't exist. For example, the auxiliary array of the example input should be .Consider query , for , if , this means that there are more than  occurrences of  after  so  should not be in the army. Thus the answer to the query is . Finding the number of elements in a range that are smaller than  is a classic problem that can be solved with persistent segment tree or wavelet tree.Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct PST {\n    int n, tot=0;\n    vector<int> lc, rc, sum, roots; // left child, right child\n    PST(int n_) : n(n_), lc(n<<5), rc(n<<5), sum(n<<5), roots(1) {\n        build(0, n-1, roots[0]);\n    }\n    void pushup(int rt) {\n        sum[rt] = sum[lc[rt]] + sum[rc[rt]];\n    }\n    void build(int l, int r, int& rt) {\n        rt = ++tot;\n        if (l == r) return;\n        int mid = (l + r) >> 1;\n        build(l, mid, lc[rt]);\n        build(mid + 1, r, rc[rt]);\n        pushup(rt);\n    }\n    void update(int pos, int val, int l, int r, int old, int& rt) {\n        rt = ++tot;\n        lc[rt] = lc[old];\n        rc[rt] = rc[old];\n        if (l == r) {\n            sum[rt] = sum[old] + val;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        if (pos <= mid) update(pos, val, l, mid, lc[old], lc[rt]);\n        else update(pos, val, mid + 1, r, rc[old], rc[rt]);\n        pushup(rt);\n    }\n    int update(int pos, int val) { // return the root of the new version\n        int new_root;\n        update(pos, val, 0, n-1, roots.back(), new_root);\n        roots.push_back(new_root);\n        return new_root;\n    }\n    int query(int u, int v, int l, int r, int k) {\n        if (l==r) return sum[v]-sum[u];\n        int mid=(l+r)/2, x=sum[lc[v]]-sum[lc[u]];\n        if (mid<k) return x+query(rc[u], rc[v], mid+1, r, k);\n        return query(lc[u], lc[v], l, mid, k);\n    }\n    int query(int u, int v, int k) {\n        return query(u, v, 0, n-1, k);\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin>>n>>k;\n    constexpr int M=1e5;\n    vector<vector<int>> pos(M);\n    vector<int> a(n, n);\n    for (int i=0; i<n; i++) {\n        int x;\n        cin>>x;\n        pos[x].push_back(i);\n        if (pos[x].size()>k) {\n            a[*(pos[x].rbegin()+k)]=i;\n        }\n    }\n    int last=0;\n    vector<int> roots(n+1);\n    roots[0]=1;\n    PST tr(n+1);\n    for (int i=0; i<n; i++) {\n        roots[i+1]=tr.update(a[i], 1);\n    }\n    int q;\n    cin>>q;\n    while (q--) {\n        int x, y;\n        cin>>x>>y;\n        int l=(x+last)%n, r=(y+last)%n;\n        if (l>r) swap(l, r);\n        last=(r-l+1)-tr.query(roots[l], roots[r+1], r);\n        cout<<last<<'\\n';\n    }\n    return 0;\n}"},{"id":"GYM101981J","title":"Solution for Gym101981J  - Prime Game","content":"problem linkTo solve this problem, we need to count for each prime factors, how many intervals include them.First, let's assume that all factors are distinct i.e. all factors only appears at one position. In this case, it's easy to count the intervals that include them. For all primes at , there are  intervals including them.However, one prime can appear multiple times so we need to substract the repeated intervals(interval contain the current position and last position). Formally, if a prime appears at  and lastly appears at , it adds  to answer.So our strategy is calculating all primes less than 1e6 first. Go through all the numbers and find their prime factors. Record the all appearance of each factor and calculate their contributions to the answer.code:#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n\n#define endl '\\n'\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MAXN=1e6+5;\nint pri[MAXN],vis[MAXN],cnt=0;\nvector<int> pos[MAXN];\nvoid init() {\n    for (int i = 2; i < MAXN; ++i) {\n        if (!vis[i]) pri[cnt++] = i;\n        for (int j = 0; j <cnt; ++j) {\n            if (1ll * i * pri[j] >= MAXN) break;\n            vis[i * pri[j]] = 1;\n            if (i % pri[j]==0) break; \n        }\n    }\n    forn(i,cnt) pos[pri[i]].pb(0);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin>>n;\n    vector<int> a(n+1);\n    for1(i,n) cin>>a[i];\n    init();\n    for1(i,n){\n\t\tfor(int j=0;pri[j]*pri[j]<=a[i];j++){\n\t\t\tif(a[i]%pri[j]==0){\n\t\t\t\tpos[pri[j]].pb(i);\n\t\t\t\twhile(a[i]%pri[j]==0) a[i]/=pri[j];\n\t\t\t}\n\t\t}\n\t\tif(a[i]>1) pos[a[i]].pb(i);\n\t}\n    ll ans=0;\n\tforn(i,cnt){\n\t\tfor(int j=1;j<pos[pri[i]].size();j++)\n\t\t\tans+=ll(pos[pri[i]][j]-pos[pri[i]][j-1])*(n-pos[pri[i]][j]+1);\n\t\t\t\n\t}\t\t\n\tcout<<ans;\n    return 0;\n}"},{"id":"GYM101981M","title":"Tutorial 2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M - Mediocre String Problem","content":"SolutionFirst, count how many palindromes begin with  and let the number be .Then, find the maximum length  such that  for each k = 1, 2, ..., d and let the length be .The answer should be .The first part can be solved using manacher algorithm, and the second part is equivalent to calculate the longest common prefix (LCP) for every suffix of the reversed string   with , which can be solved using Z algorithm.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define F first\n#define S second\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n#define pb push_back\n\nusing namespace std;\nusing ll=long long;\n\nvector<int> manacher(const string ss){\n    string s;\n    for(auto ch:ss) s+=\"#\",s+=ch;\n    s+=\"#\";\n    int n=(int)s.size();\n    vector<int> d1(n);\n    for (int i = 0, l = 0, r = -1; i < n; i++) {\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i);\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\n            k++;\n        }\n        d1[i] = k--;\n        if (i + k > r) {\n            l = i - k;\n            r = i + k;\n        }\n    }\n    return d1;\n}\n\nvector<int> z_function(const string s) {\n    int n = (int)s.size();\n    vector<int> z(n);\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\n        if (i <= r) z[i] = min(r - i + 1, z[i - l]);\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];\n        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;\n    }\n    return z;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s,t;\n    cin>>s>>t;\n    auto man=manacher(s);\n    vector<int> f(sz(s));\n    for(int i=1;i<sz(man)-1;i++){\n        int l=(i-man[i]+1)/2,r=(i-1)/2;\n        f[l]++;\n        if(r<sz(s)-1) f[r+1]--;\n    }\n    partial_sum(all(f),f.begin());\n    reverse(all(s));\n    auto g=z_function(t+\"#\"+s);\n    g.erase(g.begin(),g.begin()+sz(t)+1);\n    reverse(all(g));\n    g.erase(g.end()-1);\n    g.insert(g.begin(),0);\n    ll ans=0;\n    forn(i,sz(s)) ans+=ll(f[i])*g[i];\n    cout<<ans;\n    return 0;\n}"},{"id":"GYM102428F","title":"Solution for Gym 102428F - Fabricating Sculptures","content":"Such an elegant and amazing solution.SolutionFirst we can ignore first level of blocks. Let  be the number of ways to put  blocks on  stacks(some stacks could be empty).Now let's consider transition, there are three cases:The first level is fullThe leftmost stack is emptyThe rightmost stack is emptyFor the first case we can simply ignore the first level and the number of ways\nis . For the second and the third case, we can ignore the empty\nstack and the answer is . However, the two cases overlap,\nsince the scenario where both the leftmost and the rightmost stacks are empty\ncan be reached from both cases. So we need to subtract . Overall,\nthe formula is:This can be calculated recursively with memoization.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define fore(i, l, r) for (int i = int(l); i <= int(r); ++i)\n#define ford(i, n) for (int i = int(n)-1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\ntemplate<typename... Args>\nvoid write(Args... args) { ((cout << args << \" \"), ...); cout<<endl;}\n\nconst int N=5e3+5;\nll dp[N][N];\nconst int mod=1e9+7;\nll solve(int s,int b){\n    if(b==0) return 1;\n    if(s<=0) return 0;\n    ll& ret=dp[s][b];\n    if( ret) return ret;\n    ret=0;\n    if(s<=b) ret=solve(s,b-s);\n    ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod;\n    return ret;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int s,b;\n    cin>>s>>b;\n    cout<<solve(s,b-s);\n    return 0;\n}"},{"id":"GYM102843J","title":"Tutorial for 2020 CCPC Changchun Onsite J (GYM102832J) - Abstract Painting","content":"Easy to think but hard to write.SolutionSince the radius of a circle is at most 5, we only need to check the status of 10 blocks before it, which could be represented as a binary number. Let  be the number of ways to draw circles whose right boundary is , with mask of . Here if the k-th bit of the mask is 1, it means that you can put a circle whose left boundary is .For a fixed right boundary, there are 5 possible positions for center, so  circle combinations. So our strategy is that for each position, we check  masks and  circle combinations, then transition if possible.In order to make coding easier, we could calculate some helper array:  is the mask for the left boundary of the corresponding center mask, all the bits in  to the right of the highest bit of  is set to 1 to make positions inside the circle unavailable for the next position.CodeCredits#include <bits/stdc++.h>\n\n#define all(x) (x).begin(),(x).end()\n#define sz(x) int(x.size())\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<typename... T> void rd(T&... args) {((cin>>args), ...);}\ntemplate<typename... T> void wr(T... args) {((cout<<args<<\" \"), ...);cout<<endl;}\n\nconstexpr int mod=1e9+7;\nll dp[1010][1<<10];\nint already[1010];\nint le[32], mhi[32];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    cin>>n>>k;\n    for (int i=0; i<k; i++) {\n        int c, r;\n        cin>>c>>r;\n        already[c+r]|=(1<<(r-1));\n    }\n\n    for (int i=0; i<32; i++) {\n        for (int j=0; j<5; j++) {\n            if (i>>j&1) {\n                le[i]|=(1<<(2*j+1));\n                mhi[i]=(1<<(2*j+1))-1;\n            }\n        }\n    }\n    dp[0][0]=1;\n    for (int i=0; i<=n; i++) {\n        for (int mask=0; mask<1024; mask++) {\n            if (!dp[i][mask]) continue;\n            for (int k=0; k<32; k++) {\n                if ((already[i]&k) != already[i]) continue;\n                if ((mask & le[k]) != le[k]) continue;\n                int nxt=mask-(mask & mhi[k]);\n                nxt=(2*nxt+1)&1023;\n                (dp[i+1][nxt]+=dp[i][mask])%=mod;\n            }\n        }\n\n    }\n    ll ans=0;\n    for (int i=0; i<1024; i++) (ans+=dp[n+1][i])%=mod;\n    cout<<ans;\n    return 0;\n}"},{"id":"HDU5592","title":"Solution for HDU 5592 - ZYB's Premutation","content":"Problem LinkSolutionLet the input be  and the answer be .  is the number of numbers that are greater than , so we can also know the how many numbers are smaller than . Now we build a segment tree which counts the occurrence of numbers in  and iterate  reversely, we could know how many unused numbers are smaller than  and then find the corresponding number in the segtree and decrease the occurrence of that number by one.Code#include <bits/stdc++.h>\n\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\nusing namespace std;\n\nconst int N=5e4+5;\nint sum[N<<2];\nvoid build(int k,int l,int r){\n\tsum[k]=r-l+1;\n\tif(l==r) return;\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n}\nint query(int root,int l,int r,int p){\n\tsum[root]--;\n\tif(l==r) return l;\n\tint mid=(l+r)>>1;\n\tif(sum[root<<1]>=p) return query(root<<1,l,mid,p);\n\telse return query(root<<1|1,mid+1,r,p-sum[root<<1]);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint tt;\n\tcin>>tt;\n\twhile(tt--){\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int> a(n+1),ans(n+1);\n\t\tfor1(i,n) cin>>a[i];\n\t\tbuild(1,1,n);\n\t\tfor(int i=n;i>0;i--){\n\t\t\tint p=a[i]-a[i-1];\n\t\t\tp=i-p;\n\t\t\tans[i]=query(1,1,n,p);\n\t\t}\n\t\tfor1(i,n) cout<<ans[i]<<(i==n?'\\n':' ');\n\t}\n    return 0;\n}"},{"id":"HDU6278","title":"Editorial for HDU6278 - Just h-index","content":"SolutionUsing persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this:\nint l=0,r=INF;\nwhile(l<=r){\n    int mid=(l+r)>>1;\n    if(occurrence_of_numbers_bigger_than(mid)>=mid) l=mid+1;\n    else r=mid-1;\n}\ncout<<r<<endl;Time complexity is , which suffices but we can still optimize it.In fact, the binary search part could be done during the query on the segment tree. First let's make some notation: let  be the interval of the query,  be the current interval on the segment tree,  be the number of occurrence of numbers ranged in. The sudo code of the query function would look like this:int query(int l,int r,int s){\n    int mid=(l+r)>>1;\n    int cnt=occurrence_of_number_from_mid_to_r();\n    if(cnt+s>=mid+1) return query(mid+1,r,s);//the (mid,y] has more numbers than we need, so the answer must be in the right part\n    return query(l,mid,s+cnt);//the numbers in the right part is not enough, so the answer is in the left part.\n}Now the time complexity is . Please refer to the code in the end for the better understanding of the implementation.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nstruct PerSegTree {\n    vector<int> lson, rson, sum, root;\n    int tot;\n    PerSegTree(int n) {\n        lson = rson = sum = vector<int>(n << 5);\n        root = vector<int>(n + 1);\n        tot = 0;\n    }\n    void pushup(int rt) {\n        sum[rt] = sum[lson[rt]] + sum[rson[rt]];\n    }\n    void build(int l, int r, int& rt) {\n        rt = ++tot;\n        if (l == r) return;\n        int mid = (l + r) >> 1;\n        build(l, mid, lson[rt]);\n        build(mid + 1, r, rson[rt]);\n        pushup(rt);\n    }\n    void update(int pos, int val, int l, int r, int ord, int& rt) {\n        rt = ++tot;\n        lson[rt] = lson[ord];\n        rson[rt] = rson[ord];\n        if (l == r) {\n            sum[rt] = sum[ord] + val;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        if (pos <= mid) update(pos, val, l, mid, lson[ord], lson[rt]);\n        else update(pos, val, mid + 1, r, rson[ord], rson[rt]);\n        pushup(rt);\n    }\n    int query(int pos, int l, int r, int lrt, int rrt) {\n        if (l == r) return sum[rrt] - sum[lrt];\n        int mid = (l + r) >> 1;\n        if (pos <= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]);\n        return query(pos, mid + 1, r, rson[lrt], rson[rrt]);\n    }\n};\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,q;\n    while(cin>>n>>q){\n        PerSegTree tree(n);\n        tree.build(1,n,tree.root[0]);\n        for1(i,n){\n            int x;\n            cin>>x;\n            tree.update(x,1,1,n,tree.root[i-1],tree.root[i]);\n        }\n        while(q--){\n            int x,y;\n            cin>>x>>y;\n            int l=0,r=1e5;\n            while(l<=r){\n                int mid=(l+r)>>1;\n                int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]);\n                if(ans>=mid) l=mid+1;\n                else r=mid-1;\n            }\n            cout<<r<<endl;\n        }\n    }\n    return 0;\n}#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define ms(a, x) memset(a, x, sizeof(a))\n#define F first\n#define S second\n#define endl '\\n'\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nstruct PerSegTree {\n    vector<int> lson, rson, sum, root;\n    int tot;\n    PerSegTree(int n) {\n        lson = rson = sum = vector<int>(n << 5);\n        root = vector<int>(n + 1);\n        tot = 0;\n    }\n    void pushup(int rt) {\n        sum[rt] = sum[lson[rt]] + sum[rson[rt]];\n    }\n    void build(int l, int r, int& rt) {\n        rt = ++tot;\n        if (l == r) return;\n        int mid = (l + r) >> 1;\n        build(l, mid, lson[rt]);\n        build(mid + 1, r, rson[rt]);\n        pushup(rt);\n    }\n    void update(int pos, int val, int l, int r, int ord, int& rt) {\n        rt = ++tot;\n        lson[rt] = lson[ord];\n        rson[rt] = rson[ord];\n        if (l == r) {\n            sum[rt] = sum[ord] + val;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        if (pos <= mid) update(pos, val, l, mid, lson[ord], lson[rt]);\n        else update(pos, val, mid + 1, r, rson[ord], rson[rt]);\n        pushup(rt);\n    }\n    int query(int l, int r, int old_rt, int rt,int s) {\n        if(l==r) return l;\n        int mid=(l+r)>>1;\n        int cnt=sum[rson[rt]]-sum[rson[old_rt]];\n        if(mid<cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s);\n        return query(l,mid,lson[old_rt],lson[rt],s+cnt);\n    }\n};\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,q;\n    while(cin>>n>>q){\n        PerSegTree tree(n);\n        tree.build(1,n,tree.root[0]);\n        for1(i,n){\n            int x;\n            cin>>x;\n            tree.update(x,1,1,n,tree.root[i-1],tree.root[i]);\n        }\n        while(q--){\n            int x,y;\n            cin>>x>>y;\n            cout<<tree.query(1,n,tree.root[x-1],tree.root[y],0)<<endl;\n        }\n    }\n    return 0;\n}"},{"id":"HDU6602","title":"Solution for HDU6602 - Longest Subarray","content":"linkSolutionLet's try to fix the right endpoint first and then find the longest subarray for each right endpoint.Let  be the index of the -th occurrence of number . Assume the current right endpoint is , for each  The left endpoint can't fall in the interval  where  is the occurrence of  until . This is because if left endpoint in that interval, the occurrence of  would be larger than zero and smaller than , which doesn't satisfy the constrain. We could add 1 on those intervals and the leftmost endpoint is the smallest index whose value is 0.Now let's consider how the intervals change when the right endpoint moves to . It's easy to see that only the interval for  will change.\nThe interval will change from  to . Note that in the implementation we don't have to change the overlapped interval.In conclusion, we need a data structure that supports range modification and global minimum value query, a.k.a. segment tree.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define size(x) int(x.size())\n#define pb push_back\n\nusing namespace std;\n\nstruct SegTree{\n    int n;\n    vector<int> t,lazy,pos;\n    SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){\n        build(1,0,n-1);\n    }\n    void pushup(int node){\n        t[node]=min(t[node<<1],t[node<<1|1]);\n        pos[node]=(t[node]==t[node<<1]?pos[node<<1]:pos[node<<1|1]);\n    }\n    void build(int node,int l,int r){\n        if(l==r){\n            pos[node]=l;\n            return;\n        }\n        int mid=(l+r)>>1;\n        build(node<<1,l,mid);\n        build(node<<1|1,mid+1,r);\n        pushup(node);\n    }\n    void addtag(int p,int x){\n        t[p]+=x;\n        lazy[p]+=x;\n    }\n    void spread(int p){\n        if(lazy[p]){\n            addtag(p<<1,lazy[p]);\n            addtag(p<<1|1,lazy[p]);\n            lazy[p]=0;\n        }\n    }\n    void update(int node,int ql,int qr,int l,int r,int x){\n        if(ql<=l&&qr>=r){\n            addtag(node,x);\n            return;\n        }\n        spread(node);\n        int mid=(l+r)>>1;\n        if(ql<=mid) update(node<<1,ql,qr,l,mid,x);\n        if(qr>mid) update(node<<1|1,ql,qr,mid+1,r,x);\n        pushup(node);\n    }\n    int query(int i){\n        return t[1]==0?i-pos[1]+1:0;\n    }\n\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,c,k;\n    while(cin>>n>>c>>k){\n        vector<vector<int>> pos(c+1,{-1});\n        vector<int> a(n);\n        for(auto& it:a) cin>>it;\n        SegTree st(n);\n        int ans=0;\n        forn(i,n){\n            auto& v=pos[a[i]];\n            v.pb(i);\n            int sz=size(v)-1;\n            if(sz<k) st.update(1,v[sz-1]+1,i,0,n-1,1);\n            else{\n                st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1);\n                st.update(1,v[sz-1]+1,i,0,n-1,1);\n            }\n            ans=max(ans,st.query(i));\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"},{"id":"NC4090E","title":"Solution for NewCoder 4090E - 最大GCD(max GCD)","content":"Problem linkTranslationGiven a sequence  of length  and  queries in format , find .SolutionSince  is rather small, we can precalculate all the factors of all the numbers smaller than . Then, for each factor, we store all the  such that  contains this factor in ascending order.For each query, we iterate all the factors from biggest to smallest and see if we can find some number in  that contains this factor. We could use binary search to achieve this.Code#include <bits/stdc++.h>\n\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n#define pb push_back\nusing namespace std;\n\nconst int N=1e5+5;\nvector<int> p[N],fac[N];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint n,q;\n\tcin>>n>>q;\n\tfor1(i,1e5){\n\t\tfor(int j=i;j<=1e5;j+=i) fac[j].pb(i);\n\t}\n\tfor1(i,n){\n\t\tint x;\n\t\tcin>>x;\n\t\tfor(auto f:fac[x]) p[f].pb(i);\n\t}\n\twhile(q--){\n\t\tint l,r,x;\n\t\tcin>>l>>r>>x;\n\t\tfor(int i=fac[x].size()-1;i>=0;i--){\n\t\t\tint f=fac[x][i];\n\t\t\tif(p[f].empty()) continue;\n\t\t\tauto it=lower_bound(p[f].begin(),p[f].end(),l);\n\t\t\tif(it!=p[f].end()&&*it<=r){\n\t\t\t\tcout<<f<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    return 0;\n}"},{"id":"PBDS_basic_usage","title":"Basic Usage of PB_DS","content":"Basic usage of Policy-Based Data Structure (PB_DS)Hash TableUsage#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ncc_hash_table<int, int> table;//collision-chaining hash table\ngp_hash_table<int, int> table;//probing hash tableUse it like a .A slightly better hash Functionstruct custom_hash {\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        x ^= FIXED_RANDOM;\n        return x ^ (x >> 16);\n    }\n};Unbeatable hash functionstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};Balanced BSTDeclarationHeader#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;Make a maptree<int, int, less<int>, rb_tree_tag, tree_order_statistics_node_update> t;Make a settree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> t;Make a multi-settree<pair<int,int>, null_type, less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> t;Alternatively, you can use , but  and  will swap their functionality.tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> t;Beyond std::set : rankingYour must use  to get order statistic:size_type order_of_key(key_const_reference);// returns the number of elements that are smaller than key\niterator find_by_order(size_type order)// order starts from 0Use lower_bound and upper_bound to find precursor and successorFind precursor:*prev(t.lower_bound(x))//set\nprev(t.lower_bound({x,0}))->first//multi-setFind successor*t.upper_bound(x);//set\n*t.lower_bound({x+1,0});Priority QueuePrototypetemplate<typename  Value_Type,\n\t  typename  Cmp_Fn = std::less<Value_Type>,\n\t  typename  Tag = pairing_heap_tag,\n\t  typename  Allocator = std::allocator<char > >\n\t  class priority_queue;UsageJust use the default parameter and you will get the best performance(must include the namespace):#include<ext/pb_ds/priority_queue.hpp>\n__gnu_pbds::priority_queue<int>;All the five tags:What's different from point_iterator push(const_reference r_val);//return a iterator after push\nvoid PB_DS_CLASS_C_DEC:: join(PB_DS_CLASS_C_DEC& other)//clean other after join\nvoid split(Pred prd,priority_queue &other)  \nvoid modify(point_iterator it,const key) \nbegin();\nend();//begin and end iteratorReferencePolicy-Based Data StructureBlowing up unordered_map, and how to stop getting hacked on itpb_ds库的一些常用方法用 pbds 过 luogu P3369【模板】普通平衡树"},{"id":"POJ2186","title":"Solution for POJ 2186 - Popular Cows","content":"My first blog in English!Solutionlink to the problemI learnt Tarjan's algorithm in this video. Very good visualization.First we find all the strongly conncted components in the given relationship graph. All the vetices in the same component can be treated as one point in the graph so we could get a DAG. The cows which is considered popular by all other cows are cows in the SCC with 0 out-degree. If there are more than one SCCs with 0 out-degree the answer is 0, otherwise the anser the number of cows in that SCC.Some details in the implementation:I used the  value as the id of each vetices so all the vertices in the same SCC can be seen as one point. values are now consecutive so when you encounter one  value with 0 out-degree, you have to change its out-degree to a none-zero value in case you count it again.Code#include<iostream>\n#include<vector>\n#include<cstring>\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define fore(i, l, r) for (int i = (int)(l); i <= (int)(r); ++i)\n#define ford(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define pb push_back\n#define ms(a, x) memset(a, x, sizeof(a))\n\n#define endl '\\n'\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint n,m;\nconst int N=1e4+5;\nvector<int> vec[N];\nint id=1;\nint ids[N],low[N];\nbool onstack[N];\nint stk[N],top=-1;\nint out[N];\nvoid dfs(int x){\n    stk[++top]=x;\n    onstack[x]=1;\n    ids[x]=low[x]=id++;\n    forn(i,vec[x].size()){\n        int to=vec[x][i];\n        if(ids[to]==-1) dfs(to);\n        if(onstack[to]) low[x]=min(low[to],low[x]);\n    }\n    if(ids[x]==low[x]){\n        while(top>-1){\n            int node=stk[top--];\n            onstack[node]=0;\n            low[node]=ids[x];\n            if(node==x) break;\n        }\n    }\n}\nvoid tarjan(){\n    for1(i,n) ids[i]=-1;\n    for1(i,n){\n        if(ids[i]==-1) dfs(i);\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n>>m;\n    forn(i,m){\n        int u,v;\n        cin>>u>>v;\n        vec[u].pb(v);\n    }\n    tarjan();\n    for1(i,n){\n        forn(j,vec[i].size()){\n            int it=vec[i][j];\n            if(low[it]!=low[i])\n            out[low[i]]++;\n        }\n    }\n    int cnt=0;\n    int p;\n    for1(i,n) if(out[low[i]]==0) {\n        out[low[i]]=1;\n        cnt++;\n        p=low[i];\n    }\n    if(cnt==1){\n        int ans=0;\n        for1(i,n) if(low[i]==p) ans++;\n        cout<<ans;\n    }else cout<<0;\n    \n    return 0;\n}"},{"id":"SWERC2017E","title":"Solution for SWERC2017 E - Ingredients","content":"LinkSolutionThe solution combines shortest paths and 0/1 knapsack algorithms:First step is to find the cost and prestige of each dish, which is finding the shortest path on a DAG. This could be done in  using topological sort. Update the cost while doing topological sort:ms(cost,INF);\nqueue<int> q;\nfor1(i,id.size()){\n\tif(deg[i]==0){\n\t\tq.push(i);\n\t\tcost[i]=0;\n\t}\n}\nwhile(!empty(q)){\n\tint now=q.front();\n\tq.pop();\n\tfor(auto [dish,cost,prestige]:G[now]){\n\t\tif(cost[now]+cost<cost[dish]){//choose the smallest cost\n\t\t\tcost[dish]=cost[now]+cost;\n\t\t\tpre[\n\t\t}else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige\n\t\t\tpre[dish]=max(pre[dish],pre[now]+prestige);\n\t\t}\n\t\tdeg[dish]--;\n\t\tif(deg[dish]==0) q.push(dish);\n\t}\n}The next part is more familiar: using 0/1 knapsack algorithm to find the answer.Code#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define for1(i, n) for (int i = 1; i <= int(n); ++i)\n\n#define pb push_back\n#define eb emplace_back\n#define ms(a, x) memset(a, x, sizeof(a))\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\n\nconst int N=1e4+5;\nvector<tuple<int,int,int>> G[N];\nint cost[N],pre[N],deg[N],dp[N];\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n,b;\n\tcin>>b>>n;\n\tunordered_map<string,int> id;\n\tauto getid=[&](string& st){\n\t\tif(id[st]) return id[st];\n\t\telse return id[st]=size(id);\n\t};\n\tforn(i,n){\n\t\tstring s,t,tmp;\n\t\tint x,y;\n\t\tcin>>s>>t>>tmp>>x>>y;\n\t\tint ids=getid(s),idt=getid(t);\n\t\tG[idt].eb(ids,x,y);\n\t\tdeg[ids]++;\n\t}\n    //topo sort\n\tms(cost,INF);\n\tqueue<int> q;\n\tfor1(i,id.size()){\n\t\tif(deg[i]==0){\n\t\t\tq.push(i);\n\t\t\tcost[i]=0;\n\t\t}\n\t}\n\twhile(!empty(q)){\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(auto [to0,to1,to2]:G[now]){\n\t\t\tif(cost[now]+to1<cost[to0]){\n\t\t\t\tcost[to0]=cost[now]+to1;\n\t\t\t\tpre[to0]=pre[now]+to2;\n\t\t\t}else if(cost[now]+to1==cost[to0]){\n\t\t\t\tpre[to0]=max(pre[to0],pre[now]+to2);\n\t\t\t}\n\t\t\tdeg[to0]--;\n\t\t\tif(deg[to0]==0) q.push(to0);\n\t\t}\n\t}\n    //knapsack\n\tfor1(i,size(id)){\n\t\tfor(int j=b;j>=cost[i];j--){\n\t\t\tdp[j]=max(dp[j],dp[j-cost[i]]+pre[i]);\n\t\t}\n\t}\n\tint ans1=0,ans2=0;\n\tfor(int i=0;i<=b;i++){\n\t\tif(dp[i]>ans1){\n\t\t\tans1=dp[i];\n\t\t\tans2=i;\n\t\t}\n\t}\n\tcout<<ans1<<endl<<ans2;\n\treturn 0;\n}"},{"id":"bundle-cpp-code","title":"Bundle C++ Code with Clang","content":"As a competitive programmer, I always want to find a solution to avoid copy-and-pasting my algorithm library so I can write more complex code lol.Inspired by Egor's rust bundler, I wondered is there something similar for C++? I remembered that I read this long time ago then I spent some time finding that blog but it's not a bundler and looks quite complicated. In the comment someone mentioned using the  command which does the preprocessing work. As you may know,  is basically copy-and-paste so this actually sounds right, but the problem is that it also copies and pastes the standard library which is over 200k+ lines of code. So I dug a bit further to see if it's possible to skip system header and found this, but it only works for clang which what I'm using so I didn't look for a solution for gcc.The command is:clang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc main.cpp > bundled.cppExplanation: Only run the preprocessor Disable linemarker output in -E mode Disable standard #include directories for the C++ standard library Disable builtin #include directories (may not be needed)As  of system header isn't preserved, you can add the system headers using another command and I made a shell function to do that:expand_cpp () {\n\tclang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc $1 > bundled.cpp\n\tgsed -i \"1s/^/#include <bits\\/stdc++.h>\\n/\" bundled.cpp\n}"},{"id":"cloudflare-workers-and-pages","title":"Fast Static Website Deployment with Cloudflare Workers and Pages","content":"If you are developing a simple static website like a blog or wiki, you probably don't really like to play with a hosting service involving a remote repository like GitHub pages. Pushing to the remote repo every time you make changes and waiting for the building process is not that pleasant. With Cloudflare Workers/Pages, you can upload your website directly using Wrangler.InstallationInstall Wrangler globally:npm install -g wranglerAuthenticationThere are two ways of authentication:If you are using it on your own computer, you can use OAuth in your browser to login by running .set  and  environmental variables.API token can be generated herefor workers, you can use the \"Edit Cloudflare Workers\" template.for pages, follow the offical guice here.To find your account ID, log in to the Cloudflare dashboard > select your zone in Account Home > find your account ID in Overview under API on the right-side menu.Cloudflare WorkersCloudflare Worker is flexible and powerful. You can do much more than hosting website. You websites are stored in the KV storage.To deploy your website:copy wrangler.toml to your project directory.change  to your website directory, e.g.  folder for a hugo website.optionally, add  to set custom domain/route for your website.create  folder and copy index.jsin the  folder, run finally, back to the folder where you put , run  to deploy your website.Cloudflare PagesCloudflare Pages is meant to replace the website hosting functionality of Workers. It supports lots of front-end framework so you can deploy your front-end application very easily. You can still upload locally with  but it doesn't work that well (it failed to upload my hugo blog).The upload is pretty easy: simple run  and follow the instruction."},{"id":"cugb8","title":"Solution for CUGBACM Training","content":"LinkA - Watching TV Gym - 101498AUse a  to count the number of channels in each frequency. Iterate the map to find the frequency that displays the largest number of channels.B - Longest Prefix Gym - 101498BSwapping any two letters means that you can rearrange the second string so just count the number of each character in the second string and then iterate the first string to see if you can put the same in each position. When you stops, that's the longest prefix.C - Lunch Break Gym - 101498CJust output which one is the smallest among the three numbersD - Counting Paths Gym - 101498DThe first direction can be chosen arbitrarily. In the rest  nodes we need to choose  nodes where to change the direction so the answer is . As the  and  are large so we need to precalculate  and  .E - Car Factory Gym - 101498EBy drawing some sketchs you can find the answer is .H - Palindrome NumberStart from the first digit and try to fill every digits with the largest number. If the sum is less than  or there is leading zero, the answer is -1 otherwise output the constructed number.I - Rock Piles Gym - 101498IAt first I counldn't find any pattern so I decided to get the sg function using brute force. Here is the pattern: only when both  and  are even the answer is \"abdullah\" otherwise the answer is hasan.J - Split the String Gym - 101498JEnumerate all the possible disstance between two splitting point and check if all the splitting points are space. If you could find such a distance the answer is \"YES\" and vise versa."},{"id":"debugConfig","title":"VSCode C++ debug configurations","content":"task.json{\r\n  \"version\": \"2.0.0\",\r\n  \"tasks\": [\r\n    {\r\n      \"label\": \"task\",\r\n      \"type\": \"shell\",\r\n      \"command\": \"g++\",\r\n      \"args\": [\r\n        \"-g\",\r\n        \"${file}\",\r\n        \"-o\",\r\n        \"${fileDirname}/${fileBasenameNoExtension}.exe\"\r\n      ],\r\n      \"group\": {\r\n        \"kind\": \"build\",\r\n        \"isDefault\": true\r\n      }\r\n    }\r\n  ]\r\n}launch.json{\r\n  \"version\": \"0.2.0\",\r\n  \"configurations\": [\r\n    {\r\n      \"name\": \"C++ Launch\",\r\n      \"type\": \"cppdbg\",\r\n      \"request\": \"launch\",\r\n      \"program\": \"${workspaceRoot}/${fileBasenameNoExtension}.exe\",\r\n      \"stopAtEntry\": false,\r\n      \"externalConsole\": true,\r\n      \"cwd\": \"${workspaceFolder}\",\r\n      \"preLaunchTask\": \"task\",\r\n      \"windows\": {\r\n        \"MIMode\": \"gdb\",\r\n        \"miDebuggerPath\": \"replace this with your gdb path\"\r\n      }\r\n    }\r\n  ]\r\n}"},{"id":"debug_output_header","title":"Use Custom Header File to Facilitate Local Debugging","content":"Printing out information is probably the fastest way to debug in competitive programming, but you have to commenting out these lines before submitting, which is time-consuming and error-prone. Printing to stderr is better but it can slow your program down. We can solve this by using pre-written printing functions combining with  to differentiate local and judge environment.For printing function I'm using pretty printer which does a really nice job. Then add the line below to your code and you can use  to print things and don't have to worry about messing up your output.#ifdef LOCAL\n#include<pprint.hpp> // https://github.com/p-ranav/pprint\npprint::PrettyPrinter _printer(std::cerr);\n#define de(...) _printer.compact(true).print('[', #__VA_ARGS__,\"] =\", __VA_ARGS__)\n#define de2(...) _printer.compact(false).print('[', #__VA_ARGS__,\"] =\", __VA_ARGS__)\n#else\n#define de(...)\n#define de2(...)\n#endifNote that you need to add the directory where your  is to the  environmental variable, or use the  flag while compiling, or just put  inside your  system include directory.If you think the above code is too long, you can put this part:#ifdef LOCAL\n#include<pprint.hpp> // https://github.com/p-ranav/pprint\npprint::PrettyPrinter _printer(std::cerr);\n#define de(...) _printer.compact(true).print('[', #__VA_ARGS__,\"] =\", __VA_ARGS__)\n#define de2(...) _printer.compact(false).print('[', #__VA_ARGS__,\"] =\", __VA_ARGS__)\n#endifin your , and only leave this part in your code:#ifndef LOCAL\n#define de(...)\n#define de2(...)\n#endifUse  flag while compiling to define , you can use other word but make sure it's not defined in the judge."},{"id":"dijkExtention","title":"Extension of Dijkstra","content":"Just as a reminder with simple explanation.Path ReconstructionUse  to record the previous vertices of all the vertices in the shortest path(s). When updating the distance to vertex , if the current distance is better, discard the previous record and let the current vertex be the previous vertex of . If the distance is the same, just add the current vertex to .for(pii it:E[u]){\r\n    ll v=it.S,cost=it.F;\r\n    if(!vis[v]&&dis[v]>dis[u]+cost){\r\n        dis[v]=dis[u]+cost;\r\n        pre[v].clear();\r\n        pre[v].pb({cost,u});\r\n        q.push({dis[v],v});\r\n    }else if(dis[v]==dis[u]+cost)\r\n        pre[v].pb({cost,u});\r\n}Number of shortest pathsSimilar to recording the path, if the distance is better then let the number be one. If the same, plus 1.if(!vis[v]&&dis[u]+cost<dis[v]){\r\n    cnt[v]=1;\r\n    dis[v]=dis[u]+cost;\r\n}else if(dis[u]+cost==dis[v]){\r\n    cnt[v]++;\r\n}"},{"id":"easy-ssl-for-local-services","title":"Easy SSL Certificates for Local Services in Your Home Lab","content":"The method comes form a video of Walfgang's Channel. This post is just a note of that video for experienced people.The key point is that you can create a DNS record that points to your local IP address.Prerequisite: a domain name, a reverse proxy (I'm using Nginx Proxy Manager here), a SSL certificate of the domain that you'll be using.Step 1: create a A DNS record that points to the local IP address of your server, e.g. .Step 2: in your reverse proxy, proxy the domain to your local service and you can use your SSL certificate.It's just this easy!"},{"id":"gcj2021_r2_matrygons","title":"Solution for Google Code Jam 2021 R2 Matrygons","content":"Went the wrong direction during the contest. :disappointed:SolutionLet the number of edges of the polygons be . It's easy to find that  has to be a multiple of , thus we can rewrite  as . Hence if we know the number of edges of the first polygon, all we left if to find the longest sequence  such that   is a multiple if  and .Note that  are all multiple of , so if we divide them by  we get a sequence starting with  again! This means we get a smaller subproblem and we can use dynamic programming to solve it: let  be the length of the longest such sequence described above which sums to . Since we can get a longer sequence by multiplying a shorter one by a constant and prepending a , so the transition is:\nCode#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt = 1;\n    cin >> tt;\n    constexpr int N = 1e6;\n    vector<int> dp(N + 1, 1);\n    for (int i = 1; i <= N; i++) {\n        for (int j = 2 * i + 1; j <= N; j += i) {\n            dp[j] = max(dp[j], dp[i] + 1);\n        }\n    }\n    for (int cas = 1; cas <= tt; cas++) {\n        int x;\n        cin >> x;\n        int ans = 1;\n        cout << \"Case #\" << cas << \": \";\n        for (int f = 3; f <= x; f++) {\n            if (x % f == 0)  ans = max(ans, dp[x / f]);\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}"},{"id":"kattis-goldbandits","title":"Solution to NAIPC2014 F - Gold Bandits","content":"This problem is North American Invitational Programming Contest (NAIPC) 2014 F，link to the problem。SolutionAs n is small, we can consider brute force each shortest path. Then let's rephrase the problem: we first take the gold from all the village on the path to the castle, then we return it if we go through a village that we steal before when returning to home. Then finding the returning path becomes a shortest path problem: the cost of the vertex  is  if we steal it before, is 0 otherwise.Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int i = 2; i < n; i++)\n        cin >> a[i];\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    queue<int> q;\n    q.push(0);\n    vector<int> dep(n, -1);\n    dep[0] = 0;\n    while (!q.empty()) {\n        auto u = q.front();\n        q.pop();\n        for (auto v : g[u]) {\n            if (dep[v] == -1) {\n                dep[v] = dep[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    int ans = 0;\n    vector<bool> vis(n);\n    auto dijkstra = [&]() {\n        vector<int> dis(n, -1);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> q;\n        dis[0] = 0;\n        q.emplace(0, 0);\n        while (!q.empty()) {\n            auto [d, u] = q.top();\n            q.pop();\n            if (d != dis[u]) continue;\n            for (auto v : g[u]) {\n                int nd = d + (vis[v] ? a[v] : 0);\n                if (dis[v] == -1 || nd < dis[v]) {\n                    dis[v] = nd;\n                    q.emplace(nd, v);\n                }\n            }\n        }\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i]) sum += a[i];\n        }\n        ans = max(ans, sum - dis[1]);\n    };\n    auto dfs = [&](auto &me, int u) -> void {\n        vis[u] = true;\n        for (auto v : g[u]) {\n            if (v == 1) dijkstra();\n            else if (dep[v] == dep[u] + 1 && dep[v] < dep[1])\n                me(me, v);\n        }\n        vis[u] = false;\n    };\n    dfs(dfs, 0);\n    cout << ans << '\\n';\n    return 0;\n}"},{"id":"longestPathOnDAG","title":"Finding the longest path on a DAG","content":"vector<int> G[N];\nint dp[N];\n\nint get(int u){\n\tif(dp[u]) return dp[u];\n\tfor(auto it:G[u]){\n\t\tdp[u]=max(dp[u],get(it)+1);\n\t}\n\treturn dp[u];\n}"},{"id":"manage-python-with-pyenv","title":"Manage Python Version With Pyenv","content":"There is problem managing python version with your package manager. An easy solution is to use pyenv:Install pyenv with your package manager. For MacOS, it's .Install desired python version: Set global python version Set up your shell environment for Pyenv, for zsh, add this to your :export PYENV_ROOT=\"$HOME/.pyenv\"\ncommand -v pyenv >/dev/null || export PATH=\"$PYENV_ROOT/bin:$PATH\"\neval \"$(pyenv init -)\""},{"id":"modular_mul_inverse","title":"Algorithm note: Modular Multiplicative Inverse and Modulo of Combinations","content":"What is Modular Multiplicative Inverse?If ,  is called a inverse of a(modulo p), referred to as . We usually use the minimum positive inverse.The use of InverseThe inverse is used when calculating the modulo of division.The ways to calculate the inverse of a numberThe Extended Euclidean algorithmWe can rewrite  as  which can be solved using the Extended Euclidean algorithm.void exgcd(int a, int b, int& x, int& y) {\r\n  if (b == 0) {\r\n    x = 1, y = 0;\r\n    return;\r\n  }\r\n  exgcd(b, a % b, y, x);\r\n  y -= a / b * x;\r\n}The Fermat's Little TheoremAccording to Fermat's Little Theorem , thus , . We can calculate it using Exponentiation by squaring.inline int qpow(long long a, int b) {\r\n  int ans = 1;\r\n  a = (a % p + p) % p;\r\n  for (; b; b >>= 1) {\r\n    if (b & 1) ans = (a * ans) % p;\r\n    a = (a * a) % p;\r\n  }\r\n  return ans;\r\n}Calculate consecutive inverses in linear timeinv[1] = 1;\r\nfor (int i = 2; i <= n; ++i) inv[i] = (long long)(p - p / i) * inv[p % i] % p;Modulo of CombinationsCalculate When n and m are not too bigWe can use the inverse to calculate Calculate the inverse of factorialThereforeis an inverse of .fact[0] = 1;\r\nfor (int i = 1; i < maxn; i++) {\r\n    fact[i] = fact[i - 1] * i %mod;\r\n}\r\ninv[maxn - 1] = power(fact[maxn - 1], mod - 2);\r\nfor (int i = maxn - 2; i >= 0; i--) {\r\n    inv[i] = inv[i + 1] * (i + 1) %mod;\r\n}When n and m are really big but p is not too biglong long Lucas(long long n, long long m, long long p) {\r\n  if (m == 0) return 1;\r\n  return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;\r\n}"},{"id":"segUnion","title":"Two Ways to Do Segment Union","content":"Klee's Algorithmoriginint length_union(const vector<pair<int, int>> &a) {\n    int n = a.size();\n    vector<pair<int, bool>> x(n*2);\n    for (int i = 0; i < n; i++) {\n        x[i*2] = {a[i].first, false};\n        x[i*2+1] = {a[i].second, true};\n    }\n\n    sort(x.begin(), x.end());\n\n    int result = 0;\n    int c = 0;\n    for (int i = 0; i < n * 2; i++) {\n        if (i > 0 && x[i].first > x[i-1].first && c > 0)\n            result += x[i].first - x[i-1].first;\n        if (x[i].second) c--;\n        else c++;\n    }\n    return result;\n}One algorithm that I learnt from other's codeint length_union(const vector<pair<int, int>> &a) {\n    int n = a.size();\n    sort(a.begin(), a.end());\n    int result = 0;\n    int rr = 0;\n    for(pii it:a){\n        int l=it.fist,r=it.second;\n        result+=max(0,r-max(rr,l));\n        rr=max(rr,r);\n    }\n    return result;\n}"}]